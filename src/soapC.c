/* soapC.c
   Generated by gSOAP 2.7.13 from all_hdrs.h
   Copyright(C) 2000-2009, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.7.13 2009-07-14 14:42:11 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header));
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_xsd__int:
		return soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_Security:
		return soap_in_Security(soap, NULL, NULL, "Security");
	case SOAP_TYPE_UsernameToken:
		return soap_in_UsernameToken(soap, NULL, NULL, "UsernameToken");
	case SOAP_TYPE_stringWithAttr:
		return soap_in_stringWithAttr(soap, NULL, NULL, "stringWithAttr");
	case SOAP_TYPE_cptn__addNode:
		return soap_in_cptn__addNode(soap, NULL, NULL, "cptn:addNode");
	case SOAP_TYPE_cptn__Destroy:
		return soap_in_cptn__Destroy(soap, NULL, NULL, "cptn:Destroy");
	case SOAP_TYPE_cptn__destroyResponse:
		return soap_in_cptn__destroyResponse(soap, NULL, NULL, "cptn:destroyResponse");
	case SOAP_TYPE_cptn__addNodeResponse:
		return soap_in_cptn__addNodeResponse(soap, NULL, NULL, "cptn:addNodeResponse");
	case SOAP_TYPE_cpt__getActiveTrees:
		return soap_in_cpt__getActiveTrees(soap, NULL, NULL, "cpt:getActiveTrees");
	case SOAP_TYPE_cpt__Destroy:
		return soap_in_cpt__Destroy(soap, NULL, NULL, "cpt:Destroy");
	case SOAP_TYPE_cpt__findByHandle:
		return soap_in_cpt__findByHandle(soap, NULL, NULL, "cpt:findByHandle");
	case SOAP_TYPE_cpt__createNewTree:
		return soap_in_cpt__createNewTree(soap, NULL, NULL, "cpt:createNewTree");
	case SOAP_TYPE_cpt__destroyResponse:
		return soap_in_cpt__destroyResponse(soap, NULL, NULL, "cpt:destroyResponse");
	case SOAP_TYPE_cpt__createNewTreeResponse:
		return soap_in_cpt__createNewTreeResponse(soap, NULL, NULL, "cpt:createNewTreeResponse");
	case SOAP_TYPE_cpt__getActiveTreesResponse:
		return soap_in_cpt__getActiveTreesResponse(soap, NULL, NULL, "cpt:getActiveTreesResponse");
	case SOAP_TYPE_cpt__findByHandleResponse:
		return soap_in_cpt__findByHandleResponse(soap, NULL, NULL, "cpt:findByHandleResponse");
	case SOAP_TYPE_rsg__Add:
		return soap_in_rsg__Add(soap, NULL, NULL, "rsg:Add");
	case SOAP_TYPE_rsg__AddResponse:
		return soap_in_rsg__AddResponse(soap, NULL, NULL, "rsg:AddResponse");
	case SOAP_TYPE_swsf__createSWSResource:
		return soap_in_swsf__createSWSResource(soap, NULL, NULL, "swsf:createSWSResource");
	case SOAP_TYPE_swsf__createSWSResourceResponse:
		return soap_in_swsf__createSWSResourceResponse(soap, NULL, NULL, "swsf:createSWSResourceResponse");
	case SOAP_TYPE_wsrp__Destroy:
		return soap_in_wsrp__Destroy(soap, NULL, NULL, "wsrp:Destroy");
	case SOAP_TYPE_sws__PutParamLog:
		return soap_in_sws__PutParamLog(soap, NULL, NULL, "sws:PutParamLog");
	case SOAP_TYPE_sws__GetParamLog:
		return soap_in_sws__GetParamLog(soap, NULL, NULL, "sws:GetParamLog");
	case SOAP_TYPE_sws__RecordCheckpoint:
		return soap_in_sws__RecordCheckpoint(soap, NULL, NULL, "sws:RecordCheckpoint");
	case SOAP_TYPE_sws__Detach:
		return soap_in_sws__Detach(soap, NULL, NULL, "sws:Detach");
	case SOAP_TYPE_sws__Attach:
		return soap_in_sws__Attach(soap, NULL, NULL, "sws:Attach");
	case SOAP_TYPE_sws__AddChild:
		return soap_in_sws__AddChild(soap, NULL, NULL, "sws:AddChild");
	case SOAP_TYPE_wsrp__GetResourcePropertyDocument:
		return soap_in_wsrp__GetResourcePropertyDocument(soap, NULL, NULL, "wsrp:GetResourcePropertyDocument");
	case SOAP_TYPE_wsrp__SetResourceProperties:
		return soap_in_wsrp__SetResourceProperties(soap, NULL, NULL, "wsrp:SetResourceProperties");
	case SOAP_TYPE_wsrp__GetMultipleResourceProperties:
		return soap_in_wsrp__GetMultipleResourceProperties(soap, NULL, NULL, "wsrp:GetMultipleResourceProperties");
	case SOAP_TYPE_sws__DetachResponse:
		return soap_in_sws__DetachResponse(soap, NULL, NULL, "sws:DetachResponse");
	case SOAP_TYPE_sws__AddChildResponse:
		return soap_in_sws__AddChildResponse(soap, NULL, NULL, "sws:AddChildResponse");
	case SOAP_TYPE_sws__AddChildRequest:
		return soap_in_sws__AddChildRequest(soap, NULL, NULL, "sws:AddChildRequest");
	case SOAP_TYPE_wsrp__SetResourcePropertiesResponse:
		return soap_in_wsrp__SetResourcePropertiesResponse(soap, NULL, NULL, "wsrp:SetResourcePropertiesResponse");
	case SOAP_TYPE_wsrp__GetMultipleResourcePropertiesRequest:
		return soap_in_wsrp__GetMultipleResourcePropertiesRequest(soap, NULL, NULL, "wsrp:GetMultipleResourcePropertiesRequest");
	case SOAP_TYPE_wsrp__ResourcePropertyStruct:
		return soap_in_wsrp__ResourcePropertyStruct(soap, NULL, NULL, "wsrp:ResourcePropertyStruct");
	case SOAP_TYPE_sws__PutParamLogResponse:
		return soap_in_sws__PutParamLogResponse(soap, NULL, NULL, "sws:PutParamLogResponse");
	case SOAP_TYPE_wsrp__DestroyResponse:
		return soap_in_wsrp__DestroyResponse(soap, NULL, NULL, "wsrp:DestroyResponse");
	case SOAP_TYPE_sws__AttachResponse:
		return soap_in_sws__AttachResponse(soap, NULL, NULL, "sws:AttachResponse");
	case SOAP_TYPE_reg__steerMessage:
		return soap_in_reg__steerMessage(soap, NULL, NULL, "reg:steerMessage");
	case SOAP_TYPE_reg__supp_cmds:
		return soap_in_reg__supp_cmds(soap, NULL, NULL, "reg:supp-cmds");
	case SOAP_TYPE_reg__Command:
		return soap_in_reg__Command(soap, NULL, NULL, "reg:Command");
	case SOAP_TYPE_sws__RecordCheckpointResponse:
		return soap_in_sws__RecordCheckpointResponse(soap, NULL, NULL, "sws:RecordCheckpointResponse");
	case SOAP_TYPE_sws__GetParamLogResponse:
		return soap_in_sws__GetParamLogResponse(soap, NULL, NULL, "sws:GetParamLogResponse");
	case SOAP_TYPE_epr:
		return soap_in_epr(soap, NULL, NULL, "epr");
	case SOAP_TYPE_PointerTocptn__addNodeResponse:
		return soap_in_PointerTocptn__addNodeResponse(soap, NULL, NULL, "cptn:addNodeResponse");
	case SOAP_TYPE_PointerTocptn__destroyResponse:
		return soap_in_PointerTocptn__destroyResponse(soap, NULL, NULL, "cptn:destroyResponse");
	case SOAP_TYPE_PointerTocpt__getActiveTreesResponse:
		return soap_in_PointerTocpt__getActiveTreesResponse(soap, NULL, NULL, "cpt:getActiveTreesResponse");
	case SOAP_TYPE_PointerTocpt__destroyResponse:
		return soap_in_PointerTocpt__destroyResponse(soap, NULL, NULL, "cpt:destroyResponse");
	case SOAP_TYPE_PointerTocpt__findByHandleResponse:
		return soap_in_PointerTocpt__findByHandleResponse(soap, NULL, NULL, "cpt:findByHandleResponse");
	case SOAP_TYPE_PointerTocpt__createNewTreeResponse:
		return soap_in_PointerTocpt__createNewTreeResponse(soap, NULL, NULL, "cpt:createNewTreeResponse");
	case SOAP_TYPE_PointerTorsg__AddResponse:
		return soap_in_PointerTorsg__AddResponse(soap, NULL, NULL, "rsg:AddResponse");
	case SOAP_TYPE_PointerToswsf__createSWSResourceResponse:
		return soap_in_PointerToswsf__createSWSResourceResponse(soap, NULL, NULL, "swsf:createSWSResourceResponse");
	case SOAP_TYPE_PointerTowsrp__DestroyResponse:
		return soap_in_PointerTowsrp__DestroyResponse(soap, NULL, NULL, "wsrp:DestroyResponse");
	case SOAP_TYPE_PointerTosws__PutParamLogResponse:
		return soap_in_PointerTosws__PutParamLogResponse(soap, NULL, NULL, "sws:PutParamLogResponse");
	case SOAP_TYPE_PointerTosws__GetParamLogResponse:
		return soap_in_PointerTosws__GetParamLogResponse(soap, NULL, NULL, "sws:GetParamLogResponse");
	case SOAP_TYPE_PointerTosws__RecordCheckpointResponse:
		return soap_in_PointerTosws__RecordCheckpointResponse(soap, NULL, NULL, "sws:RecordCheckpointResponse");
	case SOAP_TYPE_PointerTosws__DetachResponse:
		return soap_in_PointerTosws__DetachResponse(soap, NULL, NULL, "sws:DetachResponse");
	case SOAP_TYPE_PointerTosws__AttachResponse:
		return soap_in_PointerTosws__AttachResponse(soap, NULL, NULL, "sws:AttachResponse");
	case SOAP_TYPE_PointerTosws__AddChildResponse:
		return soap_in_PointerTosws__AddChildResponse(soap, NULL, NULL, "sws:AddChildResponse");
	case SOAP_TYPE_PointerTowsrp__SetResourcePropertiesResponse:
		return soap_in_PointerTowsrp__SetResourcePropertiesResponse(soap, NULL, NULL, "wsrp:SetResourcePropertiesResponse");
	case SOAP_TYPE_PointerTowsrp__ResourcePropertyStruct:
		return soap_in_PointerTowsrp__ResourcePropertyStruct(soap, NULL, NULL, "wsrp:ResourcePropertyStruct");
	case SOAP_TYPE_PointerToreg__Command:
		return soap_in_PointerToreg__Command(soap, NULL, NULL, "reg:Command");
	case SOAP_TYPE_xsd__string:
	{	char **s;
		s = soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_xsd__int;
			return soap_in_xsd__int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Security"))
		{	*type = SOAP_TYPE_Security;
			return soap_in_Security(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "UsernameToken"))
		{	*type = SOAP_TYPE_UsernameToken;
			return soap_in_UsernameToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "stringWithAttr"))
		{	*type = SOAP_TYPE_stringWithAttr;
			return soap_in_stringWithAttr(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cptn:addNode"))
		{	*type = SOAP_TYPE_cptn__addNode;
			return soap_in_cptn__addNode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cptn:Destroy"))
		{	*type = SOAP_TYPE_cptn__Destroy;
			return soap_in_cptn__Destroy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cptn:destroyResponse"))
		{	*type = SOAP_TYPE_cptn__destroyResponse;
			return soap_in_cptn__destroyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cptn:addNodeResponse"))
		{	*type = SOAP_TYPE_cptn__addNodeResponse;
			return soap_in_cptn__addNodeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cpt:getActiveTrees"))
		{	*type = SOAP_TYPE_cpt__getActiveTrees;
			return soap_in_cpt__getActiveTrees(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cpt:Destroy"))
		{	*type = SOAP_TYPE_cpt__Destroy;
			return soap_in_cpt__Destroy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cpt:findByHandle"))
		{	*type = SOAP_TYPE_cpt__findByHandle;
			return soap_in_cpt__findByHandle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cpt:createNewTree"))
		{	*type = SOAP_TYPE_cpt__createNewTree;
			return soap_in_cpt__createNewTree(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cpt:destroyResponse"))
		{	*type = SOAP_TYPE_cpt__destroyResponse;
			return soap_in_cpt__destroyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cpt:createNewTreeResponse"))
		{	*type = SOAP_TYPE_cpt__createNewTreeResponse;
			return soap_in_cpt__createNewTreeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cpt:getActiveTreesResponse"))
		{	*type = SOAP_TYPE_cpt__getActiveTreesResponse;
			return soap_in_cpt__getActiveTreesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cpt:findByHandleResponse"))
		{	*type = SOAP_TYPE_cpt__findByHandleResponse;
			return soap_in_cpt__findByHandleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rsg:Add"))
		{	*type = SOAP_TYPE_rsg__Add;
			return soap_in_rsg__Add(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rsg:AddResponse"))
		{	*type = SOAP_TYPE_rsg__AddResponse;
			return soap_in_rsg__AddResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swsf:createSWSResource"))
		{	*type = SOAP_TYPE_swsf__createSWSResource;
			return soap_in_swsf__createSWSResource(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swsf:createSWSResourceResponse"))
		{	*type = SOAP_TYPE_swsf__createSWSResourceResponse;
			return soap_in_swsf__createSWSResourceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:Destroy"))
		{	*type = SOAP_TYPE_wsrp__Destroy;
			return soap_in_wsrp__Destroy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:PutParamLog"))
		{	*type = SOAP_TYPE_sws__PutParamLog;
			return soap_in_sws__PutParamLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:GetParamLog"))
		{	*type = SOAP_TYPE_sws__GetParamLog;
			return soap_in_sws__GetParamLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:RecordCheckpoint"))
		{	*type = SOAP_TYPE_sws__RecordCheckpoint;
			return soap_in_sws__RecordCheckpoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:Detach"))
		{	*type = SOAP_TYPE_sws__Detach;
			return soap_in_sws__Detach(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:Attach"))
		{	*type = SOAP_TYPE_sws__Attach;
			return soap_in_sws__Attach(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:AddChild"))
		{	*type = SOAP_TYPE_sws__AddChild;
			return soap_in_sws__AddChild(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:GetResourcePropertyDocument"))
		{	*type = SOAP_TYPE_wsrp__GetResourcePropertyDocument;
			return soap_in_wsrp__GetResourcePropertyDocument(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:SetResourceProperties"))
		{	*type = SOAP_TYPE_wsrp__SetResourceProperties;
			return soap_in_wsrp__SetResourceProperties(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:GetMultipleResourceProperties"))
		{	*type = SOAP_TYPE_wsrp__GetMultipleResourceProperties;
			return soap_in_wsrp__GetMultipleResourceProperties(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:DetachResponse"))
		{	*type = SOAP_TYPE_sws__DetachResponse;
			return soap_in_sws__DetachResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:AddChildResponse"))
		{	*type = SOAP_TYPE_sws__AddChildResponse;
			return soap_in_sws__AddChildResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:AddChildRequest"))
		{	*type = SOAP_TYPE_sws__AddChildRequest;
			return soap_in_sws__AddChildRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:SetResourcePropertiesResponse"))
		{	*type = SOAP_TYPE_wsrp__SetResourcePropertiesResponse;
			return soap_in_wsrp__SetResourcePropertiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:GetMultipleResourcePropertiesRequest"))
		{	*type = SOAP_TYPE_wsrp__GetMultipleResourcePropertiesRequest;
			return soap_in_wsrp__GetMultipleResourcePropertiesRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:ResourcePropertyStruct"))
		{	*type = SOAP_TYPE_wsrp__ResourcePropertyStruct;
			return soap_in_wsrp__ResourcePropertyStruct(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:PutParamLogResponse"))
		{	*type = SOAP_TYPE_sws__PutParamLogResponse;
			return soap_in_sws__PutParamLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:DestroyResponse"))
		{	*type = SOAP_TYPE_wsrp__DestroyResponse;
			return soap_in_wsrp__DestroyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:AttachResponse"))
		{	*type = SOAP_TYPE_sws__AttachResponse;
			return soap_in_sws__AttachResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "reg:steerMessage"))
		{	*type = SOAP_TYPE_reg__steerMessage;
			return soap_in_reg__steerMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "reg:supp-cmds"))
		{	*type = SOAP_TYPE_reg__supp_cmds;
			return soap_in_reg__supp_cmds(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "reg:Command"))
		{	*type = SOAP_TYPE_reg__Command;
			return soap_in_reg__Command(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:RecordCheckpointResponse"))
		{	*type = SOAP_TYPE_sws__RecordCheckpointResponse;
			return soap_in_sws__RecordCheckpointResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:GetParamLogResponse"))
		{	*type = SOAP_TYPE_sws__GetParamLogResponse;
			return soap_in_sws__GetParamLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "epr"))
		{	*type = SOAP_TYPE_epr;
			return soap_in_epr(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_xsd__string;
			s = soap_in_xsd__string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_xsd__int:
		return soap_out_xsd__int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_Security:
		return soap_out_Security(soap, tag, id, (const struct Security *)ptr, "Security");
	case SOAP_TYPE_UsernameToken:
		return soap_out_UsernameToken(soap, tag, id, (const struct UsernameToken *)ptr, "UsernameToken");
	case SOAP_TYPE_stringWithAttr:
		return soap_out_stringWithAttr(soap, tag, id, (const struct stringWithAttr *)ptr, "stringWithAttr");
	case SOAP_TYPE_cptn__addNode:
		return soap_out_cptn__addNode(soap, tag, id, (const struct cptn__addNode *)ptr, "cptn:addNode");
	case SOAP_TYPE_cptn__Destroy:
		return soap_out_cptn__Destroy(soap, tag, id, (const struct cptn__Destroy *)ptr, "cptn:Destroy");
	case SOAP_TYPE_cptn__destroyResponse:
		return soap_out_cptn__destroyResponse(soap, tag, id, (const struct cptn__destroyResponse *)ptr, "cptn:destroyResponse");
	case SOAP_TYPE_cptn__addNodeResponse:
		return soap_out_cptn__addNodeResponse(soap, tag, id, (const struct cptn__addNodeResponse *)ptr, "cptn:addNodeResponse");
	case SOAP_TYPE_cpt__getActiveTrees:
		return soap_out_cpt__getActiveTrees(soap, tag, id, (const struct cpt__getActiveTrees *)ptr, "cpt:getActiveTrees");
	case SOAP_TYPE_cpt__Destroy:
		return soap_out_cpt__Destroy(soap, tag, id, (const struct cpt__Destroy *)ptr, "cpt:Destroy");
	case SOAP_TYPE_cpt__findByHandle:
		return soap_out_cpt__findByHandle(soap, tag, id, (const struct cpt__findByHandle *)ptr, "cpt:findByHandle");
	case SOAP_TYPE_cpt__createNewTree:
		return soap_out_cpt__createNewTree(soap, tag, id, (const struct cpt__createNewTree *)ptr, "cpt:createNewTree");
	case SOAP_TYPE_cpt__destroyResponse:
		return soap_out_cpt__destroyResponse(soap, tag, id, (const struct cpt__destroyResponse *)ptr, "cpt:destroyResponse");
	case SOAP_TYPE_cpt__createNewTreeResponse:
		return soap_out_cpt__createNewTreeResponse(soap, tag, id, (const struct cpt__createNewTreeResponse *)ptr, "cpt:createNewTreeResponse");
	case SOAP_TYPE_cpt__getActiveTreesResponse:
		return soap_out_cpt__getActiveTreesResponse(soap, tag, id, (const struct cpt__getActiveTreesResponse *)ptr, "cpt:getActiveTreesResponse");
	case SOAP_TYPE_cpt__findByHandleResponse:
		return soap_out_cpt__findByHandleResponse(soap, tag, id, (const struct cpt__findByHandleResponse *)ptr, "cpt:findByHandleResponse");
	case SOAP_TYPE_rsg__Add:
		return soap_out_rsg__Add(soap, tag, id, (const struct rsg__Add *)ptr, "rsg:Add");
	case SOAP_TYPE_rsg__AddResponse:
		return soap_out_rsg__AddResponse(soap, tag, id, (const struct rsg__AddResponse *)ptr, "rsg:AddResponse");
	case SOAP_TYPE_swsf__createSWSResource:
		return soap_out_swsf__createSWSResource(soap, tag, id, (const struct swsf__createSWSResource *)ptr, "swsf:createSWSResource");
	case SOAP_TYPE_swsf__createSWSResourceResponse:
		return soap_out_swsf__createSWSResourceResponse(soap, tag, id, (const struct swsf__createSWSResourceResponse *)ptr, "swsf:createSWSResourceResponse");
	case SOAP_TYPE_wsrp__Destroy:
		return soap_out_wsrp__Destroy(soap, tag, id, (const struct wsrp__Destroy *)ptr, "wsrp:Destroy");
	case SOAP_TYPE_sws__PutParamLog:
		return soap_out_sws__PutParamLog(soap, tag, id, (const struct sws__PutParamLog *)ptr, "sws:PutParamLog");
	case SOAP_TYPE_sws__GetParamLog:
		return soap_out_sws__GetParamLog(soap, tag, id, (const struct sws__GetParamLog *)ptr, "sws:GetParamLog");
	case SOAP_TYPE_sws__RecordCheckpoint:
		return soap_out_sws__RecordCheckpoint(soap, tag, id, (const struct sws__RecordCheckpoint *)ptr, "sws:RecordCheckpoint");
	case SOAP_TYPE_sws__Detach:
		return soap_out_sws__Detach(soap, tag, id, (const struct sws__Detach *)ptr, "sws:Detach");
	case SOAP_TYPE_sws__Attach:
		return soap_out_sws__Attach(soap, tag, id, (const struct sws__Attach *)ptr, "sws:Attach");
	case SOAP_TYPE_sws__AddChild:
		return soap_out_sws__AddChild(soap, tag, id, (const struct sws__AddChild *)ptr, "sws:AddChild");
	case SOAP_TYPE_wsrp__GetResourcePropertyDocument:
		return soap_out_wsrp__GetResourcePropertyDocument(soap, tag, id, (const struct wsrp__GetResourcePropertyDocument *)ptr, "wsrp:GetResourcePropertyDocument");
	case SOAP_TYPE_wsrp__SetResourceProperties:
		return soap_out_wsrp__SetResourceProperties(soap, tag, id, (const struct wsrp__SetResourceProperties *)ptr, "wsrp:SetResourceProperties");
	case SOAP_TYPE_wsrp__GetMultipleResourceProperties:
		return soap_out_wsrp__GetMultipleResourceProperties(soap, tag, id, (const struct wsrp__GetMultipleResourceProperties *)ptr, "wsrp:GetMultipleResourceProperties");
	case SOAP_TYPE_sws__DetachResponse:
		return soap_out_sws__DetachResponse(soap, tag, id, (const struct sws__DetachResponse *)ptr, "sws:DetachResponse");
	case SOAP_TYPE_sws__AddChildResponse:
		return soap_out_sws__AddChildResponse(soap, tag, id, (const struct sws__AddChildResponse *)ptr, "sws:AddChildResponse");
	case SOAP_TYPE_sws__AddChildRequest:
		return soap_out_sws__AddChildRequest(soap, tag, id, (const struct sws__AddChildRequest *)ptr, "sws:AddChildRequest");
	case SOAP_TYPE_wsrp__SetResourcePropertiesResponse:
		return soap_out_wsrp__SetResourcePropertiesResponse(soap, tag, id, (const struct wsrp__SetResourcePropertiesResponse *)ptr, "wsrp:SetResourcePropertiesResponse");
	case SOAP_TYPE_wsrp__GetMultipleResourcePropertiesRequest:
		return soap_out_wsrp__GetMultipleResourcePropertiesRequest(soap, tag, id, (const struct wsrp__GetMultipleResourcePropertiesRequest *)ptr, "wsrp:GetMultipleResourcePropertiesRequest");
	case SOAP_TYPE_wsrp__ResourcePropertyStruct:
		return soap_out_wsrp__ResourcePropertyStruct(soap, tag, id, (const struct wsrp__ResourcePropertyStruct *)ptr, "wsrp:ResourcePropertyStruct");
	case SOAP_TYPE_sws__PutParamLogResponse:
		return soap_out_sws__PutParamLogResponse(soap, tag, id, (const struct sws__PutParamLogResponse *)ptr, "sws:PutParamLogResponse");
	case SOAP_TYPE_wsrp__DestroyResponse:
		return soap_out_wsrp__DestroyResponse(soap, tag, id, (const struct wsrp__DestroyResponse *)ptr, "wsrp:DestroyResponse");
	case SOAP_TYPE_sws__AttachResponse:
		return soap_out_sws__AttachResponse(soap, tag, id, (const struct sws__AttachResponse *)ptr, "sws:AttachResponse");
	case SOAP_TYPE_reg__steerMessage:
		return soap_out_reg__steerMessage(soap, tag, id, (const struct reg__steerMessage *)ptr, "reg:steerMessage");
	case SOAP_TYPE_reg__supp_cmds:
		return soap_out_reg__supp_cmds(soap, tag, id, (const struct reg__supp_cmds *)ptr, "reg:supp-cmds");
	case SOAP_TYPE_reg__Command:
		return soap_out_reg__Command(soap, tag, id, (const struct reg__Command *)ptr, "reg:Command");
	case SOAP_TYPE_sws__RecordCheckpointResponse:
		return soap_out_sws__RecordCheckpointResponse(soap, tag, id, (const struct sws__RecordCheckpointResponse *)ptr, "sws:RecordCheckpointResponse");
	case SOAP_TYPE_sws__GetParamLogResponse:
		return soap_out_sws__GetParamLogResponse(soap, tag, id, (const struct sws__GetParamLogResponse *)ptr, "sws:GetParamLogResponse");
	case SOAP_TYPE_epr:
		return soap_out_epr(soap, tag, id, (const struct epr *)ptr, "epr");
	case SOAP_TYPE_PointerTocptn__addNodeResponse:
		return soap_out_PointerTocptn__addNodeResponse(soap, tag, id, (struct cptn__addNodeResponse *const*)ptr, "cptn:addNodeResponse");
	case SOAP_TYPE_PointerTocptn__destroyResponse:
		return soap_out_PointerTocptn__destroyResponse(soap, tag, id, (struct cptn__destroyResponse *const*)ptr, "cptn:destroyResponse");
	case SOAP_TYPE_PointerTocpt__getActiveTreesResponse:
		return soap_out_PointerTocpt__getActiveTreesResponse(soap, tag, id, (struct cpt__getActiveTreesResponse *const*)ptr, "cpt:getActiveTreesResponse");
	case SOAP_TYPE_PointerTocpt__destroyResponse:
		return soap_out_PointerTocpt__destroyResponse(soap, tag, id, (struct cpt__destroyResponse *const*)ptr, "cpt:destroyResponse");
	case SOAP_TYPE_PointerTocpt__findByHandleResponse:
		return soap_out_PointerTocpt__findByHandleResponse(soap, tag, id, (struct cpt__findByHandleResponse *const*)ptr, "cpt:findByHandleResponse");
	case SOAP_TYPE_PointerTocpt__createNewTreeResponse:
		return soap_out_PointerTocpt__createNewTreeResponse(soap, tag, id, (struct cpt__createNewTreeResponse *const*)ptr, "cpt:createNewTreeResponse");
	case SOAP_TYPE_PointerTorsg__AddResponse:
		return soap_out_PointerTorsg__AddResponse(soap, tag, id, (struct rsg__AddResponse *const*)ptr, "rsg:AddResponse");
	case SOAP_TYPE_PointerToswsf__createSWSResourceResponse:
		return soap_out_PointerToswsf__createSWSResourceResponse(soap, tag, id, (struct swsf__createSWSResourceResponse *const*)ptr, "swsf:createSWSResourceResponse");
	case SOAP_TYPE_PointerTowsrp__DestroyResponse:
		return soap_out_PointerTowsrp__DestroyResponse(soap, tag, id, (struct wsrp__DestroyResponse *const*)ptr, "wsrp:DestroyResponse");
	case SOAP_TYPE_PointerTosws__PutParamLogResponse:
		return soap_out_PointerTosws__PutParamLogResponse(soap, tag, id, (struct sws__PutParamLogResponse *const*)ptr, "sws:PutParamLogResponse");
	case SOAP_TYPE_PointerTosws__GetParamLogResponse:
		return soap_out_PointerTosws__GetParamLogResponse(soap, tag, id, (struct sws__GetParamLogResponse *const*)ptr, "sws:GetParamLogResponse");
	case SOAP_TYPE_PointerTosws__RecordCheckpointResponse:
		return soap_out_PointerTosws__RecordCheckpointResponse(soap, tag, id, (struct sws__RecordCheckpointResponse *const*)ptr, "sws:RecordCheckpointResponse");
	case SOAP_TYPE_PointerTosws__DetachResponse:
		return soap_out_PointerTosws__DetachResponse(soap, tag, id, (struct sws__DetachResponse *const*)ptr, "sws:DetachResponse");
	case SOAP_TYPE_PointerTosws__AttachResponse:
		return soap_out_PointerTosws__AttachResponse(soap, tag, id, (struct sws__AttachResponse *const*)ptr, "sws:AttachResponse");
	case SOAP_TYPE_PointerTosws__AddChildResponse:
		return soap_out_PointerTosws__AddChildResponse(soap, tag, id, (struct sws__AddChildResponse *const*)ptr, "sws:AddChildResponse");
	case SOAP_TYPE_PointerTowsrp__SetResourcePropertiesResponse:
		return soap_out_PointerTowsrp__SetResourcePropertiesResponse(soap, tag, id, (struct wsrp__SetResourcePropertiesResponse *const*)ptr, "wsrp:SetResourcePropertiesResponse");
	case SOAP_TYPE_PointerTowsrp__ResourcePropertyStruct:
		return soap_out_PointerTowsrp__ResourcePropertyStruct(soap, tag, id, (struct wsrp__ResourcePropertyStruct *const*)ptr, "wsrp:ResourcePropertyStruct");
	case SOAP_TYPE_PointerToreg__Command:
		return soap_out_PointerToreg__Command(soap, tag, id, (struct reg__Command *const*)ptr, "reg:Command");
	case SOAP_TYPE_xsd__string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_Security:
		soap_serialize_Security(soap, (const struct Security *)ptr);
		break;
	case SOAP_TYPE_UsernameToken:
		soap_serialize_UsernameToken(soap, (const struct UsernameToken *)ptr);
		break;
	case SOAP_TYPE_stringWithAttr:
		soap_serialize_stringWithAttr(soap, (const struct stringWithAttr *)ptr);
		break;
	case SOAP_TYPE_cptn__addNode:
		soap_serialize_cptn__addNode(soap, (const struct cptn__addNode *)ptr);
		break;
	case SOAP_TYPE_cptn__Destroy:
		soap_serialize_cptn__Destroy(soap, (const struct cptn__Destroy *)ptr);
		break;
	case SOAP_TYPE_cptn__destroyResponse:
		soap_serialize_cptn__destroyResponse(soap, (const struct cptn__destroyResponse *)ptr);
		break;
	case SOAP_TYPE_cptn__addNodeResponse:
		soap_serialize_cptn__addNodeResponse(soap, (const struct cptn__addNodeResponse *)ptr);
		break;
	case SOAP_TYPE_cpt__getActiveTrees:
		soap_serialize_cpt__getActiveTrees(soap, (const struct cpt__getActiveTrees *)ptr);
		break;
	case SOAP_TYPE_cpt__Destroy:
		soap_serialize_cpt__Destroy(soap, (const struct cpt__Destroy *)ptr);
		break;
	case SOAP_TYPE_cpt__findByHandle:
		soap_serialize_cpt__findByHandle(soap, (const struct cpt__findByHandle *)ptr);
		break;
	case SOAP_TYPE_cpt__createNewTree:
		soap_serialize_cpt__createNewTree(soap, (const struct cpt__createNewTree *)ptr);
		break;
	case SOAP_TYPE_cpt__destroyResponse:
		soap_serialize_cpt__destroyResponse(soap, (const struct cpt__destroyResponse *)ptr);
		break;
	case SOAP_TYPE_cpt__createNewTreeResponse:
		soap_serialize_cpt__createNewTreeResponse(soap, (const struct cpt__createNewTreeResponse *)ptr);
		break;
	case SOAP_TYPE_cpt__getActiveTreesResponse:
		soap_serialize_cpt__getActiveTreesResponse(soap, (const struct cpt__getActiveTreesResponse *)ptr);
		break;
	case SOAP_TYPE_cpt__findByHandleResponse:
		soap_serialize_cpt__findByHandleResponse(soap, (const struct cpt__findByHandleResponse *)ptr);
		break;
	case SOAP_TYPE_rsg__Add:
		soap_serialize_rsg__Add(soap, (const struct rsg__Add *)ptr);
		break;
	case SOAP_TYPE_rsg__AddResponse:
		soap_serialize_rsg__AddResponse(soap, (const struct rsg__AddResponse *)ptr);
		break;
	case SOAP_TYPE_swsf__createSWSResource:
		soap_serialize_swsf__createSWSResource(soap, (const struct swsf__createSWSResource *)ptr);
		break;
	case SOAP_TYPE_swsf__createSWSResourceResponse:
		soap_serialize_swsf__createSWSResourceResponse(soap, (const struct swsf__createSWSResourceResponse *)ptr);
		break;
	case SOAP_TYPE_wsrp__Destroy:
		soap_serialize_wsrp__Destroy(soap, (const struct wsrp__Destroy *)ptr);
		break;
	case SOAP_TYPE_sws__PutParamLog:
		soap_serialize_sws__PutParamLog(soap, (const struct sws__PutParamLog *)ptr);
		break;
	case SOAP_TYPE_sws__GetParamLog:
		soap_serialize_sws__GetParamLog(soap, (const struct sws__GetParamLog *)ptr);
		break;
	case SOAP_TYPE_sws__RecordCheckpoint:
		soap_serialize_sws__RecordCheckpoint(soap, (const struct sws__RecordCheckpoint *)ptr);
		break;
	case SOAP_TYPE_sws__Detach:
		soap_serialize_sws__Detach(soap, (const struct sws__Detach *)ptr);
		break;
	case SOAP_TYPE_sws__Attach:
		soap_serialize_sws__Attach(soap, (const struct sws__Attach *)ptr);
		break;
	case SOAP_TYPE_sws__AddChild:
		soap_serialize_sws__AddChild(soap, (const struct sws__AddChild *)ptr);
		break;
	case SOAP_TYPE_wsrp__GetResourcePropertyDocument:
		soap_serialize_wsrp__GetResourcePropertyDocument(soap, (const struct wsrp__GetResourcePropertyDocument *)ptr);
		break;
	case SOAP_TYPE_wsrp__SetResourceProperties:
		soap_serialize_wsrp__SetResourceProperties(soap, (const struct wsrp__SetResourceProperties *)ptr);
		break;
	case SOAP_TYPE_wsrp__GetMultipleResourceProperties:
		soap_serialize_wsrp__GetMultipleResourceProperties(soap, (const struct wsrp__GetMultipleResourceProperties *)ptr);
		break;
	case SOAP_TYPE___wsrp__GetResourceProperty:
		soap_serialize___wsrp__GetResourceProperty(soap, (const struct __wsrp__GetResourceProperty *)ptr);
		break;
	case SOAP_TYPE_sws__DetachResponse:
		soap_serialize_sws__DetachResponse(soap, (const struct sws__DetachResponse *)ptr);
		break;
	case SOAP_TYPE_sws__AddChildResponse:
		soap_serialize_sws__AddChildResponse(soap, (const struct sws__AddChildResponse *)ptr);
		break;
	case SOAP_TYPE_sws__AddChildRequest:
		soap_serialize_sws__AddChildRequest(soap, (const struct sws__AddChildRequest *)ptr);
		break;
	case SOAP_TYPE_wsrp__SetResourcePropertiesResponse:
		soap_serialize_wsrp__SetResourcePropertiesResponse(soap, (const struct wsrp__SetResourcePropertiesResponse *)ptr);
		break;
	case SOAP_TYPE_wsrp__GetMultipleResourcePropertiesRequest:
		soap_serialize_wsrp__GetMultipleResourcePropertiesRequest(soap, (const struct wsrp__GetMultipleResourcePropertiesRequest *)ptr);
		break;
	case SOAP_TYPE_wsrp__ResourcePropertyStruct:
		soap_serialize_wsrp__ResourcePropertyStruct(soap, (const struct wsrp__ResourcePropertyStruct *)ptr);
		break;
	case SOAP_TYPE_sws__PutParamLogResponse:
		soap_serialize_sws__PutParamLogResponse(soap, (const struct sws__PutParamLogResponse *)ptr);
		break;
	case SOAP_TYPE_wsrp__DestroyResponse:
		soap_serialize_wsrp__DestroyResponse(soap, (const struct wsrp__DestroyResponse *)ptr);
		break;
	case SOAP_TYPE_sws__AttachResponse:
		soap_serialize_sws__AttachResponse(soap, (const struct sws__AttachResponse *)ptr);
		break;
	case SOAP_TYPE_reg__steerMessage:
		soap_serialize_reg__steerMessage(soap, (const struct reg__steerMessage *)ptr);
		break;
	case SOAP_TYPE_reg__supp_cmds:
		soap_serialize_reg__supp_cmds(soap, (const struct reg__supp_cmds *)ptr);
		break;
	case SOAP_TYPE_reg__Command:
		soap_serialize_reg__Command(soap, (const struct reg__Command *)ptr);
		break;
	case SOAP_TYPE_sws__RecordCheckpointResponse:
		soap_serialize_sws__RecordCheckpointResponse(soap, (const struct sws__RecordCheckpointResponse *)ptr);
		break;
	case SOAP_TYPE_sws__GetParamLogResponse:
		soap_serialize_sws__GetParamLogResponse(soap, (const struct sws__GetParamLogResponse *)ptr);
		break;
	case SOAP_TYPE_epr:
		soap_serialize_epr(soap, (const struct epr *)ptr);
		break;
	case SOAP_TYPE_PointerTocptn__addNodeResponse:
		soap_serialize_PointerTocptn__addNodeResponse(soap, (struct cptn__addNodeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTocptn__destroyResponse:
		soap_serialize_PointerTocptn__destroyResponse(soap, (struct cptn__destroyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTocpt__getActiveTreesResponse:
		soap_serialize_PointerTocpt__getActiveTreesResponse(soap, (struct cpt__getActiveTreesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTocpt__destroyResponse:
		soap_serialize_PointerTocpt__destroyResponse(soap, (struct cpt__destroyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTocpt__findByHandleResponse:
		soap_serialize_PointerTocpt__findByHandleResponse(soap, (struct cpt__findByHandleResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTocpt__createNewTreeResponse:
		soap_serialize_PointerTocpt__createNewTreeResponse(soap, (struct cpt__createNewTreeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorsg__AddResponse:
		soap_serialize_PointerTorsg__AddResponse(soap, (struct rsg__AddResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswsf__createSWSResourceResponse:
		soap_serialize_PointerToswsf__createSWSResourceResponse(soap, (struct swsf__createSWSResourceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrp__DestroyResponse:
		soap_serialize_PointerTowsrp__DestroyResponse(soap, (struct wsrp__DestroyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosws__PutParamLogResponse:
		soap_serialize_PointerTosws__PutParamLogResponse(soap, (struct sws__PutParamLogResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosws__GetParamLogResponse:
		soap_serialize_PointerTosws__GetParamLogResponse(soap, (struct sws__GetParamLogResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosws__RecordCheckpointResponse:
		soap_serialize_PointerTosws__RecordCheckpointResponse(soap, (struct sws__RecordCheckpointResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosws__DetachResponse:
		soap_serialize_PointerTosws__DetachResponse(soap, (struct sws__DetachResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosws__AttachResponse:
		soap_serialize_PointerTosws__AttachResponse(soap, (struct sws__AttachResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosws__AddChildResponse:
		soap_serialize_PointerTosws__AddChildResponse(soap, (struct sws__AddChildResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrp__SetResourcePropertiesResponse:
		soap_serialize_PointerTowsrp__SetResourcePropertiesResponse(soap, (struct wsrp__SetResourcePropertiesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrp__ResourcePropertyStruct:
		soap_serialize_PointerTowsrp__ResourcePropertyStruct(soap, (struct wsrp__ResourcePropertyStruct *const*)ptr);
		break;
	case SOAP_TYPE_PointerToreg__Command:
		soap_serialize_PointerToreg__Command(soap, (struct reg__Command *const*)ptr);
		break;
	case SOAP_TYPE_xsd__string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__int);
	if (soap_out_xsd__int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_xsd__int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_xsd__int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_xsd__int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_xsd__int);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->wsa__To);
	soap_default_Security(soap, &a->wsse__Security);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->wsa__To);
	soap_serialize_Security(soap, &a->wsse__Security);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsa:To", -1, &a->wsa__To, ""))
		return soap->error;
	if (soap_out_Security(soap, "wsse:Security", -1, &a->wsse__Security, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsa__To = 1;
	size_t soap_flag_wsse__Security = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "wsa:To", &a->wsa__To, "xsd:string"))
				{	soap_flag_wsa__To--;
					continue;
				}
			if (soap_flag_wsse__Security && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Security(soap, "wsse:Security", &a->wsse__Security, "Security"))
				{	soap_flag_wsse__Security--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsse__Security > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_Security(struct soap *soap, struct Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_UsernameToken(soap, &a->wsse__UsernameToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_Security(struct soap *soap, const struct Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_UsernameToken(soap, &a->wsse__UsernameToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_Security(struct soap *soap, const struct Security *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Security);
	if (soap_out_Security(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Security(struct soap *soap, const char *tag, int id, const struct Security *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Security), type))
		return soap->error;
	if (soap_out_UsernameToken(soap, "wsse:UsernameToken", -1, &a->wsse__UsernameToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct Security * SOAP_FMAC4 soap_get_Security(struct soap *soap, struct Security *p, const char *tag, const char *type)
{
	if ((p = soap_in_Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct Security * SOAP_FMAC4 soap_in_Security(struct soap *soap, const char *tag, struct Security *a, const char *type)
{
	size_t soap_flag_wsse__UsernameToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct Security *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Security, sizeof(struct Security), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_Security(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsse__UsernameToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_UsernameToken(soap, "wsse:UsernameToken", &a->wsse__UsernameToken, "UsernameToken"))
				{	soap_flag_wsse__UsernameToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct Security *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Security, 0, sizeof(struct Security), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsse__UsernameToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_UsernameToken(struct soap *soap, struct UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->wsse__Username);
	soap_default_stringWithAttr(soap, &a->wsse__Password);
	soap_default_xsd__string(soap, &a->wsse__Nonce);
	soap_default_xsd__string(soap, &a->wsu__Created);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_UsernameToken(struct soap *soap, const struct UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->wsse__Username);
	soap_serialize_stringWithAttr(soap, &a->wsse__Password);
	soap_serialize_xsd__string(soap, &a->wsse__Nonce);
	soap_serialize_xsd__string(soap, &a->wsu__Created);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_UsernameToken(struct soap *soap, const struct UsernameToken *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_UsernameToken);
	if (soap_out_UsernameToken(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_UsernameToken(struct soap *soap, const char *tag, int id, const struct UsernameToken *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_UsernameToken), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsse:Username", -1, &a->wsse__Username, ""))
		return soap->error;
	if (soap_out_stringWithAttr(soap, "wsse:Password", -1, &a->wsse__Password, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsse:Nonce", -1, &a->wsse__Nonce, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsu:Created", -1, &a->wsu__Created, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct UsernameToken * SOAP_FMAC4 soap_get_UsernameToken(struct soap *soap, struct UsernameToken *p, const char *tag, const char *type)
{
	if ((p = soap_in_UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct UsernameToken * SOAP_FMAC4 soap_in_UsernameToken(struct soap *soap, const char *tag, struct UsernameToken *a, const char *type)
{
	size_t soap_flag_wsse__Username = 1;
	size_t soap_flag_wsse__Password = 1;
	size_t soap_flag_wsse__Nonce = 1;
	size_t soap_flag_wsu__Created = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct UsernameToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_UsernameToken, sizeof(struct UsernameToken), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_UsernameToken(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsse__Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "wsse:Username", &a->wsse__Username, "xsd:string"))
				{	soap_flag_wsse__Username--;
					continue;
				}
			if (soap_flag_wsse__Password && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_stringWithAttr(soap, "wsse:Password", &a->wsse__Password, "stringWithAttr"))
				{	soap_flag_wsse__Password--;
					continue;
				}
			if (soap_flag_wsse__Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "wsse:Nonce", &a->wsse__Nonce, "xsd:string"))
				{	soap_flag_wsse__Nonce--;
					continue;
				}
			if (soap_flag_wsu__Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "wsu:Created", &a->wsu__Created, "xsd:string"))
				{	soap_flag_wsu__Created--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct UsernameToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_UsernameToken, 0, sizeof(struct UsernameToken), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsse__Password > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_stringWithAttr(struct soap *soap, struct stringWithAttr *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_xsd__string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_stringWithAttr(struct soap *soap, const struct stringWithAttr *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_stringWithAttr(struct soap *soap, const struct stringWithAttr *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_stringWithAttr);
	if (soap_out_stringWithAttr(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_stringWithAttr(struct soap *soap, const char *tag, int id, const struct stringWithAttr *a, const char *type)
{
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct stringWithAttr * SOAP_FMAC4 soap_get_stringWithAttr(struct soap *soap, struct stringWithAttr *p, const char *tag, const char *type)
{
	if ((p = soap_in_stringWithAttr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct stringWithAttr * SOAP_FMAC4 soap_in_stringWithAttr(struct soap *soap, const char *tag, struct stringWithAttr *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct stringWithAttr *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_stringWithAttr, sizeof(struct stringWithAttr), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_stringWithAttr(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, "stringWithAttr"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cptn__addNode(struct soap *soap, struct cptn__addNode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
	soap_default_xsd__string(soap, &a->in1);
	soap_default_xsd__string(soap, &a->in2);
	soap_default_xsd__string(soap, &a->in3);
	soap_default_xsd__string(soap, &a->in4);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cptn__addNode(struct soap *soap, const struct cptn__addNode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->in0);
	soap_serialize_xsd__string(soap, &a->in1);
	soap_serialize_xsd__string(soap, &a->in2);
	soap_serialize_xsd__string(soap, &a->in3);
	soap_serialize_xsd__string(soap, &a->in4);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cptn__addNode(struct soap *soap, const struct cptn__addNode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cptn__addNode);
	if (soap_out_cptn__addNode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cptn__addNode(struct soap *soap, const char *tag, int id, const struct cptn__addNode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cptn__addNode), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "in0", -1, &a->in0, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "in1", -1, &a->in1, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "in2", -1, &a->in2, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "in3", -1, &a->in3, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "in4", -1, &a->in4, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cptn__addNode * SOAP_FMAC4 soap_get_cptn__addNode(struct soap *soap, struct cptn__addNode *p, const char *tag, const char *type)
{
	if ((p = soap_in_cptn__addNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cptn__addNode * SOAP_FMAC4 soap_in_cptn__addNode(struct soap *soap, const char *tag, struct cptn__addNode *a, const char *type)
{
	size_t soap_flag_in0 = 1;
	size_t soap_flag_in1 = 1;
	size_t soap_flag_in2 = 1;
	size_t soap_flag_in3 = 1;
	size_t soap_flag_in4 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cptn__addNode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cptn__addNode, sizeof(struct cptn__addNode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cptn__addNode(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0--;
					continue;
				}
			if (soap_flag_in1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in1", &a->in1, "xsd:string"))
				{	soap_flag_in1--;
					continue;
				}
			if (soap_flag_in2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in2", &a->in2, "xsd:string"))
				{	soap_flag_in2--;
					continue;
				}
			if (soap_flag_in3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in3", &a->in3, "xsd:string"))
				{	soap_flag_in3--;
					continue;
				}
			if (soap_flag_in4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in4", &a->in4, "xsd:string"))
				{	soap_flag_in4--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cptn__addNode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cptn__addNode, 0, sizeof(struct cptn__addNode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cptn__Destroy(struct soap *soap, struct cptn__Destroy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cptn__Destroy(struct soap *soap, const struct cptn__Destroy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cptn__Destroy(struct soap *soap, const struct cptn__Destroy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cptn__Destroy);
	if (soap_out_cptn__Destroy(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cptn__Destroy(struct soap *soap, const char *tag, int id, const struct cptn__Destroy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cptn__Destroy), type))
		return soap->error;
	/* transient _ skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cptn__Destroy * SOAP_FMAC4 soap_get_cptn__Destroy(struct soap *soap, struct cptn__Destroy *p, const char *tag, const char *type)
{
	if ((p = soap_in_cptn__Destroy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cptn__Destroy * SOAP_FMAC4 soap_in_cptn__Destroy(struct soap *soap, const char *tag, struct cptn__Destroy *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cptn__Destroy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cptn__Destroy, sizeof(struct cptn__Destroy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cptn__Destroy(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cptn__Destroy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cptn__Destroy, 0, sizeof(struct cptn__Destroy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cptn__destroyResponse(struct soap *soap, struct cptn__destroyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cptn__destroyResponse(struct soap *soap, const struct cptn__destroyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cptn__destroyResponse(struct soap *soap, const struct cptn__destroyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cptn__destroyResponse);
	if (soap_out_cptn__destroyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cptn__destroyResponse(struct soap *soap, const char *tag, int id, const struct cptn__destroyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cptn__destroyResponse), type))
		return soap->error;
	/* transient _ skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cptn__destroyResponse * SOAP_FMAC4 soap_get_cptn__destroyResponse(struct soap *soap, struct cptn__destroyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_cptn__destroyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cptn__destroyResponse * SOAP_FMAC4 soap_in_cptn__destroyResponse(struct soap *soap, const char *tag, struct cptn__destroyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cptn__destroyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cptn__destroyResponse, sizeof(struct cptn__destroyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cptn__destroyResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cptn__destroyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cptn__destroyResponse, 0, sizeof(struct cptn__destroyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cptn__addNodeResponse(struct soap *soap, struct cptn__addNodeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_addNodeReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cptn__addNodeResponse(struct soap *soap, const struct cptn__addNodeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->_addNodeReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cptn__addNodeResponse(struct soap *soap, const struct cptn__addNodeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cptn__addNodeResponse);
	if (soap_out_cptn__addNodeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cptn__addNodeResponse(struct soap *soap, const char *tag, int id, const struct cptn__addNodeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cptn__addNodeResponse), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "addNodeReturn", -1, &a->_addNodeReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cptn__addNodeResponse * SOAP_FMAC4 soap_get_cptn__addNodeResponse(struct soap *soap, struct cptn__addNodeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_cptn__addNodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cptn__addNodeResponse * SOAP_FMAC4 soap_in_cptn__addNodeResponse(struct soap *soap, const char *tag, struct cptn__addNodeResponse *a, const char *type)
{
	size_t soap_flag__addNodeReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cptn__addNodeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cptn__addNodeResponse, sizeof(struct cptn__addNodeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cptn__addNodeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__addNodeReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_addNodeReturn, "xsd:string"))
				{	soap_flag__addNodeReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cptn__addNodeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cptn__addNodeResponse, 0, sizeof(struct cptn__addNodeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cpt__getActiveTrees(struct soap *soap, struct cpt__getActiveTrees *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cpt__getActiveTrees(struct soap *soap, const struct cpt__getActiveTrees *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cpt__getActiveTrees(struct soap *soap, const struct cpt__getActiveTrees *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cpt__getActiveTrees);
	if (soap_out_cpt__getActiveTrees(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cpt__getActiveTrees(struct soap *soap, const char *tag, int id, const struct cpt__getActiveTrees *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cpt__getActiveTrees), type))
		return soap->error;
	/* transient _ skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cpt__getActiveTrees * SOAP_FMAC4 soap_get_cpt__getActiveTrees(struct soap *soap, struct cpt__getActiveTrees *p, const char *tag, const char *type)
{
	if ((p = soap_in_cpt__getActiveTrees(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cpt__getActiveTrees * SOAP_FMAC4 soap_in_cpt__getActiveTrees(struct soap *soap, const char *tag, struct cpt__getActiveTrees *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cpt__getActiveTrees *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cpt__getActiveTrees, sizeof(struct cpt__getActiveTrees), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cpt__getActiveTrees(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cpt__getActiveTrees *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cpt__getActiveTrees, 0, sizeof(struct cpt__getActiveTrees), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cpt__Destroy(struct soap *soap, struct cpt__Destroy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cpt__Destroy(struct soap *soap, const struct cpt__Destroy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cpt__Destroy(struct soap *soap, const struct cpt__Destroy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cpt__Destroy);
	if (soap_out_cpt__Destroy(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cpt__Destroy(struct soap *soap, const char *tag, int id, const struct cpt__Destroy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cpt__Destroy), type))
		return soap->error;
	/* transient _ skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cpt__Destroy * SOAP_FMAC4 soap_get_cpt__Destroy(struct soap *soap, struct cpt__Destroy *p, const char *tag, const char *type)
{
	if ((p = soap_in_cpt__Destroy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cpt__Destroy * SOAP_FMAC4 soap_in_cpt__Destroy(struct soap *soap, const char *tag, struct cpt__Destroy *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cpt__Destroy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cpt__Destroy, sizeof(struct cpt__Destroy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cpt__Destroy(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cpt__Destroy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cpt__Destroy, 0, sizeof(struct cpt__Destroy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cpt__findByHandle(struct soap *soap, struct cpt__findByHandle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
	soap_default_xsd__string(soap, &a->in1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cpt__findByHandle(struct soap *soap, const struct cpt__findByHandle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->in0);
	soap_serialize_xsd__string(soap, &a->in1);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cpt__findByHandle(struct soap *soap, const struct cpt__findByHandle *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cpt__findByHandle);
	if (soap_out_cpt__findByHandle(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cpt__findByHandle(struct soap *soap, const char *tag, int id, const struct cpt__findByHandle *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cpt__findByHandle), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "in0", -1, &a->in0, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "in1", -1, &a->in1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cpt__findByHandle * SOAP_FMAC4 soap_get_cpt__findByHandle(struct soap *soap, struct cpt__findByHandle *p, const char *tag, const char *type)
{
	if ((p = soap_in_cpt__findByHandle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cpt__findByHandle * SOAP_FMAC4 soap_in_cpt__findByHandle(struct soap *soap, const char *tag, struct cpt__findByHandle *a, const char *type)
{
	size_t soap_flag_in0 = 1;
	size_t soap_flag_in1 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cpt__findByHandle *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cpt__findByHandle, sizeof(struct cpt__findByHandle), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cpt__findByHandle(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0--;
					continue;
				}
			if (soap_flag_in1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in1", &a->in1, "xsd:string"))
				{	soap_flag_in1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cpt__findByHandle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cpt__findByHandle, 0, sizeof(struct cpt__findByHandle), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cpt__createNewTree(struct soap *soap, struct cpt__createNewTree *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cpt__createNewTree(struct soap *soap, const struct cpt__createNewTree *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cpt__createNewTree(struct soap *soap, const struct cpt__createNewTree *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cpt__createNewTree);
	if (soap_out_cpt__createNewTree(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cpt__createNewTree(struct soap *soap, const char *tag, int id, const struct cpt__createNewTree *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cpt__createNewTree), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "in0", -1, &a->in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cpt__createNewTree * SOAP_FMAC4 soap_get_cpt__createNewTree(struct soap *soap, struct cpt__createNewTree *p, const char *tag, const char *type)
{
	if ((p = soap_in_cpt__createNewTree(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cpt__createNewTree * SOAP_FMAC4 soap_in_cpt__createNewTree(struct soap *soap, const char *tag, struct cpt__createNewTree *a, const char *type)
{
	size_t soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cpt__createNewTree *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cpt__createNewTree, sizeof(struct cpt__createNewTree), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cpt__createNewTree(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cpt__createNewTree *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cpt__createNewTree, 0, sizeof(struct cpt__createNewTree), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cpt__destroyResponse(struct soap *soap, struct cpt__destroyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cpt__destroyResponse(struct soap *soap, const struct cpt__destroyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cpt__destroyResponse(struct soap *soap, const struct cpt__destroyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cpt__destroyResponse);
	if (soap_out_cpt__destroyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cpt__destroyResponse(struct soap *soap, const char *tag, int id, const struct cpt__destroyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cpt__destroyResponse), type))
		return soap->error;
	/* transient _ skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cpt__destroyResponse * SOAP_FMAC4 soap_get_cpt__destroyResponse(struct soap *soap, struct cpt__destroyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_cpt__destroyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cpt__destroyResponse * SOAP_FMAC4 soap_in_cpt__destroyResponse(struct soap *soap, const char *tag, struct cpt__destroyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cpt__destroyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cpt__destroyResponse, sizeof(struct cpt__destroyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cpt__destroyResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cpt__destroyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cpt__destroyResponse, 0, sizeof(struct cpt__destroyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cpt__createNewTreeResponse(struct soap *soap, struct cpt__createNewTreeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_createNewTreeReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cpt__createNewTreeResponse(struct soap *soap, const struct cpt__createNewTreeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->_createNewTreeReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cpt__createNewTreeResponse(struct soap *soap, const struct cpt__createNewTreeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cpt__createNewTreeResponse);
	if (soap_out_cpt__createNewTreeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cpt__createNewTreeResponse(struct soap *soap, const char *tag, int id, const struct cpt__createNewTreeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cpt__createNewTreeResponse), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "createNewTreeReturn", -1, &a->_createNewTreeReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cpt__createNewTreeResponse * SOAP_FMAC4 soap_get_cpt__createNewTreeResponse(struct soap *soap, struct cpt__createNewTreeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_cpt__createNewTreeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cpt__createNewTreeResponse * SOAP_FMAC4 soap_in_cpt__createNewTreeResponse(struct soap *soap, const char *tag, struct cpt__createNewTreeResponse *a, const char *type)
{
	size_t soap_flag__createNewTreeReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cpt__createNewTreeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cpt__createNewTreeResponse, sizeof(struct cpt__createNewTreeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cpt__createNewTreeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__createNewTreeReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_createNewTreeReturn, "xsd:string"))
				{	soap_flag__createNewTreeReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cpt__createNewTreeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cpt__createNewTreeResponse, 0, sizeof(struct cpt__createNewTreeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cpt__getActiveTreesResponse(struct soap *soap, struct cpt__getActiveTreesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_getActiveTreesReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cpt__getActiveTreesResponse(struct soap *soap, const struct cpt__getActiveTreesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->_getActiveTreesReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cpt__getActiveTreesResponse(struct soap *soap, const struct cpt__getActiveTreesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cpt__getActiveTreesResponse);
	if (soap_out_cpt__getActiveTreesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cpt__getActiveTreesResponse(struct soap *soap, const char *tag, int id, const struct cpt__getActiveTreesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cpt__getActiveTreesResponse), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "getActiveTreesReturn", -1, &a->_getActiveTreesReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cpt__getActiveTreesResponse * SOAP_FMAC4 soap_get_cpt__getActiveTreesResponse(struct soap *soap, struct cpt__getActiveTreesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_cpt__getActiveTreesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cpt__getActiveTreesResponse * SOAP_FMAC4 soap_in_cpt__getActiveTreesResponse(struct soap *soap, const char *tag, struct cpt__getActiveTreesResponse *a, const char *type)
{
	size_t soap_flag__getActiveTreesReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cpt__getActiveTreesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cpt__getActiveTreesResponse, sizeof(struct cpt__getActiveTreesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cpt__getActiveTreesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getActiveTreesReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_getActiveTreesReturn, "xsd:string"))
				{	soap_flag__getActiveTreesReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cpt__getActiveTreesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cpt__getActiveTreesResponse, 0, sizeof(struct cpt__getActiveTreesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cpt__findByHandleResponse(struct soap *soap, struct cpt__findByHandleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_findByHandleReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cpt__findByHandleResponse(struct soap *soap, const struct cpt__findByHandleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->_findByHandleReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cpt__findByHandleResponse(struct soap *soap, const struct cpt__findByHandleResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cpt__findByHandleResponse);
	if (soap_out_cpt__findByHandleResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cpt__findByHandleResponse(struct soap *soap, const char *tag, int id, const struct cpt__findByHandleResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cpt__findByHandleResponse), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "findByHandleReturn", -1, &a->_findByHandleReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cpt__findByHandleResponse * SOAP_FMAC4 soap_get_cpt__findByHandleResponse(struct soap *soap, struct cpt__findByHandleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_cpt__findByHandleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cpt__findByHandleResponse * SOAP_FMAC4 soap_in_cpt__findByHandleResponse(struct soap *soap, const char *tag, struct cpt__findByHandleResponse *a, const char *type)
{
	size_t soap_flag__findByHandleReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cpt__findByHandleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cpt__findByHandleResponse, sizeof(struct cpt__findByHandleResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cpt__findByHandleResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__findByHandleReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_findByHandleReturn, "xsd:string"))
				{	soap_flag__findByHandleReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cpt__findByHandleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cpt__findByHandleResponse, 0, sizeof(struct cpt__findByHandleResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rsg__Add(struct soap *soap, struct rsg__Add *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_in = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rsg__Add(struct soap *soap, const struct rsg__Add *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rsg__Add(struct soap *soap, const struct rsg__Add *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rsg__Add);
	if (soap_out_rsg__Add(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rsg__Add(struct soap *soap, const char *tag, int id, const struct rsg__Add *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rsg__Add), type))
		return soap->error;
	soap_outliteral(soap, "in", &a->_in, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct rsg__Add * SOAP_FMAC4 soap_get_rsg__Add(struct soap *soap, struct rsg__Add *p, const char *tag, const char *type)
{
	if ((p = soap_in_rsg__Add(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct rsg__Add * SOAP_FMAC4 soap_in_rsg__Add(struct soap *soap, const char *tag, struct rsg__Add *a, const char *type)
{
	size_t soap_flag__in = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct rsg__Add *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rsg__Add, sizeof(struct rsg__Add), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_rsg__Add(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, NULL, &a->_in))
				{	soap_flag__in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rsg__Add *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_rsg__Add, 0, sizeof(struct rsg__Add), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rsg__AddResponse(struct soap *soap, struct rsg__AddResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_epr(soap, &a->wsa__EndpointReference);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rsg__AddResponse(struct soap *soap, const struct rsg__AddResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_epr(soap, &a->wsa__EndpointReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rsg__AddResponse(struct soap *soap, const struct rsg__AddResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rsg__AddResponse);
	if (soap_out_rsg__AddResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rsg__AddResponse(struct soap *soap, const char *tag, int id, const struct rsg__AddResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rsg__AddResponse), type))
		return soap->error;
	soap_element_result(soap, "wsa:EndpointReference");
	if (soap_out_epr(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct rsg__AddResponse * SOAP_FMAC4 soap_get_rsg__AddResponse(struct soap *soap, struct rsg__AddResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rsg__AddResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct rsg__AddResponse * SOAP_FMAC4 soap_in_rsg__AddResponse(struct soap *soap, const char *tag, struct rsg__AddResponse *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct rsg__AddResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rsg__AddResponse, sizeof(struct rsg__AddResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_rsg__AddResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_epr(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, "epr"))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			soap_check_result(soap, "wsa:EndpointReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rsg__AddResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_rsg__AddResponse, 0, sizeof(struct rsg__AddResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swsf__createSWSResource(struct soap *soap, struct swsf__createSWSResource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__int(soap, &a->timeToLive);
	soap_default_xsd__string(soap, &a->chkpointEPR);
	soap_default_xsd__string(soap, &a->passPhrase);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swsf__createSWSResource(struct soap *soap, const struct swsf__createSWSResource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->chkpointEPR);
	soap_serialize_xsd__string(soap, &a->passPhrase);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swsf__createSWSResource(struct soap *soap, const struct swsf__createSWSResource *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swsf__createSWSResource);
	if (soap_out_swsf__createSWSResource(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swsf__createSWSResource(struct soap *soap, const char *tag, int id, const struct swsf__createSWSResource *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swsf__createSWSResource), type))
		return soap->error;
	if (soap_out_xsd__int(soap, "timeToLive", -1, &a->timeToLive, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "chkpointEPR", -1, &a->chkpointEPR, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "passPhrase", -1, &a->passPhrase, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swsf__createSWSResource * SOAP_FMAC4 soap_get_swsf__createSWSResource(struct soap *soap, struct swsf__createSWSResource *p, const char *tag, const char *type)
{
	if ((p = soap_in_swsf__createSWSResource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct swsf__createSWSResource * SOAP_FMAC4 soap_in_swsf__createSWSResource(struct soap *soap, const char *tag, struct swsf__createSWSResource *a, const char *type)
{
	size_t soap_flag_timeToLive = 1;
	size_t soap_flag_chkpointEPR = 1;
	size_t soap_flag_passPhrase = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swsf__createSWSResource *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swsf__createSWSResource, sizeof(struct swsf__createSWSResource), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swsf__createSWSResource(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timeToLive && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "timeToLive", &a->timeToLive, "xsd:int"))
				{	soap_flag_timeToLive--;
					continue;
				}
			if (soap_flag_chkpointEPR && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "chkpointEPR", &a->chkpointEPR, "xsd:string"))
				{	soap_flag_chkpointEPR--;
					continue;
				}
			if (soap_flag_passPhrase && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "passPhrase", &a->passPhrase, "xsd:string"))
				{	soap_flag_passPhrase--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swsf__createSWSResource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swsf__createSWSResource, 0, sizeof(struct swsf__createSWSResource), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_timeToLive > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swsf__createSWSResourceResponse(struct soap *soap, struct swsf__createSWSResourceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_epr(soap, &a->wsa__EndpointReference);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swsf__createSWSResourceResponse(struct soap *soap, const struct swsf__createSWSResourceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_epr(soap, &a->wsa__EndpointReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swsf__createSWSResourceResponse(struct soap *soap, const struct swsf__createSWSResourceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swsf__createSWSResourceResponse);
	if (soap_out_swsf__createSWSResourceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swsf__createSWSResourceResponse(struct soap *soap, const char *tag, int id, const struct swsf__createSWSResourceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swsf__createSWSResourceResponse), type))
		return soap->error;
	soap_element_result(soap, "wsa:EndpointReference");
	if (soap_out_epr(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swsf__createSWSResourceResponse * SOAP_FMAC4 soap_get_swsf__createSWSResourceResponse(struct soap *soap, struct swsf__createSWSResourceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_swsf__createSWSResourceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct swsf__createSWSResourceResponse * SOAP_FMAC4 soap_in_swsf__createSWSResourceResponse(struct soap *soap, const char *tag, struct swsf__createSWSResourceResponse *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swsf__createSWSResourceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swsf__createSWSResourceResponse, sizeof(struct swsf__createSWSResourceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swsf__createSWSResourceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_epr(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, "epr"))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			soap_check_result(soap, "wsa:EndpointReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swsf__createSWSResourceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swsf__createSWSResourceResponse, 0, sizeof(struct swsf__createSWSResourceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrp__Destroy(struct soap *soap, struct wsrp__Destroy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrp__Destroy(struct soap *soap, const struct wsrp__Destroy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrp__Destroy(struct soap *soap, const struct wsrp__Destroy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrp__Destroy);
	if (soap_out_wsrp__Destroy(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrp__Destroy(struct soap *soap, const char *tag, int id, const struct wsrp__Destroy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrp__Destroy), type))
		return soap->error;
	/* transient _ skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrp__Destroy * SOAP_FMAC4 soap_get_wsrp__Destroy(struct soap *soap, struct wsrp__Destroy *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrp__Destroy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsrp__Destroy * SOAP_FMAC4 soap_in_wsrp__Destroy(struct soap *soap, const char *tag, struct wsrp__Destroy *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsrp__Destroy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrp__Destroy, sizeof(struct wsrp__Destroy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrp__Destroy(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrp__Destroy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrp__Destroy, 0, sizeof(struct wsrp__Destroy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__PutParamLog(struct soap *soap, struct sws__PutParamLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__PutParamLog(struct soap *soap, const struct sws__PutParamLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__PutParamLog(struct soap *soap, const struct sws__PutParamLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__PutParamLog);
	if (soap_out_sws__PutParamLog(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__PutParamLog(struct soap *soap, const char *tag, int id, const struct sws__PutParamLog *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__PutParamLog), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "in0", -1, &a->in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct sws__PutParamLog * SOAP_FMAC4 soap_get_sws__PutParamLog(struct soap *soap, struct sws__PutParamLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__PutParamLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct sws__PutParamLog * SOAP_FMAC4 soap_in_sws__PutParamLog(struct soap *soap, const char *tag, struct sws__PutParamLog *a, const char *type)
{
	size_t soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct sws__PutParamLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__PutParamLog, sizeof(struct sws__PutParamLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_sws__PutParamLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__PutParamLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_sws__PutParamLog, 0, sizeof(struct sws__PutParamLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__GetParamLog(struct soap *soap, struct sws__GetParamLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__int(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__GetParamLog(struct soap *soap, const struct sws__GetParamLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__GetParamLog(struct soap *soap, const struct sws__GetParamLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__GetParamLog);
	if (soap_out_sws__GetParamLog(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__GetParamLog(struct soap *soap, const char *tag, int id, const struct sws__GetParamLog *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__GetParamLog), type))
		return soap->error;
	if (soap_out_xsd__int(soap, "in0", -1, &a->in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct sws__GetParamLog * SOAP_FMAC4 soap_get_sws__GetParamLog(struct soap *soap, struct sws__GetParamLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__GetParamLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct sws__GetParamLog * SOAP_FMAC4 soap_in_sws__GetParamLog(struct soap *soap, const char *tag, struct sws__GetParamLog *a, const char *type)
{
	size_t soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct sws__GetParamLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__GetParamLog, sizeof(struct sws__GetParamLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_sws__GetParamLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "in0", &a->in0, "xsd:int"))
				{	soap_flag_in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__GetParamLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_sws__GetParamLog, 0, sizeof(struct sws__GetParamLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in0 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__RecordCheckpoint(struct soap *soap, struct sws__RecordCheckpoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
	soap_default_xsd__string(soap, &a->in1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__RecordCheckpoint(struct soap *soap, const struct sws__RecordCheckpoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->in0);
	soap_serialize_xsd__string(soap, &a->in1);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__RecordCheckpoint(struct soap *soap, const struct sws__RecordCheckpoint *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__RecordCheckpoint);
	if (soap_out_sws__RecordCheckpoint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__RecordCheckpoint(struct soap *soap, const char *tag, int id, const struct sws__RecordCheckpoint *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__RecordCheckpoint), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "in0", -1, &a->in0, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "in1", -1, &a->in1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct sws__RecordCheckpoint * SOAP_FMAC4 soap_get_sws__RecordCheckpoint(struct soap *soap, struct sws__RecordCheckpoint *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__RecordCheckpoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct sws__RecordCheckpoint * SOAP_FMAC4 soap_in_sws__RecordCheckpoint(struct soap *soap, const char *tag, struct sws__RecordCheckpoint *a, const char *type)
{
	size_t soap_flag_in0 = 1;
	size_t soap_flag_in1 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct sws__RecordCheckpoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__RecordCheckpoint, sizeof(struct sws__RecordCheckpoint), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_sws__RecordCheckpoint(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0--;
					continue;
				}
			if (soap_flag_in1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in1", &a->in1, "xsd:string"))
				{	soap_flag_in1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__RecordCheckpoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_sws__RecordCheckpoint, 0, sizeof(struct sws__RecordCheckpoint), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__Detach(struct soap *soap, struct sws__Detach *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _param_1 skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__Detach(struct soap *soap, const struct sws__Detach *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _param_1 skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__Detach(struct soap *soap, const struct sws__Detach *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__Detach);
	if (soap_out_sws__Detach(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__Detach(struct soap *soap, const char *tag, int id, const struct sws__Detach *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__Detach), type))
		return soap->error;
	/* transient _param_1 skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct sws__Detach * SOAP_FMAC4 soap_get_sws__Detach(struct soap *soap, struct sws__Detach *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__Detach(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct sws__Detach * SOAP_FMAC4 soap_in_sws__Detach(struct soap *soap, const char *tag, struct sws__Detach *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct sws__Detach *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__Detach, sizeof(struct sws__Detach), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_sws__Detach(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _param_1 skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__Detach *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_sws__Detach, 0, sizeof(struct sws__Detach), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__Attach(struct soap *soap, struct sws__Attach *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__Attach(struct soap *soap, const struct sws__Attach *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__Attach(struct soap *soap, const struct sws__Attach *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__Attach);
	if (soap_out_sws__Attach(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__Attach(struct soap *soap, const char *tag, int id, const struct sws__Attach *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__Attach), type))
		return soap->error;
	/* transient _ skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct sws__Attach * SOAP_FMAC4 soap_get_sws__Attach(struct soap *soap, struct sws__Attach *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__Attach(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct sws__Attach * SOAP_FMAC4 soap_in_sws__Attach(struct soap *soap, const char *tag, struct sws__Attach *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct sws__Attach *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__Attach, sizeof(struct sws__Attach), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_sws__Attach(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__Attach *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_sws__Attach, 0, sizeof(struct sws__Attach), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__AddChild(struct soap *soap, struct sws__AddChild *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_sws__AddChildRequest(soap, &a->__in);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__AddChild(struct soap *soap, const struct sws__AddChild *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_sws__AddChildRequest(soap, &a->__in);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__AddChild(struct soap *soap, const struct sws__AddChild *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__AddChild);
	if (soap_out_sws__AddChild(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__AddChild(struct soap *soap, const char *tag, int id, const struct sws__AddChild *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__AddChild), type))
		return soap->error;
	if (soap_out_sws__AddChildRequest(soap, "-in", -1, &a->__in, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct sws__AddChild * SOAP_FMAC4 soap_get_sws__AddChild(struct soap *soap, struct sws__AddChild *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__AddChild(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct sws__AddChild * SOAP_FMAC4 soap_in_sws__AddChild(struct soap *soap, const char *tag, struct sws__AddChild *a, const char *type)
{
	size_t soap_flag___in = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct sws__AddChild *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__AddChild, sizeof(struct sws__AddChild), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_sws__AddChild(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___in && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_sws__AddChildRequest(soap, "-in", &a->__in, "sws:AddChildRequest"))
				{	soap_flag___in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__AddChild *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_sws__AddChild, 0, sizeof(struct sws__AddChild), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag___in > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrp__GetResourcePropertyDocument(struct soap *soap, struct wsrp__GetResourcePropertyDocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrp__GetResourcePropertyDocument(struct soap *soap, const struct wsrp__GetResourcePropertyDocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrp__GetResourcePropertyDocument(struct soap *soap, const struct wsrp__GetResourcePropertyDocument *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrp__GetResourcePropertyDocument);
	if (soap_out_wsrp__GetResourcePropertyDocument(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrp__GetResourcePropertyDocument(struct soap *soap, const char *tag, int id, const struct wsrp__GetResourcePropertyDocument *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrp__GetResourcePropertyDocument), type))
		return soap->error;
	/* transient _ skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrp__GetResourcePropertyDocument * SOAP_FMAC4 soap_get_wsrp__GetResourcePropertyDocument(struct soap *soap, struct wsrp__GetResourcePropertyDocument *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrp__GetResourcePropertyDocument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsrp__GetResourcePropertyDocument * SOAP_FMAC4 soap_in_wsrp__GetResourcePropertyDocument(struct soap *soap, const char *tag, struct wsrp__GetResourcePropertyDocument *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsrp__GetResourcePropertyDocument *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrp__GetResourcePropertyDocument, sizeof(struct wsrp__GetResourcePropertyDocument), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrp__GetResourcePropertyDocument(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrp__GetResourcePropertyDocument *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrp__GetResourcePropertyDocument, 0, sizeof(struct wsrp__GetResourcePropertyDocument), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrp__SetResourceProperties(struct soap *soap, struct wsrp__SetResourceProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsrp__Insert = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrp__SetResourceProperties(struct soap *soap, const struct wsrp__SetResourceProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrp__SetResourceProperties(struct soap *soap, const struct wsrp__SetResourceProperties *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrp__SetResourceProperties);
	if (soap_out_wsrp__SetResourceProperties(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrp__SetResourceProperties(struct soap *soap, const char *tag, int id, const struct wsrp__SetResourceProperties *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrp__SetResourceProperties), type))
		return soap->error;
	soap_outliteral(soap, "wsrp:Insert", &a->wsrp__Insert, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrp__SetResourceProperties * SOAP_FMAC4 soap_get_wsrp__SetResourceProperties(struct soap *soap, struct wsrp__SetResourceProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrp__SetResourceProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsrp__SetResourceProperties * SOAP_FMAC4 soap_in_wsrp__SetResourceProperties(struct soap *soap, const char *tag, struct wsrp__SetResourceProperties *a, const char *type)
{
	size_t soap_flag_wsrp__Insert = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsrp__SetResourceProperties *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrp__SetResourceProperties, sizeof(struct wsrp__SetResourceProperties), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrp__SetResourceProperties(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrp__Insert && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "wsrp:Insert", &a->wsrp__Insert))
				{	soap_flag_wsrp__Insert--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrp__SetResourceProperties *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrp__SetResourceProperties, 0, sizeof(struct wsrp__SetResourceProperties), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrp__GetMultipleResourceProperties(struct soap *soap, struct wsrp__GetMultipleResourceProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsrp__GetMultipleResourcePropertiesRequest(soap, &a->in);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrp__GetMultipleResourceProperties(struct soap *soap, const struct wsrp__GetMultipleResourceProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wsrp__GetMultipleResourcePropertiesRequest(soap, &a->in);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrp__GetMultipleResourceProperties(struct soap *soap, const struct wsrp__GetMultipleResourceProperties *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrp__GetMultipleResourceProperties);
	if (soap_out_wsrp__GetMultipleResourceProperties(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrp__GetMultipleResourceProperties(struct soap *soap, const char *tag, int id, const struct wsrp__GetMultipleResourceProperties *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrp__GetMultipleResourceProperties), type))
		return soap->error;
	if (soap_out_wsrp__GetMultipleResourcePropertiesRequest(soap, "in", -1, &a->in, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrp__GetMultipleResourceProperties * SOAP_FMAC4 soap_get_wsrp__GetMultipleResourceProperties(struct soap *soap, struct wsrp__GetMultipleResourceProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrp__GetMultipleResourceProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsrp__GetMultipleResourceProperties * SOAP_FMAC4 soap_in_wsrp__GetMultipleResourceProperties(struct soap *soap, const char *tag, struct wsrp__GetMultipleResourceProperties *a, const char *type)
{
	size_t soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsrp__GetMultipleResourceProperties *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrp__GetMultipleResourceProperties, sizeof(struct wsrp__GetMultipleResourceProperties), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrp__GetMultipleResourceProperties(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsrp__GetMultipleResourcePropertiesRequest(soap, "in", &a->in, "wsrp:GetMultipleResourcePropertiesRequest"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrp__GetMultipleResourceProperties *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrp__GetMultipleResourceProperties, 0, sizeof(struct wsrp__GetMultipleResourceProperties), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsrp__GetResourceProperty(struct soap *soap, struct __wsrp__GetResourceProperty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->wsrp__GetResourceProperty);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsrp__GetResourceProperty(struct soap *soap, const struct __wsrp__GetResourceProperty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->wsrp__GetResourceProperty);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsrp__GetResourceProperty(struct soap *soap, const struct __wsrp__GetResourceProperty *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wsrp__GetResourceProperty(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsrp__GetResourceProperty(struct soap *soap, const char *tag, int id, const struct __wsrp__GetResourceProperty *a, const char *type)
{
	if (soap_out_xsd__string(soap, "wsrp:GetResourceProperty", -1, &a->wsrp__GetResourceProperty, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrp__GetResourceProperty * SOAP_FMAC4 soap_get___wsrp__GetResourceProperty(struct soap *soap, struct __wsrp__GetResourceProperty *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsrp__GetResourceProperty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __wsrp__GetResourceProperty * SOAP_FMAC4 soap_in___wsrp__GetResourceProperty(struct soap *soap, const char *tag, struct __wsrp__GetResourceProperty *a, const char *type)
{
	size_t soap_flag_wsrp__GetResourceProperty = 1;
	short soap_flag;
	a = (struct __wsrp__GetResourceProperty *)soap_id_enter(soap, "", a, SOAP_TYPE___wsrp__GetResourceProperty, sizeof(struct __wsrp__GetResourceProperty), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsrp__GetResourceProperty(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrp__GetResourceProperty && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "wsrp:GetResourceProperty", &a->wsrp__GetResourceProperty, "xsd:string"))
				{	soap_flag_wsrp__GetResourceProperty--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__DetachResponse(struct soap *soap, struct sws__DetachResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient rubbish skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__DetachResponse(struct soap *soap, const struct sws__DetachResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient rubbish skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__DetachResponse(struct soap *soap, const struct sws__DetachResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__DetachResponse);
	if (soap_out_sws__DetachResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__DetachResponse(struct soap *soap, const char *tag, int id, const struct sws__DetachResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__DetachResponse), type))
		return soap->error;
	/* transient rubbish skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct sws__DetachResponse * SOAP_FMAC4 soap_get_sws__DetachResponse(struct soap *soap, struct sws__DetachResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__DetachResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct sws__DetachResponse * SOAP_FMAC4 soap_in_sws__DetachResponse(struct soap *soap, const char *tag, struct sws__DetachResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct sws__DetachResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__DetachResponse, sizeof(struct sws__DetachResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_sws__DetachResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient rubbish skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__DetachResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_sws__DetachResponse, 0, sizeof(struct sws__DetachResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__AddChildResponse(struct soap *soap, struct sws__AddChildResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient rubbish skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__AddChildResponse(struct soap *soap, const struct sws__AddChildResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient rubbish skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__AddChildResponse(struct soap *soap, const struct sws__AddChildResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__AddChildResponse);
	if (soap_out_sws__AddChildResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__AddChildResponse(struct soap *soap, const char *tag, int id, const struct sws__AddChildResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__AddChildResponse), type))
		return soap->error;
	/* transient rubbish skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct sws__AddChildResponse * SOAP_FMAC4 soap_get_sws__AddChildResponse(struct soap *soap, struct sws__AddChildResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__AddChildResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct sws__AddChildResponse * SOAP_FMAC4 soap_in_sws__AddChildResponse(struct soap *soap, const char *tag, struct sws__AddChildResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct sws__AddChildResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__AddChildResponse, sizeof(struct sws__AddChildResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_sws__AddChildResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient rubbish skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__AddChildResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_sws__AddChildResponse, 0, sizeof(struct sws__AddChildResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__AddChildRequest(struct soap *soap, struct sws__AddChildRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->epr);
	soap_default_xsd__string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__AddChildRequest(struct soap *soap, const struct sws__AddChildRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->epr);
	soap_serialize_xsd__string(soap, &a->name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__AddChildRequest(struct soap *soap, const struct sws__AddChildRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__AddChildRequest);
	if (soap_out_sws__AddChildRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__AddChildRequest(struct soap *soap, const char *tag, int id, const struct sws__AddChildRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__AddChildRequest), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "epr", -1, &a->epr, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "name", -1, &a->name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct sws__AddChildRequest * SOAP_FMAC4 soap_get_sws__AddChildRequest(struct soap *soap, struct sws__AddChildRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__AddChildRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct sws__AddChildRequest * SOAP_FMAC4 soap_in_sws__AddChildRequest(struct soap *soap, const char *tag, struct sws__AddChildRequest *a, const char *type)
{
	size_t soap_flag_epr = 1;
	size_t soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct sws__AddChildRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__AddChildRequest, sizeof(struct sws__AddChildRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_sws__AddChildRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_epr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "epr", &a->epr, "xsd:string"))
				{	soap_flag_epr--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__AddChildRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_sws__AddChildRequest, 0, sizeof(struct sws__AddChildRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrp__SetResourcePropertiesResponse(struct soap *soap, struct wsrp__SetResourcePropertiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient rubbish skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrp__SetResourcePropertiesResponse(struct soap *soap, const struct wsrp__SetResourcePropertiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient rubbish skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrp__SetResourcePropertiesResponse(struct soap *soap, const struct wsrp__SetResourcePropertiesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrp__SetResourcePropertiesResponse);
	if (soap_out_wsrp__SetResourcePropertiesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrp__SetResourcePropertiesResponse(struct soap *soap, const char *tag, int id, const struct wsrp__SetResourcePropertiesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrp__SetResourcePropertiesResponse), type))
		return soap->error;
	/* transient rubbish skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrp__SetResourcePropertiesResponse * SOAP_FMAC4 soap_get_wsrp__SetResourcePropertiesResponse(struct soap *soap, struct wsrp__SetResourcePropertiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrp__SetResourcePropertiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsrp__SetResourcePropertiesResponse * SOAP_FMAC4 soap_in_wsrp__SetResourcePropertiesResponse(struct soap *soap, const char *tag, struct wsrp__SetResourcePropertiesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsrp__SetResourcePropertiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrp__SetResourcePropertiesResponse, sizeof(struct wsrp__SetResourcePropertiesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrp__SetResourcePropertiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient rubbish skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrp__SetResourcePropertiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrp__SetResourcePropertiesResponse, 0, sizeof(struct wsrp__SetResourcePropertiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrp__GetMultipleResourcePropertiesRequest(struct soap *soap, struct wsrp__GetMultipleResourcePropertiesRequest *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrp__GetMultipleResourcePropertiesRequest(struct soap *soap, struct wsrp__GetMultipleResourcePropertiesRequest const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_wsrp__GetMultipleResourcePropertiesRequest))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_wsrp__ResourcePropertyStruct);
			soap_serialize_wsrp__ResourcePropertyStruct(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrp__GetMultipleResourcePropertiesRequest(struct soap *soap, const struct wsrp__GetMultipleResourcePropertiesRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_wsrp__GetMultipleResourcePropertiesRequest);
	if (soap_out_wsrp__GetMultipleResourcePropertiesRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrp__GetMultipleResourcePropertiesRequest(struct soap *soap, const char *tag, int id, const struct wsrp__GetMultipleResourcePropertiesRequest *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_wsrp__GetMultipleResourcePropertiesRequest);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_wsrp__ResourcePropertyStruct(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrp__GetMultipleResourcePropertiesRequest * SOAP_FMAC4 soap_get_wsrp__GetMultipleResourcePropertiesRequest(struct soap *soap, struct wsrp__GetMultipleResourcePropertiesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrp__GetMultipleResourcePropertiesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsrp__GetMultipleResourcePropertiesRequest * SOAP_FMAC4 soap_in_wsrp__GetMultipleResourcePropertiesRequest(struct soap *soap, const char *tag, struct wsrp__GetMultipleResourcePropertiesRequest *a, const char *type)
{	int i, j;
	struct wsrp__ResourcePropertyStruct *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "wsrp:ResourcePropertyStruct") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct wsrp__GetMultipleResourcePropertiesRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrp__GetMultipleResourcePropertiesRequest, sizeof(struct wsrp__GetMultipleResourcePropertiesRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrp__GetMultipleResourcePropertiesRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct wsrp__ResourcePropertyStruct *)soap_malloc(soap, sizeof(struct wsrp__ResourcePropertyStruct) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_wsrp__ResourcePropertyStruct(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_wsrp__ResourcePropertyStruct(soap, NULL, a->__ptr + i, "wsrp:ResourcePropertyStruct"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct wsrp__ResourcePropertyStruct *)soap_push_block(soap, NULL, sizeof(struct wsrp__ResourcePropertyStruct));
				if (!p)
					return NULL;
				soap_default_wsrp__ResourcePropertyStruct(soap, p);
				if (!soap_in_wsrp__ResourcePropertyStruct(soap, NULL, p, "wsrp:ResourcePropertyStruct"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct wsrp__ResourcePropertyStruct *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrp__GetMultipleResourcePropertiesRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrp__GetMultipleResourcePropertiesRequest, 0, sizeof(struct wsrp__GetMultipleResourcePropertiesRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrp__ResourcePropertyStruct(struct soap *soap, struct wsrp__ResourcePropertyStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->ResourceProperty);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrp__ResourcePropertyStruct(struct soap *soap, const struct wsrp__ResourcePropertyStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->ResourceProperty);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrp__ResourcePropertyStruct(struct soap *soap, const struct wsrp__ResourcePropertyStruct *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrp__ResourcePropertyStruct);
	if (soap_out_wsrp__ResourcePropertyStruct(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrp__ResourcePropertyStruct(struct soap *soap, const char *tag, int id, const struct wsrp__ResourcePropertyStruct *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrp__ResourcePropertyStruct), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "ResourceProperty", -1, &a->ResourceProperty, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrp__ResourcePropertyStruct * SOAP_FMAC4 soap_get_wsrp__ResourcePropertyStruct(struct soap *soap, struct wsrp__ResourcePropertyStruct *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrp__ResourcePropertyStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsrp__ResourcePropertyStruct * SOAP_FMAC4 soap_in_wsrp__ResourcePropertyStruct(struct soap *soap, const char *tag, struct wsrp__ResourcePropertyStruct *a, const char *type)
{
	size_t soap_flag_ResourceProperty = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsrp__ResourcePropertyStruct *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrp__ResourcePropertyStruct, sizeof(struct wsrp__ResourcePropertyStruct), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrp__ResourcePropertyStruct(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceProperty && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "ResourceProperty", &a->ResourceProperty, "xsd:string"))
				{	soap_flag_ResourceProperty--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrp__ResourcePropertyStruct *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrp__ResourcePropertyStruct, 0, sizeof(struct wsrp__ResourcePropertyStruct), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__PutParamLogResponse(struct soap *soap, struct sws__PutParamLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _rubbish skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__PutParamLogResponse(struct soap *soap, const struct sws__PutParamLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _rubbish skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__PutParamLogResponse(struct soap *soap, const struct sws__PutParamLogResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__PutParamLogResponse);
	if (soap_out_sws__PutParamLogResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__PutParamLogResponse(struct soap *soap, const char *tag, int id, const struct sws__PutParamLogResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__PutParamLogResponse), type))
		return soap->error;
	/* transient _rubbish skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct sws__PutParamLogResponse * SOAP_FMAC4 soap_get_sws__PutParamLogResponse(struct soap *soap, struct sws__PutParamLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__PutParamLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct sws__PutParamLogResponse * SOAP_FMAC4 soap_in_sws__PutParamLogResponse(struct soap *soap, const char *tag, struct sws__PutParamLogResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct sws__PutParamLogResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__PutParamLogResponse, sizeof(struct sws__PutParamLogResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_sws__PutParamLogResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _rubbish skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__PutParamLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_sws__PutParamLogResponse, 0, sizeof(struct sws__PutParamLogResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrp__DestroyResponse(struct soap *soap, struct wsrp__DestroyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _rubbish skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrp__DestroyResponse(struct soap *soap, const struct wsrp__DestroyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _rubbish skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrp__DestroyResponse(struct soap *soap, const struct wsrp__DestroyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrp__DestroyResponse);
	if (soap_out_wsrp__DestroyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrp__DestroyResponse(struct soap *soap, const char *tag, int id, const struct wsrp__DestroyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrp__DestroyResponse), type))
		return soap->error;
	/* transient _rubbish skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrp__DestroyResponse * SOAP_FMAC4 soap_get_wsrp__DestroyResponse(struct soap *soap, struct wsrp__DestroyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrp__DestroyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsrp__DestroyResponse * SOAP_FMAC4 soap_in_wsrp__DestroyResponse(struct soap *soap, const char *tag, struct wsrp__DestroyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsrp__DestroyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrp__DestroyResponse, sizeof(struct wsrp__DestroyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrp__DestroyResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _rubbish skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrp__DestroyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrp__DestroyResponse, 0, sizeof(struct wsrp__DestroyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__AttachResponse(struct soap *soap, struct sws__AttachResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_reg__steerMessage(soap, &a->ReG_USCOREsteer_USCOREmessage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__AttachResponse(struct soap *soap, const struct sws__AttachResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_reg__steerMessage(soap, &a->ReG_USCOREsteer_USCOREmessage);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__AttachResponse(struct soap *soap, const struct sws__AttachResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__AttachResponse);
	if (soap_out_sws__AttachResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__AttachResponse(struct soap *soap, const char *tag, int id, const struct sws__AttachResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__AttachResponse), type))
		return soap->error;
	if (soap_out_reg__steerMessage(soap, "ReG_steer_message", -1, &a->ReG_USCOREsteer_USCOREmessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct sws__AttachResponse * SOAP_FMAC4 soap_get_sws__AttachResponse(struct soap *soap, struct sws__AttachResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__AttachResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct sws__AttachResponse * SOAP_FMAC4 soap_in_sws__AttachResponse(struct soap *soap, const char *tag, struct sws__AttachResponse *a, const char *type)
{
	size_t soap_flag_ReG_USCOREsteer_USCOREmessage = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct sws__AttachResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__AttachResponse, sizeof(struct sws__AttachResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_sws__AttachResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReG_USCOREsteer_USCOREmessage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_reg__steerMessage(soap, "ReG_steer_message", &a->ReG_USCOREsteer_USCOREmessage, "reg:steerMessage"))
				{	soap_flag_ReG_USCOREsteer_USCOREmessage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__AttachResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_sws__AttachResponse, 0, sizeof(struct sws__AttachResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ReG_USCOREsteer_USCOREmessage > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_reg__steerMessage(struct soap *soap, struct reg__steerMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_reg__supp_cmds(soap, &a->Supported_USCOREcommands);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_reg__steerMessage(struct soap *soap, const struct reg__steerMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_reg__supp_cmds(soap, &a->Supported_USCOREcommands);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_reg__steerMessage(struct soap *soap, const struct reg__steerMessage *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_reg__steerMessage);
	if (soap_out_reg__steerMessage(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_reg__steerMessage(struct soap *soap, const char *tag, int id, const struct reg__steerMessage *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_reg__steerMessage), type))
		return soap->error;
	if (soap_out_reg__supp_cmds(soap, "Supported_commands", -1, &a->Supported_USCOREcommands, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct reg__steerMessage * SOAP_FMAC4 soap_get_reg__steerMessage(struct soap *soap, struct reg__steerMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in_reg__steerMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct reg__steerMessage * SOAP_FMAC4 soap_in_reg__steerMessage(struct soap *soap, const char *tag, struct reg__steerMessage *a, const char *type)
{
	size_t soap_flag_Supported_USCOREcommands = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct reg__steerMessage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_reg__steerMessage, sizeof(struct reg__steerMessage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_reg__steerMessage(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Supported_USCOREcommands && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_reg__supp_cmds(soap, "Supported_commands", &a->Supported_USCOREcommands, "reg:supp-cmds"))
				{	soap_flag_Supported_USCOREcommands--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct reg__steerMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_reg__steerMessage, 0, sizeof(struct reg__steerMessage), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Supported_USCOREcommands > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_reg__supp_cmds(struct soap *soap, struct reg__supp_cmds *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_reg__supp_cmds(struct soap *soap, struct reg__supp_cmds const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_reg__supp_cmds))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_reg__Command);
			soap_serialize_reg__Command(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_reg__supp_cmds(struct soap *soap, const struct reg__supp_cmds *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_reg__supp_cmds);
	if (soap_out_reg__supp_cmds(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_reg__supp_cmds(struct soap *soap, const char *tag, int id, const struct reg__supp_cmds *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_reg__supp_cmds);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_reg__Command(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct reg__supp_cmds * SOAP_FMAC4 soap_get_reg__supp_cmds(struct soap *soap, struct reg__supp_cmds *p, const char *tag, const char *type)
{
	if ((p = soap_in_reg__supp_cmds(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct reg__supp_cmds * SOAP_FMAC4 soap_in_reg__supp_cmds(struct soap *soap, const char *tag, struct reg__supp_cmds *a, const char *type)
{	int i, j;
	struct reg__Command *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "reg:Command") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct reg__supp_cmds *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_reg__supp_cmds, sizeof(struct reg__supp_cmds), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_reg__supp_cmds(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct reg__Command *)soap_malloc(soap, sizeof(struct reg__Command) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_reg__Command(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_reg__Command(soap, NULL, a->__ptr + i, "reg:Command"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct reg__Command *)soap_push_block(soap, NULL, sizeof(struct reg__Command));
				if (!p)
					return NULL;
				soap_default_reg__Command(soap, p);
				if (!soap_in_reg__Command(soap, NULL, p, "reg:Command"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct reg__Command *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct reg__supp_cmds *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_reg__supp_cmds, 0, sizeof(struct reg__supp_cmds), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_reg__Command(struct soap *soap, struct reg__Command *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__int(soap, &a->Cmd_USCOREid);
	soap_default_xsd__string(soap, &a->Cmd_USCOREname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_reg__Command(struct soap *soap, const struct reg__Command *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->Cmd_USCOREname);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_reg__Command(struct soap *soap, const struct reg__Command *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_reg__Command);
	if (soap_out_reg__Command(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_reg__Command(struct soap *soap, const char *tag, int id, const struct reg__Command *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_reg__Command), type))
		return soap->error;
	if (soap_out_xsd__int(soap, "Cmd_id", -1, &a->Cmd_USCOREid, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "Cmd_name", -1, &a->Cmd_USCOREname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct reg__Command * SOAP_FMAC4 soap_get_reg__Command(struct soap *soap, struct reg__Command *p, const char *tag, const char *type)
{
	if ((p = soap_in_reg__Command(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct reg__Command * SOAP_FMAC4 soap_in_reg__Command(struct soap *soap, const char *tag, struct reg__Command *a, const char *type)
{
	size_t soap_flag_Cmd_USCOREid = 1;
	size_t soap_flag_Cmd_USCOREname = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct reg__Command *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_reg__Command, sizeof(struct reg__Command), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_reg__Command(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Cmd_USCOREid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "Cmd_id", &a->Cmd_USCOREid, "xsd:int"))
				{	soap_flag_Cmd_USCOREid--;
					continue;
				}
			if (soap_flag_Cmd_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "Cmd_name", &a->Cmd_USCOREname, "xsd:string"))
				{	soap_flag_Cmd_USCOREname--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct reg__Command *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_reg__Command, 0, sizeof(struct reg__Command), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Cmd_USCOREid > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__RecordCheckpointResponse(struct soap *soap, struct sws__RecordCheckpointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_RecordCheckpointReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__RecordCheckpointResponse(struct soap *soap, const struct sws__RecordCheckpointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->_RecordCheckpointReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__RecordCheckpointResponse(struct soap *soap, const struct sws__RecordCheckpointResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__RecordCheckpointResponse);
	if (soap_out_sws__RecordCheckpointResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__RecordCheckpointResponse(struct soap *soap, const char *tag, int id, const struct sws__RecordCheckpointResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__RecordCheckpointResponse), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "RecordCheckpointReturn", -1, &a->_RecordCheckpointReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct sws__RecordCheckpointResponse * SOAP_FMAC4 soap_get_sws__RecordCheckpointResponse(struct soap *soap, struct sws__RecordCheckpointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__RecordCheckpointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct sws__RecordCheckpointResponse * SOAP_FMAC4 soap_in_sws__RecordCheckpointResponse(struct soap *soap, const char *tag, struct sws__RecordCheckpointResponse *a, const char *type)
{
	size_t soap_flag__RecordCheckpointReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct sws__RecordCheckpointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__RecordCheckpointResponse, sizeof(struct sws__RecordCheckpointResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_sws__RecordCheckpointResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__RecordCheckpointReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_RecordCheckpointReturn, "xsd:string"))
				{	soap_flag__RecordCheckpointReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__RecordCheckpointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_sws__RecordCheckpointResponse, 0, sizeof(struct sws__RecordCheckpointResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__GetParamLogResponse(struct soap *soap, struct sws__GetParamLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->LogValues);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__GetParamLogResponse(struct soap *soap, const struct sws__GetParamLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->LogValues);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__GetParamLogResponse(struct soap *soap, const struct sws__GetParamLogResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__GetParamLogResponse);
	if (soap_out_sws__GetParamLogResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__GetParamLogResponse(struct soap *soap, const char *tag, int id, const struct sws__GetParamLogResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__GetParamLogResponse), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "LogValues", -1, &a->LogValues, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct sws__GetParamLogResponse * SOAP_FMAC4 soap_get_sws__GetParamLogResponse(struct soap *soap, struct sws__GetParamLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__GetParamLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct sws__GetParamLogResponse * SOAP_FMAC4 soap_in_sws__GetParamLogResponse(struct soap *soap, const char *tag, struct sws__GetParamLogResponse *a, const char *type)
{
	size_t soap_flag_LogValues = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct sws__GetParamLogResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__GetParamLogResponse, sizeof(struct sws__GetParamLogResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_sws__GetParamLogResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LogValues && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "LogValues", &a->LogValues, "xsd:string"))
				{	soap_flag_LogValues--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__GetParamLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_sws__GetParamLogResponse, 0, sizeof(struct sws__GetParamLogResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_epr(struct soap *soap, struct epr *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->wsa__Address);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_epr(struct soap *soap, const struct epr *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->wsa__Address);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_epr(struct soap *soap, const struct epr *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_epr);
	if (soap_out_epr(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_epr(struct soap *soap, const char *tag, int id, const struct epr *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_epr), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsa:Address", -1, &a->wsa__Address, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct epr * SOAP_FMAC4 soap_get_epr(struct soap *soap, struct epr *p, const char *tag, const char *type)
{
	if ((p = soap_in_epr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct epr * SOAP_FMAC4 soap_in_epr(struct soap *soap, const char *tag, struct epr *a, const char *type)
{
	size_t soap_flag_wsa__Address = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct epr *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_epr, sizeof(struct epr), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_epr(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "wsa:Address", &a->wsa__Address, "xsd:string"))
				{	soap_flag_wsa__Address--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct epr *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_epr, 0, sizeof(struct epr), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocptn__addNodeResponse(struct soap *soap, struct cptn__addNodeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cptn__addNodeResponse))
		soap_serialize_cptn__addNodeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocptn__addNodeResponse(struct soap *soap, struct cptn__addNodeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTocptn__addNodeResponse);
	if (soap_out_PointerTocptn__addNodeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocptn__addNodeResponse(struct soap *soap, const char *tag, int id, struct cptn__addNodeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cptn__addNodeResponse);
	if (id < 0)
		return soap->error;
	return soap_out_cptn__addNodeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cptn__addNodeResponse ** SOAP_FMAC4 soap_get_PointerTocptn__addNodeResponse(struct soap *soap, struct cptn__addNodeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocptn__addNodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cptn__addNodeResponse ** SOAP_FMAC4 soap_in_PointerTocptn__addNodeResponse(struct soap *soap, const char *tag, struct cptn__addNodeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cptn__addNodeResponse **)soap_malloc(soap, sizeof(struct cptn__addNodeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cptn__addNodeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cptn__addNodeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cptn__addNodeResponse, sizeof(struct cptn__addNodeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocptn__destroyResponse(struct soap *soap, struct cptn__destroyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cptn__destroyResponse))
		soap_serialize_cptn__destroyResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocptn__destroyResponse(struct soap *soap, struct cptn__destroyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTocptn__destroyResponse);
	if (soap_out_PointerTocptn__destroyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocptn__destroyResponse(struct soap *soap, const char *tag, int id, struct cptn__destroyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cptn__destroyResponse);
	if (id < 0)
		return soap->error;
	return soap_out_cptn__destroyResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cptn__destroyResponse ** SOAP_FMAC4 soap_get_PointerTocptn__destroyResponse(struct soap *soap, struct cptn__destroyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocptn__destroyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cptn__destroyResponse ** SOAP_FMAC4 soap_in_PointerTocptn__destroyResponse(struct soap *soap, const char *tag, struct cptn__destroyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cptn__destroyResponse **)soap_malloc(soap, sizeof(struct cptn__destroyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cptn__destroyResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cptn__destroyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cptn__destroyResponse, sizeof(struct cptn__destroyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocpt__getActiveTreesResponse(struct soap *soap, struct cpt__getActiveTreesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cpt__getActiveTreesResponse))
		soap_serialize_cpt__getActiveTreesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocpt__getActiveTreesResponse(struct soap *soap, struct cpt__getActiveTreesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTocpt__getActiveTreesResponse);
	if (soap_out_PointerTocpt__getActiveTreesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocpt__getActiveTreesResponse(struct soap *soap, const char *tag, int id, struct cpt__getActiveTreesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cpt__getActiveTreesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_cpt__getActiveTreesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cpt__getActiveTreesResponse ** SOAP_FMAC4 soap_get_PointerTocpt__getActiveTreesResponse(struct soap *soap, struct cpt__getActiveTreesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocpt__getActiveTreesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cpt__getActiveTreesResponse ** SOAP_FMAC4 soap_in_PointerTocpt__getActiveTreesResponse(struct soap *soap, const char *tag, struct cpt__getActiveTreesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cpt__getActiveTreesResponse **)soap_malloc(soap, sizeof(struct cpt__getActiveTreesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cpt__getActiveTreesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cpt__getActiveTreesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cpt__getActiveTreesResponse, sizeof(struct cpt__getActiveTreesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocpt__destroyResponse(struct soap *soap, struct cpt__destroyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cpt__destroyResponse))
		soap_serialize_cpt__destroyResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocpt__destroyResponse(struct soap *soap, struct cpt__destroyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTocpt__destroyResponse);
	if (soap_out_PointerTocpt__destroyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocpt__destroyResponse(struct soap *soap, const char *tag, int id, struct cpt__destroyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cpt__destroyResponse);
	if (id < 0)
		return soap->error;
	return soap_out_cpt__destroyResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cpt__destroyResponse ** SOAP_FMAC4 soap_get_PointerTocpt__destroyResponse(struct soap *soap, struct cpt__destroyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocpt__destroyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cpt__destroyResponse ** SOAP_FMAC4 soap_in_PointerTocpt__destroyResponse(struct soap *soap, const char *tag, struct cpt__destroyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cpt__destroyResponse **)soap_malloc(soap, sizeof(struct cpt__destroyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cpt__destroyResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cpt__destroyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cpt__destroyResponse, sizeof(struct cpt__destroyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocpt__findByHandleResponse(struct soap *soap, struct cpt__findByHandleResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cpt__findByHandleResponse))
		soap_serialize_cpt__findByHandleResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocpt__findByHandleResponse(struct soap *soap, struct cpt__findByHandleResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTocpt__findByHandleResponse);
	if (soap_out_PointerTocpt__findByHandleResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocpt__findByHandleResponse(struct soap *soap, const char *tag, int id, struct cpt__findByHandleResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cpt__findByHandleResponse);
	if (id < 0)
		return soap->error;
	return soap_out_cpt__findByHandleResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cpt__findByHandleResponse ** SOAP_FMAC4 soap_get_PointerTocpt__findByHandleResponse(struct soap *soap, struct cpt__findByHandleResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocpt__findByHandleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cpt__findByHandleResponse ** SOAP_FMAC4 soap_in_PointerTocpt__findByHandleResponse(struct soap *soap, const char *tag, struct cpt__findByHandleResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cpt__findByHandleResponse **)soap_malloc(soap, sizeof(struct cpt__findByHandleResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cpt__findByHandleResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cpt__findByHandleResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cpt__findByHandleResponse, sizeof(struct cpt__findByHandleResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocpt__createNewTreeResponse(struct soap *soap, struct cpt__createNewTreeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cpt__createNewTreeResponse))
		soap_serialize_cpt__createNewTreeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocpt__createNewTreeResponse(struct soap *soap, struct cpt__createNewTreeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTocpt__createNewTreeResponse);
	if (soap_out_PointerTocpt__createNewTreeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocpt__createNewTreeResponse(struct soap *soap, const char *tag, int id, struct cpt__createNewTreeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cpt__createNewTreeResponse);
	if (id < 0)
		return soap->error;
	return soap_out_cpt__createNewTreeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cpt__createNewTreeResponse ** SOAP_FMAC4 soap_get_PointerTocpt__createNewTreeResponse(struct soap *soap, struct cpt__createNewTreeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocpt__createNewTreeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cpt__createNewTreeResponse ** SOAP_FMAC4 soap_in_PointerTocpt__createNewTreeResponse(struct soap *soap, const char *tag, struct cpt__createNewTreeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cpt__createNewTreeResponse **)soap_malloc(soap, sizeof(struct cpt__createNewTreeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cpt__createNewTreeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cpt__createNewTreeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cpt__createNewTreeResponse, sizeof(struct cpt__createNewTreeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorsg__AddResponse(struct soap *soap, struct rsg__AddResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rsg__AddResponse))
		soap_serialize_rsg__AddResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorsg__AddResponse(struct soap *soap, struct rsg__AddResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorsg__AddResponse);
	if (soap_out_PointerTorsg__AddResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorsg__AddResponse(struct soap *soap, const char *tag, int id, struct rsg__AddResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rsg__AddResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rsg__AddResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rsg__AddResponse ** SOAP_FMAC4 soap_get_PointerTorsg__AddResponse(struct soap *soap, struct rsg__AddResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorsg__AddResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct rsg__AddResponse ** SOAP_FMAC4 soap_in_PointerTorsg__AddResponse(struct soap *soap, const char *tag, struct rsg__AddResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct rsg__AddResponse **)soap_malloc(soap, sizeof(struct rsg__AddResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rsg__AddResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rsg__AddResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rsg__AddResponse, sizeof(struct rsg__AddResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswsf__createSWSResourceResponse(struct soap *soap, struct swsf__createSWSResourceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_swsf__createSWSResourceResponse))
		soap_serialize_swsf__createSWSResourceResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswsf__createSWSResourceResponse(struct soap *soap, struct swsf__createSWSResourceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswsf__createSWSResourceResponse);
	if (soap_out_PointerToswsf__createSWSResourceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswsf__createSWSResourceResponse(struct soap *soap, const char *tag, int id, struct swsf__createSWSResourceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swsf__createSWSResourceResponse);
	if (id < 0)
		return soap->error;
	return soap_out_swsf__createSWSResourceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swsf__createSWSResourceResponse ** SOAP_FMAC4 soap_get_PointerToswsf__createSWSResourceResponse(struct soap *soap, struct swsf__createSWSResourceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswsf__createSWSResourceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct swsf__createSWSResourceResponse ** SOAP_FMAC4 soap_in_PointerToswsf__createSWSResourceResponse(struct soap *soap, const char *tag, struct swsf__createSWSResourceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swsf__createSWSResourceResponse **)soap_malloc(soap, sizeof(struct swsf__createSWSResourceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swsf__createSWSResourceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swsf__createSWSResourceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swsf__createSWSResourceResponse, sizeof(struct swsf__createSWSResourceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrp__DestroyResponse(struct soap *soap, struct wsrp__DestroyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrp__DestroyResponse))
		soap_serialize_wsrp__DestroyResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrp__DestroyResponse(struct soap *soap, struct wsrp__DestroyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsrp__DestroyResponse);
	if (soap_out_PointerTowsrp__DestroyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrp__DestroyResponse(struct soap *soap, const char *tag, int id, struct wsrp__DestroyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrp__DestroyResponse);
	if (id < 0)
		return soap->error;
	return soap_out_wsrp__DestroyResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrp__DestroyResponse ** SOAP_FMAC4 soap_get_PointerTowsrp__DestroyResponse(struct soap *soap, struct wsrp__DestroyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrp__DestroyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsrp__DestroyResponse ** SOAP_FMAC4 soap_in_PointerTowsrp__DestroyResponse(struct soap *soap, const char *tag, struct wsrp__DestroyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrp__DestroyResponse **)soap_malloc(soap, sizeof(struct wsrp__DestroyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrp__DestroyResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrp__DestroyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrp__DestroyResponse, sizeof(struct wsrp__DestroyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosws__PutParamLogResponse(struct soap *soap, struct sws__PutParamLogResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sws__PutParamLogResponse))
		soap_serialize_sws__PutParamLogResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosws__PutParamLogResponse(struct soap *soap, struct sws__PutParamLogResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosws__PutParamLogResponse);
	if (soap_out_PointerTosws__PutParamLogResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosws__PutParamLogResponse(struct soap *soap, const char *tag, int id, struct sws__PutParamLogResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sws__PutParamLogResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sws__PutParamLogResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sws__PutParamLogResponse ** SOAP_FMAC4 soap_get_PointerTosws__PutParamLogResponse(struct soap *soap, struct sws__PutParamLogResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosws__PutParamLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct sws__PutParamLogResponse ** SOAP_FMAC4 soap_in_PointerTosws__PutParamLogResponse(struct soap *soap, const char *tag, struct sws__PutParamLogResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct sws__PutParamLogResponse **)soap_malloc(soap, sizeof(struct sws__PutParamLogResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sws__PutParamLogResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sws__PutParamLogResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sws__PutParamLogResponse, sizeof(struct sws__PutParamLogResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosws__GetParamLogResponse(struct soap *soap, struct sws__GetParamLogResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sws__GetParamLogResponse))
		soap_serialize_sws__GetParamLogResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosws__GetParamLogResponse(struct soap *soap, struct sws__GetParamLogResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosws__GetParamLogResponse);
	if (soap_out_PointerTosws__GetParamLogResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosws__GetParamLogResponse(struct soap *soap, const char *tag, int id, struct sws__GetParamLogResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sws__GetParamLogResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sws__GetParamLogResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sws__GetParamLogResponse ** SOAP_FMAC4 soap_get_PointerTosws__GetParamLogResponse(struct soap *soap, struct sws__GetParamLogResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosws__GetParamLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct sws__GetParamLogResponse ** SOAP_FMAC4 soap_in_PointerTosws__GetParamLogResponse(struct soap *soap, const char *tag, struct sws__GetParamLogResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct sws__GetParamLogResponse **)soap_malloc(soap, sizeof(struct sws__GetParamLogResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sws__GetParamLogResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sws__GetParamLogResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sws__GetParamLogResponse, sizeof(struct sws__GetParamLogResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosws__RecordCheckpointResponse(struct soap *soap, struct sws__RecordCheckpointResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sws__RecordCheckpointResponse))
		soap_serialize_sws__RecordCheckpointResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosws__RecordCheckpointResponse(struct soap *soap, struct sws__RecordCheckpointResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosws__RecordCheckpointResponse);
	if (soap_out_PointerTosws__RecordCheckpointResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosws__RecordCheckpointResponse(struct soap *soap, const char *tag, int id, struct sws__RecordCheckpointResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sws__RecordCheckpointResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sws__RecordCheckpointResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sws__RecordCheckpointResponse ** SOAP_FMAC4 soap_get_PointerTosws__RecordCheckpointResponse(struct soap *soap, struct sws__RecordCheckpointResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosws__RecordCheckpointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct sws__RecordCheckpointResponse ** SOAP_FMAC4 soap_in_PointerTosws__RecordCheckpointResponse(struct soap *soap, const char *tag, struct sws__RecordCheckpointResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct sws__RecordCheckpointResponse **)soap_malloc(soap, sizeof(struct sws__RecordCheckpointResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sws__RecordCheckpointResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sws__RecordCheckpointResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sws__RecordCheckpointResponse, sizeof(struct sws__RecordCheckpointResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosws__DetachResponse(struct soap *soap, struct sws__DetachResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sws__DetachResponse))
		soap_serialize_sws__DetachResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosws__DetachResponse(struct soap *soap, struct sws__DetachResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosws__DetachResponse);
	if (soap_out_PointerTosws__DetachResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosws__DetachResponse(struct soap *soap, const char *tag, int id, struct sws__DetachResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sws__DetachResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sws__DetachResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sws__DetachResponse ** SOAP_FMAC4 soap_get_PointerTosws__DetachResponse(struct soap *soap, struct sws__DetachResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosws__DetachResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct sws__DetachResponse ** SOAP_FMAC4 soap_in_PointerTosws__DetachResponse(struct soap *soap, const char *tag, struct sws__DetachResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct sws__DetachResponse **)soap_malloc(soap, sizeof(struct sws__DetachResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sws__DetachResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sws__DetachResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sws__DetachResponse, sizeof(struct sws__DetachResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosws__AttachResponse(struct soap *soap, struct sws__AttachResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sws__AttachResponse))
		soap_serialize_sws__AttachResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosws__AttachResponse(struct soap *soap, struct sws__AttachResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosws__AttachResponse);
	if (soap_out_PointerTosws__AttachResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosws__AttachResponse(struct soap *soap, const char *tag, int id, struct sws__AttachResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sws__AttachResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sws__AttachResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sws__AttachResponse ** SOAP_FMAC4 soap_get_PointerTosws__AttachResponse(struct soap *soap, struct sws__AttachResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosws__AttachResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct sws__AttachResponse ** SOAP_FMAC4 soap_in_PointerTosws__AttachResponse(struct soap *soap, const char *tag, struct sws__AttachResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct sws__AttachResponse **)soap_malloc(soap, sizeof(struct sws__AttachResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sws__AttachResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sws__AttachResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sws__AttachResponse, sizeof(struct sws__AttachResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosws__AddChildResponse(struct soap *soap, struct sws__AddChildResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sws__AddChildResponse))
		soap_serialize_sws__AddChildResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosws__AddChildResponse(struct soap *soap, struct sws__AddChildResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosws__AddChildResponse);
	if (soap_out_PointerTosws__AddChildResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosws__AddChildResponse(struct soap *soap, const char *tag, int id, struct sws__AddChildResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sws__AddChildResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sws__AddChildResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sws__AddChildResponse ** SOAP_FMAC4 soap_get_PointerTosws__AddChildResponse(struct soap *soap, struct sws__AddChildResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosws__AddChildResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct sws__AddChildResponse ** SOAP_FMAC4 soap_in_PointerTosws__AddChildResponse(struct soap *soap, const char *tag, struct sws__AddChildResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct sws__AddChildResponse **)soap_malloc(soap, sizeof(struct sws__AddChildResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sws__AddChildResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sws__AddChildResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sws__AddChildResponse, sizeof(struct sws__AddChildResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrp__SetResourcePropertiesResponse(struct soap *soap, struct wsrp__SetResourcePropertiesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrp__SetResourcePropertiesResponse))
		soap_serialize_wsrp__SetResourcePropertiesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrp__SetResourcePropertiesResponse(struct soap *soap, struct wsrp__SetResourcePropertiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsrp__SetResourcePropertiesResponse);
	if (soap_out_PointerTowsrp__SetResourcePropertiesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrp__SetResourcePropertiesResponse(struct soap *soap, const char *tag, int id, struct wsrp__SetResourcePropertiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrp__SetResourcePropertiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_wsrp__SetResourcePropertiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrp__SetResourcePropertiesResponse ** SOAP_FMAC4 soap_get_PointerTowsrp__SetResourcePropertiesResponse(struct soap *soap, struct wsrp__SetResourcePropertiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrp__SetResourcePropertiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsrp__SetResourcePropertiesResponse ** SOAP_FMAC4 soap_in_PointerTowsrp__SetResourcePropertiesResponse(struct soap *soap, const char *tag, struct wsrp__SetResourcePropertiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrp__SetResourcePropertiesResponse **)soap_malloc(soap, sizeof(struct wsrp__SetResourcePropertiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrp__SetResourcePropertiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrp__SetResourcePropertiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrp__SetResourcePropertiesResponse, sizeof(struct wsrp__SetResourcePropertiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrp__ResourcePropertyStruct(struct soap *soap, struct wsrp__ResourcePropertyStruct *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrp__ResourcePropertyStruct))
		soap_serialize_wsrp__ResourcePropertyStruct(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrp__ResourcePropertyStruct(struct soap *soap, struct wsrp__ResourcePropertyStruct *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsrp__ResourcePropertyStruct);
	if (soap_out_PointerTowsrp__ResourcePropertyStruct(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrp__ResourcePropertyStruct(struct soap *soap, const char *tag, int id, struct wsrp__ResourcePropertyStruct *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrp__ResourcePropertyStruct);
	if (id < 0)
		return soap->error;
	return soap_out_wsrp__ResourcePropertyStruct(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrp__ResourcePropertyStruct ** SOAP_FMAC4 soap_get_PointerTowsrp__ResourcePropertyStruct(struct soap *soap, struct wsrp__ResourcePropertyStruct **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrp__ResourcePropertyStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsrp__ResourcePropertyStruct ** SOAP_FMAC4 soap_in_PointerTowsrp__ResourcePropertyStruct(struct soap *soap, const char *tag, struct wsrp__ResourcePropertyStruct **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrp__ResourcePropertyStruct **)soap_malloc(soap, sizeof(struct wsrp__ResourcePropertyStruct *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrp__ResourcePropertyStruct(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrp__ResourcePropertyStruct **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrp__ResourcePropertyStruct, sizeof(struct wsrp__ResourcePropertyStruct), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToreg__Command(struct soap *soap, struct reg__Command *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_reg__Command))
		soap_serialize_reg__Command(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToreg__Command(struct soap *soap, struct reg__Command *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToreg__Command);
	if (soap_out_PointerToreg__Command(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToreg__Command(struct soap *soap, const char *tag, int id, struct reg__Command *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_reg__Command);
	if (id < 0)
		return soap->error;
	return soap_out_reg__Command(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct reg__Command ** SOAP_FMAC4 soap_get_PointerToreg__Command(struct soap *soap, struct reg__Command **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToreg__Command(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct reg__Command ** SOAP_FMAC4 soap_in_PointerToreg__Command(struct soap *soap, const char *tag, struct reg__Command **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct reg__Command **)soap_malloc(soap, sizeof(struct reg__Command *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_reg__Command(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct reg__Command **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_reg__Command, sizeof(struct reg__Command), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__string);
	if (soap_out_xsd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
