/* soapC.c
   Generated by gSOAP 2.7.2 from all_hdrs.h
   Copyright (C) 2000-2005, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/
#include "soapH.h"
#ifdef __cplusplus
extern "C" {
#endif

SOAP_BEGIN_NAMESPACE(soap)

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.7.2 2005-10-12 13:54:46 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version != 1 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_xsd__int:
		return soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_rgt__addNode:
		return soap_in_rgt__addNode(soap, NULL, NULL, "rgt:addNode");
	case SOAP_TYPE_rgt__getParentNode:
		return soap_in_rgt__getParentNode(soap, NULL, NULL, "rgt:getParentNode");
	case SOAP_TYPE_rgt__getCheckPointData:
		return soap_in_rgt__getCheckPointData(soap, NULL, NULL, "rgt:getCheckPointData");
	case SOAP_TYPE_rgt__requestTerminationBefore:
		return soap_in_rgt__requestTerminationBefore(soap, NULL, NULL, "rgt:requestTerminationBefore");
	case SOAP_TYPE_rgt__getSteeringCommands:
		return soap_in_rgt__getSteeringCommands(soap, NULL, NULL, "rgt:getSteeringCommands");
	case SOAP_TYPE_rgt__destroy:
		return soap_in_rgt__destroy(soap, NULL, NULL, "rgt:destroy");
	case SOAP_TYPE_rgt__setCheckPointData:
		return soap_in_rgt__setCheckPointData(soap, NULL, NULL, "rgt:setCheckPointData");
	case SOAP_TYPE_rgt__findServiceData:
		return soap_in_rgt__findServiceData(soap, NULL, NULL, "rgt:findServiceData");
	case SOAP_TYPE_rgt__getInputFile:
		return soap_in_rgt__getInputFile(soap, NULL, NULL, "rgt:getInputFile");
	case SOAP_TYPE_rgt__getChildNodes:
		return soap_in_rgt__getChildNodes(soap, NULL, NULL, "rgt:getChildNodes");
	case SOAP_TYPE_rgt__requestTerminationAfter:
		return soap_in_rgt__requestTerminationAfter(soap, NULL, NULL, "rgt:requestTerminationAfter");
	case SOAP_TYPE_rgt__destroyResponse:
		return soap_in_rgt__destroyResponse(soap, NULL, NULL, "rgt:destroyResponse");
	case SOAP_TYPE_rgt__getInputFileResponse:
		return soap_in_rgt__getInputFileResponse(soap, NULL, NULL, "rgt:getInputFileResponse");
	case SOAP_TYPE_rgt__getSteeringCommandsResponse:
		return soap_in_rgt__getSteeringCommandsResponse(soap, NULL, NULL, "rgt:getSteeringCommandsResponse");
	case SOAP_TYPE_rgt__requestTerminationBeforeResponse:
		return soap_in_rgt__requestTerminationBeforeResponse(soap, NULL, NULL, "rgt:requestTerminationBeforeResponse");
	case SOAP_TYPE_rgt__getChildNodesResponse:
		return soap_in_rgt__getChildNodesResponse(soap, NULL, NULL, "rgt:getChildNodesResponse");
	case SOAP_TYPE_rgt__setCheckPointDataResponse:
		return soap_in_rgt__setCheckPointDataResponse(soap, NULL, NULL, "rgt:setCheckPointDataResponse");
	case SOAP_TYPE_rgt__findServiceDataResponse:
		return soap_in_rgt__findServiceDataResponse(soap, NULL, NULL, "rgt:findServiceDataResponse");
	case SOAP_TYPE_rgt__getCheckPointDataResponse:
		return soap_in_rgt__getCheckPointDataResponse(soap, NULL, NULL, "rgt:getCheckPointDataResponse");
	case SOAP_TYPE_rgt__addNodeResponse:
		return soap_in_rgt__addNodeResponse(soap, NULL, NULL, "rgt:addNodeResponse");
	case SOAP_TYPE_rgt__requestTerminationAfterResponse:
		return soap_in_rgt__requestTerminationAfterResponse(soap, NULL, NULL, "rgt:requestTerminationAfterResponse");
	case SOAP_TYPE_rgt__getParentNodeResponse:
		return soap_in_rgt__getParentNodeResponse(soap, NULL, NULL, "rgt:getParentNodeResponse");
	case SOAP_TYPE_rgtf__requestTerminationAfter:
		return soap_in_rgtf__requestTerminationAfter(soap, NULL, NULL, "rgtf:requestTerminationAfter");
	case SOAP_TYPE_rgtf__requestTerminationBefore:
		return soap_in_rgtf__requestTerminationBefore(soap, NULL, NULL, "rgtf:requestTerminationBefore");
	case SOAP_TYPE_rgtf__getActiveTrees:
		return soap_in_rgtf__getActiveTrees(soap, NULL, NULL, "rgtf:getActiveTrees");
	case SOAP_TYPE_rgtf__findServiceData:
		return soap_in_rgtf__findServiceData(soap, NULL, NULL, "rgtf:findServiceData");
	case SOAP_TYPE_rgtf__destroy:
		return soap_in_rgtf__destroy(soap, NULL, NULL, "rgtf:destroy");
	case SOAP_TYPE_rgtf__findByHandle:
		return soap_in_rgtf__findByHandle(soap, NULL, NULL, "rgtf:findByHandle");
	case SOAP_TYPE_rgtf__createNewTree:
		return soap_in_rgtf__createNewTree(soap, NULL, NULL, "rgtf:createNewTree");
	case SOAP_TYPE_rgtf__destroyResponse:
		return soap_in_rgtf__destroyResponse(soap, NULL, NULL, "rgtf:destroyResponse");
	case SOAP_TYPE_rgtf__requestTerminationAfterResponse:
		return soap_in_rgtf__requestTerminationAfterResponse(soap, NULL, NULL, "rgtf:requestTerminationAfterResponse");
	case SOAP_TYPE_rgtf__createNewTreeResponse:
		return soap_in_rgtf__createNewTreeResponse(soap, NULL, NULL, "rgtf:createNewTreeResponse");
	case SOAP_TYPE_rgtf__getActiveTreesResponse:
		return soap_in_rgtf__getActiveTreesResponse(soap, NULL, NULL, "rgtf:getActiveTreesResponse");
	case SOAP_TYPE_rgtf__findByHandleResponse:
		return soap_in_rgtf__findByHandleResponse(soap, NULL, NULL, "rgtf:findByHandleResponse");
	case SOAP_TYPE_rgtf__findServiceDataResponse:
		return soap_in_rgtf__findServiceDataResponse(soap, NULL, NULL, "rgtf:findServiceDataResponse");
	case SOAP_TYPE_rgtf__requestTerminationBeforeResponse:
		return soap_in_rgtf__requestTerminationBeforeResponse(soap, NULL, NULL, "rgtf:requestTerminationBeforeResponse");
	case SOAP_TYPE_sgr__findServiceData:
		return soap_in_sgr__findServiceData(soap, NULL, NULL, "sgr:findServiceData");
	case SOAP_TYPE_sgr__add:
		return soap_in_sgr__add(soap, NULL, NULL, "sgr:add");
	case SOAP_TYPE_sgr__remove:
		return soap_in_sgr__remove(soap, NULL, NULL, "sgr:remove");
	case SOAP_TYPE_sgr__removeResponse:
		return soap_in_sgr__removeResponse(soap, NULL, NULL, "sgr:removeResponse");
	case SOAP_TYPE_ArrayOf_USCORE_xsd_USCORE_string:
		return soap_in_ArrayOf_USCORE_xsd_USCORE_string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_sgr__addResponse:
		return soap_in_sgr__addResponse(soap, NULL, NULL, "sgr:addResponse");
	case SOAP_TYPE_sgr__findServiceDataResponse:
		return soap_in_sgr__findServiceDataResponse(soap, NULL, NULL, "sgr:findServiceDataResponse");
	case SOAP_TYPE_swsf__createSWSResource:
		return soap_in_swsf__createSWSResource(soap, NULL, NULL, "swsf:createSWSResource");
	case SOAP_TYPE_swsf__createSWSResourceResponse:
		return soap_in_swsf__createSWSResourceResponse(soap, NULL, NULL, "swsf:createSWSResourceResponse");
	case SOAP_TYPE_epr:
		return soap_in_epr(soap, NULL, NULL, "epr");
	case SOAP_TYPE_sgsf__createService:
		return soap_in_sgsf__createService(soap, NULL, NULL, "sgsf:createService");
	case SOAP_TYPE_sgsf__destroy:
		return soap_in_sgsf__destroy(soap, NULL, NULL, "sgsf:destroy");
	case SOAP_TYPE_sgsf__registerSelf:
		return soap_in_sgsf__registerSelf(soap, NULL, NULL, "sgsf:registerSelf");
	case SOAP_TYPE_sgsf__registerSelfResponse:
		return soap_in_sgsf__registerSelfResponse(soap, NULL, NULL, "sgsf:registerSelfResponse");
	case SOAP_TYPE_sgsf__destroyResponse:
		return soap_in_sgsf__destroyResponse(soap, NULL, NULL, "sgsf:destroyResponse");
	case SOAP_TYPE_sgsf__createServiceResponse:
		return soap_in_sgsf__createServiceResponse(soap, NULL, NULL, "sgsf:createServiceResponse");
	case SOAP_TYPE_sgs__AppStop:
		return soap_in_sgs__AppStop(soap, NULL, NULL, "sgs:AppStop");
	case SOAP_TYPE_sgs__GetNotifications:
		return soap_in_sgs__GetNotifications(soap, NULL, NULL, "sgs:GetNotifications");
	case SOAP_TYPE_sgs__GetControl:
		return soap_in_sgs__GetControl(soap, NULL, NULL, "sgs:GetControl");
	case SOAP_TYPE_sgs__destroy:
		return soap_in_sgs__destroy(soap, NULL, NULL, "sgs:destroy");
	case SOAP_TYPE_sgs__findServiceData:
		return soap_in_sgs__findServiceData(soap, NULL, NULL, "sgs:findServiceData");
	case SOAP_TYPE_sgs__GetNthDataSource:
		return soap_in_sgs__GetNthDataSource(soap, NULL, NULL, "sgs:GetNthDataSource");
	case SOAP_TYPE_sgs__Restart:
		return soap_in_sgs__Restart(soap, NULL, NULL, "sgs:Restart");
	case SOAP_TYPE_sgs__PutControl:
		return soap_in_sgs__PutControl(soap, NULL, NULL, "sgs:PutControl");
	case SOAP_TYPE_sgs__Pause:
		return soap_in_sgs__Pause(soap, NULL, NULL, "sgs:Pause");
	case SOAP_TYPE_sgs__AppDetach:
		return soap_in_sgs__AppDetach(soap, NULL, NULL, "sgs:AppDetach");
	case SOAP_TYPE_sgs__AppPutLog:
		return soap_in_sgs__AppPutLog(soap, NULL, NULL, "sgs:AppPutLog");
	case SOAP_TYPE_sgs__setServiceData:
		return soap_in_sgs__setServiceData(soap, NULL, NULL, "sgs:setServiceData");
	case SOAP_TYPE_sgs__GetParamLog:
		return soap_in_sgs__GetParamLog(soap, NULL, NULL, "sgs:GetParamLog");
	case SOAP_TYPE_sgs__AppStart:
		return soap_in_sgs__AppStart(soap, NULL, NULL, "sgs:AppStart");
	case SOAP_TYPE_sgs__PutStatus:
		return soap_in_sgs__PutStatus(soap, NULL, NULL, "sgs:PutStatus");
	case SOAP_TYPE_sgs__AppRecordChkpoint:
		return soap_in_sgs__AppRecordChkpoint(soap, NULL, NULL, "sgs:AppRecordChkpoint");
	case SOAP_TYPE_sgs__Resume:
		return soap_in_sgs__Resume(soap, NULL, NULL, "sgs:Resume");
	case SOAP_TYPE_sgs__Detach:
		return soap_in_sgs__Detach(soap, NULL, NULL, "sgs:Detach");
	case SOAP_TYPE_sgs__ClearStatusMsgQueue:
		return soap_in_sgs__ClearStatusMsgQueue(soap, NULL, NULL, "sgs:ClearStatusMsgQueue");
	case SOAP_TYPE_sgs__Stop:
		return soap_in_sgs__Stop(soap, NULL, NULL, "sgs:Stop");
	case SOAP_TYPE_sgs__GetStatus:
		return soap_in_sgs__GetStatus(soap, NULL, NULL, "sgs:GetStatus");
	case SOAP_TYPE_sgs__Attach:
		return soap_in_sgs__Attach(soap, NULL, NULL, "sgs:Attach");
	case SOAP_TYPE_sgs__AppDetachResponse:
		return soap_in_sgs__AppDetachResponse(soap, NULL, NULL, "sgs:AppDetachResponse");
	case SOAP_TYPE_sgs__AppStartResponse:
		return soap_in_sgs__AppStartResponse(soap, NULL, NULL, "sgs:AppStartResponse");
	case SOAP_TYPE_sgs__GetNthDataSourceResponse:
		return soap_in_sgs__GetNthDataSourceResponse(soap, NULL, NULL, "sgs:GetNthDataSourceResponse");
	case SOAP_TYPE_sgs__AppPutLogResponse:
		return soap_in_sgs__AppPutLogResponse(soap, NULL, NULL, "sgs:AppPutLogResponse");
	case SOAP_TYPE_sgs__ClearStatusMsgQueueResponse:
		return soap_in_sgs__ClearStatusMsgQueueResponse(soap, NULL, NULL, "sgs:ClearStatusMsgQueueResponse");
	case SOAP_TYPE_sgs__destroyResponse:
		return soap_in_sgs__destroyResponse(soap, NULL, NULL, "sgs:destroyResponse");
	case SOAP_TYPE_sgs__AppStopResponse:
		return soap_in_sgs__AppStopResponse(soap, NULL, NULL, "sgs:AppStopResponse");
	case SOAP_TYPE_sgs__GetStatusResponse:
		return soap_in_sgs__GetStatusResponse(soap, NULL, NULL, "sgs:GetStatusResponse");
	case SOAP_TYPE_sgs__GetControlResponse:
		return soap_in_sgs__GetControlResponse(soap, NULL, NULL, "sgs:GetControlResponse");
	case SOAP_TYPE_sgs__StopResponse:
		return soap_in_sgs__StopResponse(soap, NULL, NULL, "sgs:StopResponse");
	case SOAP_TYPE_sgs__GetNotificationsResponse:
		return soap_in_sgs__GetNotificationsResponse(soap, NULL, NULL, "sgs:GetNotificationsResponse");
	case SOAP_TYPE_sgs__AttachResponse:
		return soap_in_sgs__AttachResponse(soap, NULL, NULL, "sgs:AttachResponse");
	case SOAP_TYPE_sgs__ResumeResponse:
		return soap_in_sgs__ResumeResponse(soap, NULL, NULL, "sgs:ResumeResponse");
	case SOAP_TYPE_sgs__PutControlResponse:
		return soap_in_sgs__PutControlResponse(soap, NULL, NULL, "sgs:PutControlResponse");
	case SOAP_TYPE_sgs__RestartResponse:
		return soap_in_sgs__RestartResponse(soap, NULL, NULL, "sgs:RestartResponse");
	case SOAP_TYPE_sgs__findServiceDataResponse:
		return soap_in_sgs__findServiceDataResponse(soap, NULL, NULL, "sgs:findServiceDataResponse");
	case SOAP_TYPE_sgs__PauseResponse:
		return soap_in_sgs__PauseResponse(soap, NULL, NULL, "sgs:PauseResponse");
	case SOAP_TYPE_sgs__setServiceDataResponse:
		return soap_in_sgs__setServiceDataResponse(soap, NULL, NULL, "sgs:setServiceDataResponse");
	case SOAP_TYPE_sgs__PutStatusResponse:
		return soap_in_sgs__PutStatusResponse(soap, NULL, NULL, "sgs:PutStatusResponse");
	case SOAP_TYPE_sgs__AppRecordChkpointResponse:
		return soap_in_sgs__AppRecordChkpointResponse(soap, NULL, NULL, "sgs:AppRecordChkpointResponse");
	case SOAP_TYPE_sgs__DetachResponse:
		return soap_in_sgs__DetachResponse(soap, NULL, NULL, "sgs:DetachResponse");
	case SOAP_TYPE_sgs__GetParamLogResponse:
		return soap_in_sgs__GetParamLogResponse(soap, NULL, NULL, "sgs:GetParamLogResponse");
	case SOAP_TYPE_wsrp__Destroy:
		return soap_in_wsrp__Destroy(soap, NULL, NULL, "wsrp:Destroy");
	case SOAP_TYPE_sws__PutParamLog:
		return soap_in_sws__PutParamLog(soap, NULL, NULL, "sws:PutParamLog");
	case SOAP_TYPE_sws__GetParamLog:
		return soap_in_sws__GetParamLog(soap, NULL, NULL, "sws:GetParamLog");
	case SOAP_TYPE_sws__RecordCheckpoint:
		return soap_in_sws__RecordCheckpoint(soap, NULL, NULL, "sws:RecordCheckpoint");
	case SOAP_TYPE_sws__Detach:
		return soap_in_sws__Detach(soap, NULL, NULL, "sws:Detach");
	case SOAP_TYPE_sws__Attach:
		return soap_in_sws__Attach(soap, NULL, NULL, "sws:Attach");
	case SOAP_TYPE_sws__AddChild:
		return soap_in_sws__AddChild(soap, NULL, NULL, "sws:AddChild");
	case SOAP_TYPE_wsrp__GetResourcePropertyDocument:
		return soap_in_wsrp__GetResourcePropertyDocument(soap, NULL, NULL, "wsrp:GetResourcePropertyDocument");
	case SOAP_TYPE_wsrp__SetResourceProperties:
		return soap_in_wsrp__SetResourceProperties(soap, NULL, NULL, "wsrp:SetResourceProperties");
	case SOAP_TYPE_wsrp__GetMultipleResourceProperties:
		return soap_in_wsrp__GetMultipleResourceProperties(soap, NULL, NULL, "wsrp:GetMultipleResourceProperties");
	case SOAP_TYPE_wsrp__GetResourceProperty:
		return soap_in_wsrp__GetResourceProperty(soap, NULL, NULL, "wsrp:GetResourceProperty");
	case SOAP_TYPE_sws__DetachResponse:
		return soap_in_sws__DetachResponse(soap, NULL, NULL, "sws:DetachResponse");
	case SOAP_TYPE_sws__AddChildResponse:
		return soap_in_sws__AddChildResponse(soap, NULL, NULL, "sws:AddChildResponse");
	case SOAP_TYPE_sws__AddChildRequest:
		return soap_in_sws__AddChildRequest(soap, NULL, NULL, "sws:AddChildRequest");
	case SOAP_TYPE_wsrp__SetResourcePropertiesResponse:
		return soap_in_wsrp__SetResourcePropertiesResponse(soap, NULL, NULL, "wsrp:SetResourcePropertiesResponse");
	case SOAP_TYPE_wsrp__GetMultipleResourcePropertiesRequest:
		return soap_in_wsrp__GetMultipleResourcePropertiesRequest(soap, NULL, NULL, "wsrp:GetMultipleResourcePropertiesRequest");
	case SOAP_TYPE_wsrp__ResourcePropertyStruct:
		return soap_in_wsrp__ResourcePropertyStruct(soap, NULL, NULL, "wsrp:ResourcePropertyStruct");
	case SOAP_TYPE_wsrp__GetResourcePropertyResponse:
		return soap_in_wsrp__GetResourcePropertyResponse(soap, NULL, NULL, "wsrp:GetResourcePropertyResponse");
	case SOAP_TYPE_GetResourcePropertyRequest:
		return soap_in_GetResourcePropertyRequest(soap, NULL, NULL, "GetResourcePropertyRequest");
	case SOAP_TYPE_sws__PutParamLogResponse:
		return soap_in_sws__PutParamLogResponse(soap, NULL, NULL, "sws:PutParamLogResponse");
	case SOAP_TYPE_wsrp__DestroyResponse:
		return soap_in_wsrp__DestroyResponse(soap, NULL, NULL, "wsrp:DestroyResponse");
	case SOAP_TYPE_sws__AttachResponse:
		return soap_in_sws__AttachResponse(soap, NULL, NULL, "sws:AttachResponse");
	case SOAP_TYPE_steerMessage:
		return soap_in_steerMessage(soap, NULL, NULL, "steerMessage");
	case SOAP_TYPE_supp_cmds:
		return soap_in_supp_cmds(soap, NULL, NULL, "Command");
	case SOAP_TYPE_Command:
		return soap_in_Command(soap, NULL, NULL, "Command");
	case SOAP_TYPE_sws__RecordCheckpointResponse:
		return soap_in_sws__RecordCheckpointResponse(soap, NULL, NULL, "sws:RecordCheckpointResponse");
	case SOAP_TYPE_sws__GetParamLogResponse:
		return soap_in_sws__GetParamLogResponse(soap, NULL, NULL, "sws:GetParamLogResponse");
	case SOAP_TYPE_PointerTorgt__addNodeResponse:
		return soap_in_PointerTorgt__addNodeResponse(soap, NULL, NULL, "rgt:addNodeResponse");
	case SOAP_TYPE_PointerTorgt__getParentNodeResponse:
		return soap_in_PointerTorgt__getParentNodeResponse(soap, NULL, NULL, "rgt:getParentNodeResponse");
	case SOAP_TYPE_PointerTorgt__getCheckPointDataResponse:
		return soap_in_PointerTorgt__getCheckPointDataResponse(soap, NULL, NULL, "rgt:getCheckPointDataResponse");
	case SOAP_TYPE_PointerTorgt__requestTerminationBeforeResponse:
		return soap_in_PointerTorgt__requestTerminationBeforeResponse(soap, NULL, NULL, "rgt:requestTerminationBeforeResponse");
	case SOAP_TYPE_PointerTorgt__getSteeringCommandsResponse:
		return soap_in_PointerTorgt__getSteeringCommandsResponse(soap, NULL, NULL, "rgt:getSteeringCommandsResponse");
	case SOAP_TYPE_PointerTorgt__destroyResponse:
		return soap_in_PointerTorgt__destroyResponse(soap, NULL, NULL, "rgt:destroyResponse");
	case SOAP_TYPE_PointerTorgt__setCheckPointDataResponse:
		return soap_in_PointerTorgt__setCheckPointDataResponse(soap, NULL, NULL, "rgt:setCheckPointDataResponse");
	case SOAP_TYPE_PointerTorgt__findServiceDataResponse:
		return soap_in_PointerTorgt__findServiceDataResponse(soap, NULL, NULL, "rgt:findServiceDataResponse");
	case SOAP_TYPE_PointerTorgt__getInputFileResponse:
		return soap_in_PointerTorgt__getInputFileResponse(soap, NULL, NULL, "rgt:getInputFileResponse");
	case SOAP_TYPE_PointerTorgt__getChildNodesResponse:
		return soap_in_PointerTorgt__getChildNodesResponse(soap, NULL, NULL, "rgt:getChildNodesResponse");
	case SOAP_TYPE_PointerTorgt__requestTerminationAfterResponse:
		return soap_in_PointerTorgt__requestTerminationAfterResponse(soap, NULL, NULL, "rgt:requestTerminationAfterResponse");
	case SOAP_TYPE_PointerTorgtf__requestTerminationAfterResponse:
		return soap_in_PointerTorgtf__requestTerminationAfterResponse(soap, NULL, NULL, "rgtf:requestTerminationAfterResponse");
	case SOAP_TYPE_PointerTorgtf__requestTerminationBeforeResponse:
		return soap_in_PointerTorgtf__requestTerminationBeforeResponse(soap, NULL, NULL, "rgtf:requestTerminationBeforeResponse");
	case SOAP_TYPE_PointerTorgtf__getActiveTreesResponse:
		return soap_in_PointerTorgtf__getActiveTreesResponse(soap, NULL, NULL, "rgtf:getActiveTreesResponse");
	case SOAP_TYPE_PointerTorgtf__findServiceDataResponse:
		return soap_in_PointerTorgtf__findServiceDataResponse(soap, NULL, NULL, "rgtf:findServiceDataResponse");
	case SOAP_TYPE_PointerTorgtf__destroyResponse:
		return soap_in_PointerTorgtf__destroyResponse(soap, NULL, NULL, "rgtf:destroyResponse");
	case SOAP_TYPE_PointerTorgtf__findByHandleResponse:
		return soap_in_PointerTorgtf__findByHandleResponse(soap, NULL, NULL, "rgtf:findByHandleResponse");
	case SOAP_TYPE_PointerTorgtf__createNewTreeResponse:
		return soap_in_PointerTorgtf__createNewTreeResponse(soap, NULL, NULL, "rgtf:createNewTreeResponse");
	case SOAP_TYPE_PointerTosgr__findServiceDataResponse:
		return soap_in_PointerTosgr__findServiceDataResponse(soap, NULL, NULL, "sgr:findServiceDataResponse");
	case SOAP_TYPE_PointerTosgr__addResponse:
		return soap_in_PointerTosgr__addResponse(soap, NULL, NULL, "sgr:addResponse");
	case SOAP_TYPE_PointerTosgr__removeResponse:
		return soap_in_PointerTosgr__removeResponse(soap, NULL, NULL, "sgr:removeResponse");
	case SOAP_TYPE_PointerToxsd__string:
		return soap_in_PointerToxsd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToArrayOf_USCORE_xsd_USCORE_string:
		return soap_in_PointerToArrayOf_USCORE_xsd_USCORE_string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToswsf__createSWSResourceResponse:
		return soap_in_PointerToswsf__createSWSResourceResponse(soap, NULL, NULL, "swsf:createSWSResourceResponse");
	case SOAP_TYPE_PointerTosgsf__createServiceResponse:
		return soap_in_PointerTosgsf__createServiceResponse(soap, NULL, NULL, "sgsf:createServiceResponse");
	case SOAP_TYPE_PointerTosgsf__destroyResponse:
		return soap_in_PointerTosgsf__destroyResponse(soap, NULL, NULL, "sgsf:destroyResponse");
	case SOAP_TYPE_PointerTosgsf__registerSelfResponse:
		return soap_in_PointerTosgsf__registerSelfResponse(soap, NULL, NULL, "sgsf:registerSelfResponse");
	case SOAP_TYPE_PointerTosgs__AppStopResponse:
		return soap_in_PointerTosgs__AppStopResponse(soap, NULL, NULL, "sgs:AppStopResponse");
	case SOAP_TYPE_PointerTosgs__GetNotificationsResponse:
		return soap_in_PointerTosgs__GetNotificationsResponse(soap, NULL, NULL, "sgs:GetNotificationsResponse");
	case SOAP_TYPE_PointerTosgs__GetControlResponse:
		return soap_in_PointerTosgs__GetControlResponse(soap, NULL, NULL, "sgs:GetControlResponse");
	case SOAP_TYPE_PointerTosgs__destroyResponse:
		return soap_in_PointerTosgs__destroyResponse(soap, NULL, NULL, "sgs:destroyResponse");
	case SOAP_TYPE_PointerTosgs__findServiceDataResponse:
		return soap_in_PointerTosgs__findServiceDataResponse(soap, NULL, NULL, "sgs:findServiceDataResponse");
	case SOAP_TYPE_PointerTosgs__GetNthDataSourceResponse:
		return soap_in_PointerTosgs__GetNthDataSourceResponse(soap, NULL, NULL, "sgs:GetNthDataSourceResponse");
	case SOAP_TYPE_PointerTosgs__RestartResponse:
		return soap_in_PointerTosgs__RestartResponse(soap, NULL, NULL, "sgs:RestartResponse");
	case SOAP_TYPE_PointerTosgs__PutControlResponse:
		return soap_in_PointerTosgs__PutControlResponse(soap, NULL, NULL, "sgs:PutControlResponse");
	case SOAP_TYPE_PointerTosgs__PauseResponse:
		return soap_in_PointerTosgs__PauseResponse(soap, NULL, NULL, "sgs:PauseResponse");
	case SOAP_TYPE_PointerTosgs__AppDetachResponse:
		return soap_in_PointerTosgs__AppDetachResponse(soap, NULL, NULL, "sgs:AppDetachResponse");
	case SOAP_TYPE_PointerTosgs__AppPutLogResponse:
		return soap_in_PointerTosgs__AppPutLogResponse(soap, NULL, NULL, "sgs:AppPutLogResponse");
	case SOAP_TYPE_PointerTosgs__setServiceDataResponse:
		return soap_in_PointerTosgs__setServiceDataResponse(soap, NULL, NULL, "sgs:setServiceDataResponse");
	case SOAP_TYPE_PointerTosgs__GetParamLogResponse:
		return soap_in_PointerTosgs__GetParamLogResponse(soap, NULL, NULL, "sgs:GetParamLogResponse");
	case SOAP_TYPE_PointerTosgs__AppStartResponse:
		return soap_in_PointerTosgs__AppStartResponse(soap, NULL, NULL, "sgs:AppStartResponse");
	case SOAP_TYPE_PointerTosgs__PutStatusResponse:
		return soap_in_PointerTosgs__PutStatusResponse(soap, NULL, NULL, "sgs:PutStatusResponse");
	case SOAP_TYPE_PointerTosgs__AppRecordChkpointResponse:
		return soap_in_PointerTosgs__AppRecordChkpointResponse(soap, NULL, NULL, "sgs:AppRecordChkpointResponse");
	case SOAP_TYPE_PointerTosgs__ResumeResponse:
		return soap_in_PointerTosgs__ResumeResponse(soap, NULL, NULL, "sgs:ResumeResponse");
	case SOAP_TYPE_PointerTosgs__DetachResponse:
		return soap_in_PointerTosgs__DetachResponse(soap, NULL, NULL, "sgs:DetachResponse");
	case SOAP_TYPE_PointerTosgs__ClearStatusMsgQueueResponse:
		return soap_in_PointerTosgs__ClearStatusMsgQueueResponse(soap, NULL, NULL, "sgs:ClearStatusMsgQueueResponse");
	case SOAP_TYPE_PointerTosgs__StopResponse:
		return soap_in_PointerTosgs__StopResponse(soap, NULL, NULL, "sgs:StopResponse");
	case SOAP_TYPE_PointerTosgs__GetStatusResponse:
		return soap_in_PointerTosgs__GetStatusResponse(soap, NULL, NULL, "sgs:GetStatusResponse");
	case SOAP_TYPE_PointerTosgs__AttachResponse:
		return soap_in_PointerTosgs__AttachResponse(soap, NULL, NULL, "sgs:AttachResponse");
	case SOAP_TYPE_PointerTowsrp__DestroyResponse:
		return soap_in_PointerTowsrp__DestroyResponse(soap, NULL, NULL, "wsrp:DestroyResponse");
	case SOAP_TYPE_PointerTosws__PutParamLogResponse:
		return soap_in_PointerTosws__PutParamLogResponse(soap, NULL, NULL, "sws:PutParamLogResponse");
	case SOAP_TYPE_PointerTosws__GetParamLogResponse:
		return soap_in_PointerTosws__GetParamLogResponse(soap, NULL, NULL, "sws:GetParamLogResponse");
	case SOAP_TYPE_PointerTosws__RecordCheckpointResponse:
		return soap_in_PointerTosws__RecordCheckpointResponse(soap, NULL, NULL, "sws:RecordCheckpointResponse");
	case SOAP_TYPE_PointerTosws__DetachResponse:
		return soap_in_PointerTosws__DetachResponse(soap, NULL, NULL, "sws:DetachResponse");
	case SOAP_TYPE_PointerTosws__AttachResponse:
		return soap_in_PointerTosws__AttachResponse(soap, NULL, NULL, "sws:AttachResponse");
	case SOAP_TYPE_PointerTosws__AddChildResponse:
		return soap_in_PointerTosws__AddChildResponse(soap, NULL, NULL, "sws:AddChildResponse");
	case SOAP_TYPE_PointerTowsrp__SetResourcePropertiesResponse:
		return soap_in_PointerTowsrp__SetResourcePropertiesResponse(soap, NULL, NULL, "wsrp:SetResourcePropertiesResponse");
	case SOAP_TYPE_PointerToGetResourcePropertyRequest:
		return soap_in_PointerToGetResourcePropertyRequest(soap, NULL, NULL, "GetResourcePropertyRequest");
	case SOAP_TYPE_PointerTowsrp__ResourcePropertyStruct:
		return soap_in_PointerTowsrp__ResourcePropertyStruct(soap, NULL, NULL, "wsrp:ResourcePropertyStruct");
	case SOAP_TYPE_PointerToCommand:
		return soap_in_PointerToCommand(soap, NULL, NULL, "Command");
	case SOAP_TYPE_xsd__string:
	{	char **s;
		s = soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_xsd__int;
			return soap_in_xsd__int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgt:addNode"))
		{	*type = SOAP_TYPE_rgt__addNode;
			return soap_in_rgt__addNode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgt:getParentNode"))
		{	*type = SOAP_TYPE_rgt__getParentNode;
			return soap_in_rgt__getParentNode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgt:getCheckPointData"))
		{	*type = SOAP_TYPE_rgt__getCheckPointData;
			return soap_in_rgt__getCheckPointData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgt:requestTerminationBefore"))
		{	*type = SOAP_TYPE_rgt__requestTerminationBefore;
			return soap_in_rgt__requestTerminationBefore(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgt:getSteeringCommands"))
		{	*type = SOAP_TYPE_rgt__getSteeringCommands;
			return soap_in_rgt__getSteeringCommands(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgt:destroy"))
		{	*type = SOAP_TYPE_rgt__destroy;
			return soap_in_rgt__destroy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgt:setCheckPointData"))
		{	*type = SOAP_TYPE_rgt__setCheckPointData;
			return soap_in_rgt__setCheckPointData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgt:findServiceData"))
		{	*type = SOAP_TYPE_rgt__findServiceData;
			return soap_in_rgt__findServiceData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgt:getInputFile"))
		{	*type = SOAP_TYPE_rgt__getInputFile;
			return soap_in_rgt__getInputFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgt:getChildNodes"))
		{	*type = SOAP_TYPE_rgt__getChildNodes;
			return soap_in_rgt__getChildNodes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgt:requestTerminationAfter"))
		{	*type = SOAP_TYPE_rgt__requestTerminationAfter;
			return soap_in_rgt__requestTerminationAfter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgt:destroyResponse"))
		{	*type = SOAP_TYPE_rgt__destroyResponse;
			return soap_in_rgt__destroyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgt:getInputFileResponse"))
		{	*type = SOAP_TYPE_rgt__getInputFileResponse;
			return soap_in_rgt__getInputFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgt:getSteeringCommandsResponse"))
		{	*type = SOAP_TYPE_rgt__getSteeringCommandsResponse;
			return soap_in_rgt__getSteeringCommandsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgt:requestTerminationBeforeResponse"))
		{	*type = SOAP_TYPE_rgt__requestTerminationBeforeResponse;
			return soap_in_rgt__requestTerminationBeforeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgt:getChildNodesResponse"))
		{	*type = SOAP_TYPE_rgt__getChildNodesResponse;
			return soap_in_rgt__getChildNodesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgt:setCheckPointDataResponse"))
		{	*type = SOAP_TYPE_rgt__setCheckPointDataResponse;
			return soap_in_rgt__setCheckPointDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgt:findServiceDataResponse"))
		{	*type = SOAP_TYPE_rgt__findServiceDataResponse;
			return soap_in_rgt__findServiceDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgt:getCheckPointDataResponse"))
		{	*type = SOAP_TYPE_rgt__getCheckPointDataResponse;
			return soap_in_rgt__getCheckPointDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgt:addNodeResponse"))
		{	*type = SOAP_TYPE_rgt__addNodeResponse;
			return soap_in_rgt__addNodeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgt:requestTerminationAfterResponse"))
		{	*type = SOAP_TYPE_rgt__requestTerminationAfterResponse;
			return soap_in_rgt__requestTerminationAfterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgt:getParentNodeResponse"))
		{	*type = SOAP_TYPE_rgt__getParentNodeResponse;
			return soap_in_rgt__getParentNodeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgtf:requestTerminationAfter"))
		{	*type = SOAP_TYPE_rgtf__requestTerminationAfter;
			return soap_in_rgtf__requestTerminationAfter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgtf:requestTerminationBefore"))
		{	*type = SOAP_TYPE_rgtf__requestTerminationBefore;
			return soap_in_rgtf__requestTerminationBefore(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgtf:getActiveTrees"))
		{	*type = SOAP_TYPE_rgtf__getActiveTrees;
			return soap_in_rgtf__getActiveTrees(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgtf:findServiceData"))
		{	*type = SOAP_TYPE_rgtf__findServiceData;
			return soap_in_rgtf__findServiceData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgtf:destroy"))
		{	*type = SOAP_TYPE_rgtf__destroy;
			return soap_in_rgtf__destroy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgtf:findByHandle"))
		{	*type = SOAP_TYPE_rgtf__findByHandle;
			return soap_in_rgtf__findByHandle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgtf:createNewTree"))
		{	*type = SOAP_TYPE_rgtf__createNewTree;
			return soap_in_rgtf__createNewTree(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgtf:destroyResponse"))
		{	*type = SOAP_TYPE_rgtf__destroyResponse;
			return soap_in_rgtf__destroyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgtf:requestTerminationAfterResponse"))
		{	*type = SOAP_TYPE_rgtf__requestTerminationAfterResponse;
			return soap_in_rgtf__requestTerminationAfterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgtf:createNewTreeResponse"))
		{	*type = SOAP_TYPE_rgtf__createNewTreeResponse;
			return soap_in_rgtf__createNewTreeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgtf:getActiveTreesResponse"))
		{	*type = SOAP_TYPE_rgtf__getActiveTreesResponse;
			return soap_in_rgtf__getActiveTreesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgtf:findByHandleResponse"))
		{	*type = SOAP_TYPE_rgtf__findByHandleResponse;
			return soap_in_rgtf__findByHandleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgtf:findServiceDataResponse"))
		{	*type = SOAP_TYPE_rgtf__findServiceDataResponse;
			return soap_in_rgtf__findServiceDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rgtf:requestTerminationBeforeResponse"))
		{	*type = SOAP_TYPE_rgtf__requestTerminationBeforeResponse;
			return soap_in_rgtf__requestTerminationBeforeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgr:findServiceData"))
		{	*type = SOAP_TYPE_sgr__findServiceData;
			return soap_in_sgr__findServiceData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgr:add"))
		{	*type = SOAP_TYPE_sgr__add;
			return soap_in_sgr__add(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgr:remove"))
		{	*type = SOAP_TYPE_sgr__remove;
			return soap_in_sgr__remove(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgr:removeResponse"))
		{	*type = SOAP_TYPE_sgr__removeResponse;
			return soap_in_sgr__removeResponse(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_ArrayOf_USCORE_xsd_USCORE_string;
			return soap_in_ArrayOf_USCORE_xsd_USCORE_string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgr:addResponse"))
		{	*type = SOAP_TYPE_sgr__addResponse;
			return soap_in_sgr__addResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgr:findServiceDataResponse"))
		{	*type = SOAP_TYPE_sgr__findServiceDataResponse;
			return soap_in_sgr__findServiceDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swsf:createSWSResource"))
		{	*type = SOAP_TYPE_swsf__createSWSResource;
			return soap_in_swsf__createSWSResource(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swsf:createSWSResourceResponse"))
		{	*type = SOAP_TYPE_swsf__createSWSResourceResponse;
			return soap_in_swsf__createSWSResourceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "epr"))
		{	*type = SOAP_TYPE_epr;
			return soap_in_epr(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgsf:createService"))
		{	*type = SOAP_TYPE_sgsf__createService;
			return soap_in_sgsf__createService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgsf:destroy"))
		{	*type = SOAP_TYPE_sgsf__destroy;
			return soap_in_sgsf__destroy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgsf:registerSelf"))
		{	*type = SOAP_TYPE_sgsf__registerSelf;
			return soap_in_sgsf__registerSelf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgsf:registerSelfResponse"))
		{	*type = SOAP_TYPE_sgsf__registerSelfResponse;
			return soap_in_sgsf__registerSelfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgsf:destroyResponse"))
		{	*type = SOAP_TYPE_sgsf__destroyResponse;
			return soap_in_sgsf__destroyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgsf:createServiceResponse"))
		{	*type = SOAP_TYPE_sgsf__createServiceResponse;
			return soap_in_sgsf__createServiceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:AppStop"))
		{	*type = SOAP_TYPE_sgs__AppStop;
			return soap_in_sgs__AppStop(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:GetNotifications"))
		{	*type = SOAP_TYPE_sgs__GetNotifications;
			return soap_in_sgs__GetNotifications(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:GetControl"))
		{	*type = SOAP_TYPE_sgs__GetControl;
			return soap_in_sgs__GetControl(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:destroy"))
		{	*type = SOAP_TYPE_sgs__destroy;
			return soap_in_sgs__destroy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:findServiceData"))
		{	*type = SOAP_TYPE_sgs__findServiceData;
			return soap_in_sgs__findServiceData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:GetNthDataSource"))
		{	*type = SOAP_TYPE_sgs__GetNthDataSource;
			return soap_in_sgs__GetNthDataSource(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:Restart"))
		{	*type = SOAP_TYPE_sgs__Restart;
			return soap_in_sgs__Restart(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:PutControl"))
		{	*type = SOAP_TYPE_sgs__PutControl;
			return soap_in_sgs__PutControl(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:Pause"))
		{	*type = SOAP_TYPE_sgs__Pause;
			return soap_in_sgs__Pause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:AppDetach"))
		{	*type = SOAP_TYPE_sgs__AppDetach;
			return soap_in_sgs__AppDetach(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:AppPutLog"))
		{	*type = SOAP_TYPE_sgs__AppPutLog;
			return soap_in_sgs__AppPutLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:setServiceData"))
		{	*type = SOAP_TYPE_sgs__setServiceData;
			return soap_in_sgs__setServiceData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:GetParamLog"))
		{	*type = SOAP_TYPE_sgs__GetParamLog;
			return soap_in_sgs__GetParamLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:AppStart"))
		{	*type = SOAP_TYPE_sgs__AppStart;
			return soap_in_sgs__AppStart(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:PutStatus"))
		{	*type = SOAP_TYPE_sgs__PutStatus;
			return soap_in_sgs__PutStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:AppRecordChkpoint"))
		{	*type = SOAP_TYPE_sgs__AppRecordChkpoint;
			return soap_in_sgs__AppRecordChkpoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:Resume"))
		{	*type = SOAP_TYPE_sgs__Resume;
			return soap_in_sgs__Resume(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:Detach"))
		{	*type = SOAP_TYPE_sgs__Detach;
			return soap_in_sgs__Detach(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:ClearStatusMsgQueue"))
		{	*type = SOAP_TYPE_sgs__ClearStatusMsgQueue;
			return soap_in_sgs__ClearStatusMsgQueue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:Stop"))
		{	*type = SOAP_TYPE_sgs__Stop;
			return soap_in_sgs__Stop(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:GetStatus"))
		{	*type = SOAP_TYPE_sgs__GetStatus;
			return soap_in_sgs__GetStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:Attach"))
		{	*type = SOAP_TYPE_sgs__Attach;
			return soap_in_sgs__Attach(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:AppDetachResponse"))
		{	*type = SOAP_TYPE_sgs__AppDetachResponse;
			return soap_in_sgs__AppDetachResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:AppStartResponse"))
		{	*type = SOAP_TYPE_sgs__AppStartResponse;
			return soap_in_sgs__AppStartResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:GetNthDataSourceResponse"))
		{	*type = SOAP_TYPE_sgs__GetNthDataSourceResponse;
			return soap_in_sgs__GetNthDataSourceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:AppPutLogResponse"))
		{	*type = SOAP_TYPE_sgs__AppPutLogResponse;
			return soap_in_sgs__AppPutLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:ClearStatusMsgQueueResponse"))
		{	*type = SOAP_TYPE_sgs__ClearStatusMsgQueueResponse;
			return soap_in_sgs__ClearStatusMsgQueueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:destroyResponse"))
		{	*type = SOAP_TYPE_sgs__destroyResponse;
			return soap_in_sgs__destroyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:AppStopResponse"))
		{	*type = SOAP_TYPE_sgs__AppStopResponse;
			return soap_in_sgs__AppStopResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:GetStatusResponse"))
		{	*type = SOAP_TYPE_sgs__GetStatusResponse;
			return soap_in_sgs__GetStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:GetControlResponse"))
		{	*type = SOAP_TYPE_sgs__GetControlResponse;
			return soap_in_sgs__GetControlResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:StopResponse"))
		{	*type = SOAP_TYPE_sgs__StopResponse;
			return soap_in_sgs__StopResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:GetNotificationsResponse"))
		{	*type = SOAP_TYPE_sgs__GetNotificationsResponse;
			return soap_in_sgs__GetNotificationsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:AttachResponse"))
		{	*type = SOAP_TYPE_sgs__AttachResponse;
			return soap_in_sgs__AttachResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:ResumeResponse"))
		{	*type = SOAP_TYPE_sgs__ResumeResponse;
			return soap_in_sgs__ResumeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:PutControlResponse"))
		{	*type = SOAP_TYPE_sgs__PutControlResponse;
			return soap_in_sgs__PutControlResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:RestartResponse"))
		{	*type = SOAP_TYPE_sgs__RestartResponse;
			return soap_in_sgs__RestartResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:findServiceDataResponse"))
		{	*type = SOAP_TYPE_sgs__findServiceDataResponse;
			return soap_in_sgs__findServiceDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:PauseResponse"))
		{	*type = SOAP_TYPE_sgs__PauseResponse;
			return soap_in_sgs__PauseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:setServiceDataResponse"))
		{	*type = SOAP_TYPE_sgs__setServiceDataResponse;
			return soap_in_sgs__setServiceDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:PutStatusResponse"))
		{	*type = SOAP_TYPE_sgs__PutStatusResponse;
			return soap_in_sgs__PutStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:AppRecordChkpointResponse"))
		{	*type = SOAP_TYPE_sgs__AppRecordChkpointResponse;
			return soap_in_sgs__AppRecordChkpointResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:DetachResponse"))
		{	*type = SOAP_TYPE_sgs__DetachResponse;
			return soap_in_sgs__DetachResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sgs:GetParamLogResponse"))
		{	*type = SOAP_TYPE_sgs__GetParamLogResponse;
			return soap_in_sgs__GetParamLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:Destroy"))
		{	*type = SOAP_TYPE_wsrp__Destroy;
			return soap_in_wsrp__Destroy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:PutParamLog"))
		{	*type = SOAP_TYPE_sws__PutParamLog;
			return soap_in_sws__PutParamLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:GetParamLog"))
		{	*type = SOAP_TYPE_sws__GetParamLog;
			return soap_in_sws__GetParamLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:RecordCheckpoint"))
		{	*type = SOAP_TYPE_sws__RecordCheckpoint;
			return soap_in_sws__RecordCheckpoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:Detach"))
		{	*type = SOAP_TYPE_sws__Detach;
			return soap_in_sws__Detach(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:Attach"))
		{	*type = SOAP_TYPE_sws__Attach;
			return soap_in_sws__Attach(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:AddChild"))
		{	*type = SOAP_TYPE_sws__AddChild;
			return soap_in_sws__AddChild(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:GetResourcePropertyDocument"))
		{	*type = SOAP_TYPE_wsrp__GetResourcePropertyDocument;
			return soap_in_wsrp__GetResourcePropertyDocument(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:SetResourceProperties"))
		{	*type = SOAP_TYPE_wsrp__SetResourceProperties;
			return soap_in_wsrp__SetResourceProperties(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:GetMultipleResourceProperties"))
		{	*type = SOAP_TYPE_wsrp__GetMultipleResourceProperties;
			return soap_in_wsrp__GetMultipleResourceProperties(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:GetResourceProperty"))
		{	*type = SOAP_TYPE_wsrp__GetResourceProperty;
			return soap_in_wsrp__GetResourceProperty(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:DetachResponse"))
		{	*type = SOAP_TYPE_sws__DetachResponse;
			return soap_in_sws__DetachResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:AddChildResponse"))
		{	*type = SOAP_TYPE_sws__AddChildResponse;
			return soap_in_sws__AddChildResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:AddChildRequest"))
		{	*type = SOAP_TYPE_sws__AddChildRequest;
			return soap_in_sws__AddChildRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:SetResourcePropertiesResponse"))
		{	*type = SOAP_TYPE_wsrp__SetResourcePropertiesResponse;
			return soap_in_wsrp__SetResourcePropertiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:GetMultipleResourcePropertiesRequest"))
		{	*type = SOAP_TYPE_wsrp__GetMultipleResourcePropertiesRequest;
			return soap_in_wsrp__GetMultipleResourcePropertiesRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:ResourcePropertyStruct"))
		{	*type = SOAP_TYPE_wsrp__ResourcePropertyStruct;
			return soap_in_wsrp__ResourcePropertyStruct(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:GetResourcePropertyResponse"))
		{	*type = SOAP_TYPE_wsrp__GetResourcePropertyResponse;
			return soap_in_wsrp__GetResourcePropertyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "GetResourcePropertyRequest"))
		{	*type = SOAP_TYPE_GetResourcePropertyRequest;
			return soap_in_GetResourcePropertyRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:PutParamLogResponse"))
		{	*type = SOAP_TYPE_sws__PutParamLogResponse;
			return soap_in_sws__PutParamLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:DestroyResponse"))
		{	*type = SOAP_TYPE_wsrp__DestroyResponse;
			return soap_in_wsrp__DestroyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:AttachResponse"))
		{	*type = SOAP_TYPE_sws__AttachResponse;
			return soap_in_sws__AttachResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "steerMessage"))
		{	*type = SOAP_TYPE_steerMessage;
			return soap_in_steerMessage(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "Command"))
		{	*type = SOAP_TYPE_supp_cmds;
			return soap_in_supp_cmds(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Command"))
		{	*type = SOAP_TYPE_Command;
			return soap_in_Command(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:RecordCheckpointResponse"))
		{	*type = SOAP_TYPE_sws__RecordCheckpointResponse;
			return soap_in_sws__RecordCheckpointResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sws:GetParamLogResponse"))
		{	*type = SOAP_TYPE_sws__GetParamLogResponse;
			return soap_in_sws__GetParamLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_xsd__string;
			s = soap_in_xsd__string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
			return soap->error = SOAP_TAG_MISMATCH;
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_xsd__int:
		return soap_out_xsd__int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_rgt__addNode:
		return soap_out_rgt__addNode(soap, tag, id, (const struct rgt__addNode *)ptr, "rgt:addNode");
	case SOAP_TYPE_rgt__getParentNode:
		return soap_out_rgt__getParentNode(soap, tag, id, (const struct rgt__getParentNode *)ptr, "rgt:getParentNode");
	case SOAP_TYPE_rgt__getCheckPointData:
		return soap_out_rgt__getCheckPointData(soap, tag, id, (const struct rgt__getCheckPointData *)ptr, "rgt:getCheckPointData");
	case SOAP_TYPE_rgt__requestTerminationBefore:
		return soap_out_rgt__requestTerminationBefore(soap, tag, id, (const struct rgt__requestTerminationBefore *)ptr, "rgt:requestTerminationBefore");
	case SOAP_TYPE_rgt__getSteeringCommands:
		return soap_out_rgt__getSteeringCommands(soap, tag, id, (const struct rgt__getSteeringCommands *)ptr, "rgt:getSteeringCommands");
	case SOAP_TYPE_rgt__destroy:
		return soap_out_rgt__destroy(soap, tag, id, (const struct rgt__destroy *)ptr, "rgt:destroy");
	case SOAP_TYPE_rgt__setCheckPointData:
		return soap_out_rgt__setCheckPointData(soap, tag, id, (const struct rgt__setCheckPointData *)ptr, "rgt:setCheckPointData");
	case SOAP_TYPE_rgt__findServiceData:
		return soap_out_rgt__findServiceData(soap, tag, id, (const struct rgt__findServiceData *)ptr, "rgt:findServiceData");
	case SOAP_TYPE_rgt__getInputFile:
		return soap_out_rgt__getInputFile(soap, tag, id, (const struct rgt__getInputFile *)ptr, "rgt:getInputFile");
	case SOAP_TYPE_rgt__getChildNodes:
		return soap_out_rgt__getChildNodes(soap, tag, id, (const struct rgt__getChildNodes *)ptr, "rgt:getChildNodes");
	case SOAP_TYPE_rgt__requestTerminationAfter:
		return soap_out_rgt__requestTerminationAfter(soap, tag, id, (const struct rgt__requestTerminationAfter *)ptr, "rgt:requestTerminationAfter");
	case SOAP_TYPE_rgt__destroyResponse:
		return soap_out_rgt__destroyResponse(soap, tag, id, (const struct rgt__destroyResponse *)ptr, "rgt:destroyResponse");
	case SOAP_TYPE_rgt__getInputFileResponse:
		return soap_out_rgt__getInputFileResponse(soap, tag, id, (const struct rgt__getInputFileResponse *)ptr, "rgt:getInputFileResponse");
	case SOAP_TYPE_rgt__getSteeringCommandsResponse:
		return soap_out_rgt__getSteeringCommandsResponse(soap, tag, id, (const struct rgt__getSteeringCommandsResponse *)ptr, "rgt:getSteeringCommandsResponse");
	case SOAP_TYPE_rgt__requestTerminationBeforeResponse:
		return soap_out_rgt__requestTerminationBeforeResponse(soap, tag, id, (const struct rgt__requestTerminationBeforeResponse *)ptr, "rgt:requestTerminationBeforeResponse");
	case SOAP_TYPE_rgt__getChildNodesResponse:
		return soap_out_rgt__getChildNodesResponse(soap, tag, id, (const struct rgt__getChildNodesResponse *)ptr, "rgt:getChildNodesResponse");
	case SOAP_TYPE_rgt__setCheckPointDataResponse:
		return soap_out_rgt__setCheckPointDataResponse(soap, tag, id, (const struct rgt__setCheckPointDataResponse *)ptr, "rgt:setCheckPointDataResponse");
	case SOAP_TYPE_rgt__findServiceDataResponse:
		return soap_out_rgt__findServiceDataResponse(soap, tag, id, (const struct rgt__findServiceDataResponse *)ptr, "rgt:findServiceDataResponse");
	case SOAP_TYPE_rgt__getCheckPointDataResponse:
		return soap_out_rgt__getCheckPointDataResponse(soap, tag, id, (const struct rgt__getCheckPointDataResponse *)ptr, "rgt:getCheckPointDataResponse");
	case SOAP_TYPE_rgt__addNodeResponse:
		return soap_out_rgt__addNodeResponse(soap, tag, id, (const struct rgt__addNodeResponse *)ptr, "rgt:addNodeResponse");
	case SOAP_TYPE_rgt__requestTerminationAfterResponse:
		return soap_out_rgt__requestTerminationAfterResponse(soap, tag, id, (const struct rgt__requestTerminationAfterResponse *)ptr, "rgt:requestTerminationAfterResponse");
	case SOAP_TYPE_rgt__getParentNodeResponse:
		return soap_out_rgt__getParentNodeResponse(soap, tag, id, (const struct rgt__getParentNodeResponse *)ptr, "rgt:getParentNodeResponse");
	case SOAP_TYPE_rgtf__requestTerminationAfter:
		return soap_out_rgtf__requestTerminationAfter(soap, tag, id, (const struct rgtf__requestTerminationAfter *)ptr, "rgtf:requestTerminationAfter");
	case SOAP_TYPE_rgtf__requestTerminationBefore:
		return soap_out_rgtf__requestTerminationBefore(soap, tag, id, (const struct rgtf__requestTerminationBefore *)ptr, "rgtf:requestTerminationBefore");
	case SOAP_TYPE_rgtf__getActiveTrees:
		return soap_out_rgtf__getActiveTrees(soap, tag, id, (const struct rgtf__getActiveTrees *)ptr, "rgtf:getActiveTrees");
	case SOAP_TYPE_rgtf__findServiceData:
		return soap_out_rgtf__findServiceData(soap, tag, id, (const struct rgtf__findServiceData *)ptr, "rgtf:findServiceData");
	case SOAP_TYPE_rgtf__destroy:
		return soap_out_rgtf__destroy(soap, tag, id, (const struct rgtf__destroy *)ptr, "rgtf:destroy");
	case SOAP_TYPE_rgtf__findByHandle:
		return soap_out_rgtf__findByHandle(soap, tag, id, (const struct rgtf__findByHandle *)ptr, "rgtf:findByHandle");
	case SOAP_TYPE_rgtf__createNewTree:
		return soap_out_rgtf__createNewTree(soap, tag, id, (const struct rgtf__createNewTree *)ptr, "rgtf:createNewTree");
	case SOAP_TYPE_rgtf__destroyResponse:
		return soap_out_rgtf__destroyResponse(soap, tag, id, (const struct rgtf__destroyResponse *)ptr, "rgtf:destroyResponse");
	case SOAP_TYPE_rgtf__requestTerminationAfterResponse:
		return soap_out_rgtf__requestTerminationAfterResponse(soap, tag, id, (const struct rgtf__requestTerminationAfterResponse *)ptr, "rgtf:requestTerminationAfterResponse");
	case SOAP_TYPE_rgtf__createNewTreeResponse:
		return soap_out_rgtf__createNewTreeResponse(soap, tag, id, (const struct rgtf__createNewTreeResponse *)ptr, "rgtf:createNewTreeResponse");
	case SOAP_TYPE_rgtf__getActiveTreesResponse:
		return soap_out_rgtf__getActiveTreesResponse(soap, tag, id, (const struct rgtf__getActiveTreesResponse *)ptr, "rgtf:getActiveTreesResponse");
	case SOAP_TYPE_rgtf__findByHandleResponse:
		return soap_out_rgtf__findByHandleResponse(soap, tag, id, (const struct rgtf__findByHandleResponse *)ptr, "rgtf:findByHandleResponse");
	case SOAP_TYPE_rgtf__findServiceDataResponse:
		return soap_out_rgtf__findServiceDataResponse(soap, tag, id, (const struct rgtf__findServiceDataResponse *)ptr, "rgtf:findServiceDataResponse");
	case SOAP_TYPE_rgtf__requestTerminationBeforeResponse:
		return soap_out_rgtf__requestTerminationBeforeResponse(soap, tag, id, (const struct rgtf__requestTerminationBeforeResponse *)ptr, "rgtf:requestTerminationBeforeResponse");
	case SOAP_TYPE_sgr__findServiceData:
		return soap_out_sgr__findServiceData(soap, tag, id, (const struct sgr__findServiceData *)ptr, "sgr:findServiceData");
	case SOAP_TYPE_sgr__add:
		return soap_out_sgr__add(soap, tag, id, (const struct sgr__add *)ptr, "sgr:add");
	case SOAP_TYPE_sgr__remove:
		return soap_out_sgr__remove(soap, tag, id, (const struct sgr__remove *)ptr, "sgr:remove");
	case SOAP_TYPE_sgr__removeResponse:
		return soap_out_sgr__removeResponse(soap, tag, id, (const struct sgr__removeResponse *)ptr, "sgr:removeResponse");
	case SOAP_TYPE_ArrayOf_USCORE_xsd_USCORE_string:
		return soap_out_ArrayOf_USCORE_xsd_USCORE_string(soap, tag, id, (const struct ArrayOf_USCORE_xsd_USCORE_string *)ptr, "xsd:string");
	case SOAP_TYPE_sgr__addResponse:
		return soap_out_sgr__addResponse(soap, tag, id, (const struct sgr__addResponse *)ptr, "sgr:addResponse");
	case SOAP_TYPE_sgr__findServiceDataResponse:
		return soap_out_sgr__findServiceDataResponse(soap, tag, id, (const struct sgr__findServiceDataResponse *)ptr, "sgr:findServiceDataResponse");
	case SOAP_TYPE_swsf__createSWSResource:
		return soap_out_swsf__createSWSResource(soap, tag, id, (const struct swsf__createSWSResource *)ptr, "swsf:createSWSResource");
	case SOAP_TYPE_swsf__createSWSResourceResponse:
		return soap_out_swsf__createSWSResourceResponse(soap, tag, id, (const struct swsf__createSWSResourceResponse *)ptr, "swsf:createSWSResourceResponse");
	case SOAP_TYPE_epr:
		return soap_out_epr(soap, tag, id, (const struct epr *)ptr, "epr");
	case SOAP_TYPE_sgsf__createService:
		return soap_out_sgsf__createService(soap, tag, id, (const struct sgsf__createService *)ptr, "sgsf:createService");
	case SOAP_TYPE_sgsf__destroy:
		return soap_out_sgsf__destroy(soap, tag, id, (const struct sgsf__destroy *)ptr, "sgsf:destroy");
	case SOAP_TYPE_sgsf__registerSelf:
		return soap_out_sgsf__registerSelf(soap, tag, id, (const struct sgsf__registerSelf *)ptr, "sgsf:registerSelf");
	case SOAP_TYPE_sgsf__registerSelfResponse:
		return soap_out_sgsf__registerSelfResponse(soap, tag, id, (const struct sgsf__registerSelfResponse *)ptr, "sgsf:registerSelfResponse");
	case SOAP_TYPE_sgsf__destroyResponse:
		return soap_out_sgsf__destroyResponse(soap, tag, id, (const struct sgsf__destroyResponse *)ptr, "sgsf:destroyResponse");
	case SOAP_TYPE_sgsf__createServiceResponse:
		return soap_out_sgsf__createServiceResponse(soap, tag, id, (const struct sgsf__createServiceResponse *)ptr, "sgsf:createServiceResponse");
	case SOAP_TYPE_sgs__AppStop:
		return soap_out_sgs__AppStop(soap, tag, id, (const struct sgs__AppStop *)ptr, "sgs:AppStop");
	case SOAP_TYPE_sgs__GetNotifications:
		return soap_out_sgs__GetNotifications(soap, tag, id, (const struct sgs__GetNotifications *)ptr, "sgs:GetNotifications");
	case SOAP_TYPE_sgs__GetControl:
		return soap_out_sgs__GetControl(soap, tag, id, (const struct sgs__GetControl *)ptr, "sgs:GetControl");
	case SOAP_TYPE_sgs__destroy:
		return soap_out_sgs__destroy(soap, tag, id, (const struct sgs__destroy *)ptr, "sgs:destroy");
	case SOAP_TYPE_sgs__findServiceData:
		return soap_out_sgs__findServiceData(soap, tag, id, (const struct sgs__findServiceData *)ptr, "sgs:findServiceData");
	case SOAP_TYPE_sgs__GetNthDataSource:
		return soap_out_sgs__GetNthDataSource(soap, tag, id, (const struct sgs__GetNthDataSource *)ptr, "sgs:GetNthDataSource");
	case SOAP_TYPE_sgs__Restart:
		return soap_out_sgs__Restart(soap, tag, id, (const struct sgs__Restart *)ptr, "sgs:Restart");
	case SOAP_TYPE_sgs__PutControl:
		return soap_out_sgs__PutControl(soap, tag, id, (const struct sgs__PutControl *)ptr, "sgs:PutControl");
	case SOAP_TYPE_sgs__Pause:
		return soap_out_sgs__Pause(soap, tag, id, (const struct sgs__Pause *)ptr, "sgs:Pause");
	case SOAP_TYPE_sgs__AppDetach:
		return soap_out_sgs__AppDetach(soap, tag, id, (const struct sgs__AppDetach *)ptr, "sgs:AppDetach");
	case SOAP_TYPE_sgs__AppPutLog:
		return soap_out_sgs__AppPutLog(soap, tag, id, (const struct sgs__AppPutLog *)ptr, "sgs:AppPutLog");
	case SOAP_TYPE_sgs__setServiceData:
		return soap_out_sgs__setServiceData(soap, tag, id, (const struct sgs__setServiceData *)ptr, "sgs:setServiceData");
	case SOAP_TYPE_sgs__GetParamLog:
		return soap_out_sgs__GetParamLog(soap, tag, id, (const struct sgs__GetParamLog *)ptr, "sgs:GetParamLog");
	case SOAP_TYPE_sgs__AppStart:
		return soap_out_sgs__AppStart(soap, tag, id, (const struct sgs__AppStart *)ptr, "sgs:AppStart");
	case SOAP_TYPE_sgs__PutStatus:
		return soap_out_sgs__PutStatus(soap, tag, id, (const struct sgs__PutStatus *)ptr, "sgs:PutStatus");
	case SOAP_TYPE_sgs__AppRecordChkpoint:
		return soap_out_sgs__AppRecordChkpoint(soap, tag, id, (const struct sgs__AppRecordChkpoint *)ptr, "sgs:AppRecordChkpoint");
	case SOAP_TYPE_sgs__Resume:
		return soap_out_sgs__Resume(soap, tag, id, (const struct sgs__Resume *)ptr, "sgs:Resume");
	case SOAP_TYPE_sgs__Detach:
		return soap_out_sgs__Detach(soap, tag, id, (const struct sgs__Detach *)ptr, "sgs:Detach");
	case SOAP_TYPE_sgs__ClearStatusMsgQueue:
		return soap_out_sgs__ClearStatusMsgQueue(soap, tag, id, (const struct sgs__ClearStatusMsgQueue *)ptr, "sgs:ClearStatusMsgQueue");
	case SOAP_TYPE_sgs__Stop:
		return soap_out_sgs__Stop(soap, tag, id, (const struct sgs__Stop *)ptr, "sgs:Stop");
	case SOAP_TYPE_sgs__GetStatus:
		return soap_out_sgs__GetStatus(soap, tag, id, (const struct sgs__GetStatus *)ptr, "sgs:GetStatus");
	case SOAP_TYPE_sgs__Attach:
		return soap_out_sgs__Attach(soap, tag, id, (const struct sgs__Attach *)ptr, "sgs:Attach");
	case SOAP_TYPE_sgs__AppDetachResponse:
		return soap_out_sgs__AppDetachResponse(soap, tag, id, (const struct sgs__AppDetachResponse *)ptr, "sgs:AppDetachResponse");
	case SOAP_TYPE_sgs__AppStartResponse:
		return soap_out_sgs__AppStartResponse(soap, tag, id, (const struct sgs__AppStartResponse *)ptr, "sgs:AppStartResponse");
	case SOAP_TYPE_sgs__GetNthDataSourceResponse:
		return soap_out_sgs__GetNthDataSourceResponse(soap, tag, id, (const struct sgs__GetNthDataSourceResponse *)ptr, "sgs:GetNthDataSourceResponse");
	case SOAP_TYPE_sgs__AppPutLogResponse:
		return soap_out_sgs__AppPutLogResponse(soap, tag, id, (const struct sgs__AppPutLogResponse *)ptr, "sgs:AppPutLogResponse");
	case SOAP_TYPE_sgs__ClearStatusMsgQueueResponse:
		return soap_out_sgs__ClearStatusMsgQueueResponse(soap, tag, id, (const struct sgs__ClearStatusMsgQueueResponse *)ptr, "sgs:ClearStatusMsgQueueResponse");
	case SOAP_TYPE_sgs__destroyResponse:
		return soap_out_sgs__destroyResponse(soap, tag, id, (const struct sgs__destroyResponse *)ptr, "sgs:destroyResponse");
	case SOAP_TYPE_sgs__AppStopResponse:
		return soap_out_sgs__AppStopResponse(soap, tag, id, (const struct sgs__AppStopResponse *)ptr, "sgs:AppStopResponse");
	case SOAP_TYPE_sgs__GetStatusResponse:
		return soap_out_sgs__GetStatusResponse(soap, tag, id, (const struct sgs__GetStatusResponse *)ptr, "sgs:GetStatusResponse");
	case SOAP_TYPE_sgs__GetControlResponse:
		return soap_out_sgs__GetControlResponse(soap, tag, id, (const struct sgs__GetControlResponse *)ptr, "sgs:GetControlResponse");
	case SOAP_TYPE_sgs__StopResponse:
		return soap_out_sgs__StopResponse(soap, tag, id, (const struct sgs__StopResponse *)ptr, "sgs:StopResponse");
	case SOAP_TYPE_sgs__GetNotificationsResponse:
		return soap_out_sgs__GetNotificationsResponse(soap, tag, id, (const struct sgs__GetNotificationsResponse *)ptr, "sgs:GetNotificationsResponse");
	case SOAP_TYPE_sgs__AttachResponse:
		return soap_out_sgs__AttachResponse(soap, tag, id, (const struct sgs__AttachResponse *)ptr, "sgs:AttachResponse");
	case SOAP_TYPE_sgs__ResumeResponse:
		return soap_out_sgs__ResumeResponse(soap, tag, id, (const struct sgs__ResumeResponse *)ptr, "sgs:ResumeResponse");
	case SOAP_TYPE_sgs__PutControlResponse:
		return soap_out_sgs__PutControlResponse(soap, tag, id, (const struct sgs__PutControlResponse *)ptr, "sgs:PutControlResponse");
	case SOAP_TYPE_sgs__RestartResponse:
		return soap_out_sgs__RestartResponse(soap, tag, id, (const struct sgs__RestartResponse *)ptr, "sgs:RestartResponse");
	case SOAP_TYPE_sgs__findServiceDataResponse:
		return soap_out_sgs__findServiceDataResponse(soap, tag, id, (const struct sgs__findServiceDataResponse *)ptr, "sgs:findServiceDataResponse");
	case SOAP_TYPE_sgs__PauseResponse:
		return soap_out_sgs__PauseResponse(soap, tag, id, (const struct sgs__PauseResponse *)ptr, "sgs:PauseResponse");
	case SOAP_TYPE_sgs__setServiceDataResponse:
		return soap_out_sgs__setServiceDataResponse(soap, tag, id, (const struct sgs__setServiceDataResponse *)ptr, "sgs:setServiceDataResponse");
	case SOAP_TYPE_sgs__PutStatusResponse:
		return soap_out_sgs__PutStatusResponse(soap, tag, id, (const struct sgs__PutStatusResponse *)ptr, "sgs:PutStatusResponse");
	case SOAP_TYPE_sgs__AppRecordChkpointResponse:
		return soap_out_sgs__AppRecordChkpointResponse(soap, tag, id, (const struct sgs__AppRecordChkpointResponse *)ptr, "sgs:AppRecordChkpointResponse");
	case SOAP_TYPE_sgs__DetachResponse:
		return soap_out_sgs__DetachResponse(soap, tag, id, (const struct sgs__DetachResponse *)ptr, "sgs:DetachResponse");
	case SOAP_TYPE_sgs__GetParamLogResponse:
		return soap_out_sgs__GetParamLogResponse(soap, tag, id, (const struct sgs__GetParamLogResponse *)ptr, "sgs:GetParamLogResponse");
	case SOAP_TYPE_wsrp__Destroy:
		return soap_out_wsrp__Destroy(soap, tag, id, (const struct wsrp__Destroy *)ptr, "wsrp:Destroy");
	case SOAP_TYPE_sws__PutParamLog:
		return soap_out_sws__PutParamLog(soap, tag, id, (const struct sws__PutParamLog *)ptr, "sws:PutParamLog");
	case SOAP_TYPE_sws__GetParamLog:
		return soap_out_sws__GetParamLog(soap, tag, id, (const struct sws__GetParamLog *)ptr, "sws:GetParamLog");
	case SOAP_TYPE_sws__RecordCheckpoint:
		return soap_out_sws__RecordCheckpoint(soap, tag, id, (const struct sws__RecordCheckpoint *)ptr, "sws:RecordCheckpoint");
	case SOAP_TYPE_sws__Detach:
		return soap_out_sws__Detach(soap, tag, id, (const struct sws__Detach *)ptr, "sws:Detach");
	case SOAP_TYPE_sws__Attach:
		return soap_out_sws__Attach(soap, tag, id, (const struct sws__Attach *)ptr, "sws:Attach");
	case SOAP_TYPE_sws__AddChild:
		return soap_out_sws__AddChild(soap, tag, id, (const struct sws__AddChild *)ptr, "sws:AddChild");
	case SOAP_TYPE_wsrp__GetResourcePropertyDocument:
		return soap_out_wsrp__GetResourcePropertyDocument(soap, tag, id, (const struct wsrp__GetResourcePropertyDocument *)ptr, "wsrp:GetResourcePropertyDocument");
	case SOAP_TYPE_wsrp__SetResourceProperties:
		return soap_out_wsrp__SetResourceProperties(soap, tag, id, (const struct wsrp__SetResourceProperties *)ptr, "wsrp:SetResourceProperties");
	case SOAP_TYPE_wsrp__GetMultipleResourceProperties:
		return soap_out_wsrp__GetMultipleResourceProperties(soap, tag, id, (const struct wsrp__GetMultipleResourceProperties *)ptr, "wsrp:GetMultipleResourceProperties");
	case SOAP_TYPE_wsrp__GetResourceProperty:
		return soap_out_wsrp__GetResourceProperty(soap, tag, id, (const struct wsrp__GetResourceProperty *)ptr, "wsrp:GetResourceProperty");
	case SOAP_TYPE_sws__DetachResponse:
		return soap_out_sws__DetachResponse(soap, tag, id, (const struct sws__DetachResponse *)ptr, "sws:DetachResponse");
	case SOAP_TYPE_sws__AddChildResponse:
		return soap_out_sws__AddChildResponse(soap, tag, id, (const struct sws__AddChildResponse *)ptr, "sws:AddChildResponse");
	case SOAP_TYPE_sws__AddChildRequest:
		return soap_out_sws__AddChildRequest(soap, tag, id, (const struct sws__AddChildRequest *)ptr, "sws:AddChildRequest");
	case SOAP_TYPE_wsrp__SetResourcePropertiesResponse:
		return soap_out_wsrp__SetResourcePropertiesResponse(soap, tag, id, (const struct wsrp__SetResourcePropertiesResponse *)ptr, "wsrp:SetResourcePropertiesResponse");
	case SOAP_TYPE_wsrp__GetMultipleResourcePropertiesRequest:
		return soap_out_wsrp__GetMultipleResourcePropertiesRequest(soap, tag, id, (const struct wsrp__GetMultipleResourcePropertiesRequest *)ptr, "wsrp:GetMultipleResourcePropertiesRequest");
	case SOAP_TYPE_wsrp__ResourcePropertyStruct:
		return soap_out_wsrp__ResourcePropertyStruct(soap, tag, id, (const struct wsrp__ResourcePropertyStruct *)ptr, "wsrp:ResourcePropertyStruct");
	case SOAP_TYPE_wsrp__GetResourcePropertyResponse:
		return soap_out_wsrp__GetResourcePropertyResponse(soap, tag, id, (const struct wsrp__GetResourcePropertyResponse *)ptr, "wsrp:GetResourcePropertyResponse");
	case SOAP_TYPE_GetResourcePropertyRequest:
		return soap_out_GetResourcePropertyRequest(soap, tag, id, (const struct GetResourcePropertyRequest *)ptr, "GetResourcePropertyRequest");
	case SOAP_TYPE_sws__PutParamLogResponse:
		return soap_out_sws__PutParamLogResponse(soap, tag, id, (const struct sws__PutParamLogResponse *)ptr, "sws:PutParamLogResponse");
	case SOAP_TYPE_wsrp__DestroyResponse:
		return soap_out_wsrp__DestroyResponse(soap, tag, id, (const struct wsrp__DestroyResponse *)ptr, "wsrp:DestroyResponse");
	case SOAP_TYPE_sws__AttachResponse:
		return soap_out_sws__AttachResponse(soap, tag, id, (const struct sws__AttachResponse *)ptr, "sws:AttachResponse");
	case SOAP_TYPE_steerMessage:
		return soap_out_steerMessage(soap, tag, id, (const struct steerMessage *)ptr, "steerMessage");
	case SOAP_TYPE_supp_cmds:
		return soap_out_supp_cmds(soap, tag, id, (const struct supp_cmds *)ptr, "Command");
	case SOAP_TYPE_Command:
		return soap_out_Command(soap, tag, id, (const struct Command *)ptr, "Command");
	case SOAP_TYPE_sws__RecordCheckpointResponse:
		return soap_out_sws__RecordCheckpointResponse(soap, tag, id, (const struct sws__RecordCheckpointResponse *)ptr, "sws:RecordCheckpointResponse");
	case SOAP_TYPE_sws__GetParamLogResponse:
		return soap_out_sws__GetParamLogResponse(soap, tag, id, (const struct sws__GetParamLogResponse *)ptr, "sws:GetParamLogResponse");
	case SOAP_TYPE_PointerTorgt__addNodeResponse:
		return soap_out_PointerTorgt__addNodeResponse(soap, tag, id, (struct rgt__addNodeResponse *const*)ptr, "rgt:addNodeResponse");
	case SOAP_TYPE_PointerTorgt__getParentNodeResponse:
		return soap_out_PointerTorgt__getParentNodeResponse(soap, tag, id, (struct rgt__getParentNodeResponse *const*)ptr, "rgt:getParentNodeResponse");
	case SOAP_TYPE_PointerTorgt__getCheckPointDataResponse:
		return soap_out_PointerTorgt__getCheckPointDataResponse(soap, tag, id, (struct rgt__getCheckPointDataResponse *const*)ptr, "rgt:getCheckPointDataResponse");
	case SOAP_TYPE_PointerTorgt__requestTerminationBeforeResponse:
		return soap_out_PointerTorgt__requestTerminationBeforeResponse(soap, tag, id, (struct rgt__requestTerminationBeforeResponse *const*)ptr, "rgt:requestTerminationBeforeResponse");
	case SOAP_TYPE_PointerTorgt__getSteeringCommandsResponse:
		return soap_out_PointerTorgt__getSteeringCommandsResponse(soap, tag, id, (struct rgt__getSteeringCommandsResponse *const*)ptr, "rgt:getSteeringCommandsResponse");
	case SOAP_TYPE_PointerTorgt__destroyResponse:
		return soap_out_PointerTorgt__destroyResponse(soap, tag, id, (struct rgt__destroyResponse *const*)ptr, "rgt:destroyResponse");
	case SOAP_TYPE_PointerTorgt__setCheckPointDataResponse:
		return soap_out_PointerTorgt__setCheckPointDataResponse(soap, tag, id, (struct rgt__setCheckPointDataResponse *const*)ptr, "rgt:setCheckPointDataResponse");
	case SOAP_TYPE_PointerTorgt__findServiceDataResponse:
		return soap_out_PointerTorgt__findServiceDataResponse(soap, tag, id, (struct rgt__findServiceDataResponse *const*)ptr, "rgt:findServiceDataResponse");
	case SOAP_TYPE_PointerTorgt__getInputFileResponse:
		return soap_out_PointerTorgt__getInputFileResponse(soap, tag, id, (struct rgt__getInputFileResponse *const*)ptr, "rgt:getInputFileResponse");
	case SOAP_TYPE_PointerTorgt__getChildNodesResponse:
		return soap_out_PointerTorgt__getChildNodesResponse(soap, tag, id, (struct rgt__getChildNodesResponse *const*)ptr, "rgt:getChildNodesResponse");
	case SOAP_TYPE_PointerTorgt__requestTerminationAfterResponse:
		return soap_out_PointerTorgt__requestTerminationAfterResponse(soap, tag, id, (struct rgt__requestTerminationAfterResponse *const*)ptr, "rgt:requestTerminationAfterResponse");
	case SOAP_TYPE_PointerTorgtf__requestTerminationAfterResponse:
		return soap_out_PointerTorgtf__requestTerminationAfterResponse(soap, tag, id, (struct rgtf__requestTerminationAfterResponse *const*)ptr, "rgtf:requestTerminationAfterResponse");
	case SOAP_TYPE_PointerTorgtf__requestTerminationBeforeResponse:
		return soap_out_PointerTorgtf__requestTerminationBeforeResponse(soap, tag, id, (struct rgtf__requestTerminationBeforeResponse *const*)ptr, "rgtf:requestTerminationBeforeResponse");
	case SOAP_TYPE_PointerTorgtf__getActiveTreesResponse:
		return soap_out_PointerTorgtf__getActiveTreesResponse(soap, tag, id, (struct rgtf__getActiveTreesResponse *const*)ptr, "rgtf:getActiveTreesResponse");
	case SOAP_TYPE_PointerTorgtf__findServiceDataResponse:
		return soap_out_PointerTorgtf__findServiceDataResponse(soap, tag, id, (struct rgtf__findServiceDataResponse *const*)ptr, "rgtf:findServiceDataResponse");
	case SOAP_TYPE_PointerTorgtf__destroyResponse:
		return soap_out_PointerTorgtf__destroyResponse(soap, tag, id, (struct rgtf__destroyResponse *const*)ptr, "rgtf:destroyResponse");
	case SOAP_TYPE_PointerTorgtf__findByHandleResponse:
		return soap_out_PointerTorgtf__findByHandleResponse(soap, tag, id, (struct rgtf__findByHandleResponse *const*)ptr, "rgtf:findByHandleResponse");
	case SOAP_TYPE_PointerTorgtf__createNewTreeResponse:
		return soap_out_PointerTorgtf__createNewTreeResponse(soap, tag, id, (struct rgtf__createNewTreeResponse *const*)ptr, "rgtf:createNewTreeResponse");
	case SOAP_TYPE_PointerTosgr__findServiceDataResponse:
		return soap_out_PointerTosgr__findServiceDataResponse(soap, tag, id, (struct sgr__findServiceDataResponse *const*)ptr, "sgr:findServiceDataResponse");
	case SOAP_TYPE_PointerTosgr__addResponse:
		return soap_out_PointerTosgr__addResponse(soap, tag, id, (struct sgr__addResponse *const*)ptr, "sgr:addResponse");
	case SOAP_TYPE_PointerTosgr__removeResponse:
		return soap_out_PointerTosgr__removeResponse(soap, tag, id, (struct sgr__removeResponse *const*)ptr, "sgr:removeResponse");
	case SOAP_TYPE_PointerToxsd__string:
		return soap_out_PointerToxsd__string(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToArrayOf_USCORE_xsd_USCORE_string:
		return soap_out_PointerToArrayOf_USCORE_xsd_USCORE_string(soap, tag, id, (struct ArrayOf_USCORE_xsd_USCORE_string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToswsf__createSWSResourceResponse:
		return soap_out_PointerToswsf__createSWSResourceResponse(soap, tag, id, (struct swsf__createSWSResourceResponse *const*)ptr, "swsf:createSWSResourceResponse");
	case SOAP_TYPE_PointerTosgsf__createServiceResponse:
		return soap_out_PointerTosgsf__createServiceResponse(soap, tag, id, (struct sgsf__createServiceResponse *const*)ptr, "sgsf:createServiceResponse");
	case SOAP_TYPE_PointerTosgsf__destroyResponse:
		return soap_out_PointerTosgsf__destroyResponse(soap, tag, id, (struct sgsf__destroyResponse *const*)ptr, "sgsf:destroyResponse");
	case SOAP_TYPE_PointerTosgsf__registerSelfResponse:
		return soap_out_PointerTosgsf__registerSelfResponse(soap, tag, id, (struct sgsf__registerSelfResponse *const*)ptr, "sgsf:registerSelfResponse");
	case SOAP_TYPE_PointerTosgs__AppStopResponse:
		return soap_out_PointerTosgs__AppStopResponse(soap, tag, id, (struct sgs__AppStopResponse *const*)ptr, "sgs:AppStopResponse");
	case SOAP_TYPE_PointerTosgs__GetNotificationsResponse:
		return soap_out_PointerTosgs__GetNotificationsResponse(soap, tag, id, (struct sgs__GetNotificationsResponse *const*)ptr, "sgs:GetNotificationsResponse");
	case SOAP_TYPE_PointerTosgs__GetControlResponse:
		return soap_out_PointerTosgs__GetControlResponse(soap, tag, id, (struct sgs__GetControlResponse *const*)ptr, "sgs:GetControlResponse");
	case SOAP_TYPE_PointerTosgs__destroyResponse:
		return soap_out_PointerTosgs__destroyResponse(soap, tag, id, (struct sgs__destroyResponse *const*)ptr, "sgs:destroyResponse");
	case SOAP_TYPE_PointerTosgs__findServiceDataResponse:
		return soap_out_PointerTosgs__findServiceDataResponse(soap, tag, id, (struct sgs__findServiceDataResponse *const*)ptr, "sgs:findServiceDataResponse");
	case SOAP_TYPE_PointerTosgs__GetNthDataSourceResponse:
		return soap_out_PointerTosgs__GetNthDataSourceResponse(soap, tag, id, (struct sgs__GetNthDataSourceResponse *const*)ptr, "sgs:GetNthDataSourceResponse");
	case SOAP_TYPE_PointerTosgs__RestartResponse:
		return soap_out_PointerTosgs__RestartResponse(soap, tag, id, (struct sgs__RestartResponse *const*)ptr, "sgs:RestartResponse");
	case SOAP_TYPE_PointerTosgs__PutControlResponse:
		return soap_out_PointerTosgs__PutControlResponse(soap, tag, id, (struct sgs__PutControlResponse *const*)ptr, "sgs:PutControlResponse");
	case SOAP_TYPE_PointerTosgs__PauseResponse:
		return soap_out_PointerTosgs__PauseResponse(soap, tag, id, (struct sgs__PauseResponse *const*)ptr, "sgs:PauseResponse");
	case SOAP_TYPE_PointerTosgs__AppDetachResponse:
		return soap_out_PointerTosgs__AppDetachResponse(soap, tag, id, (struct sgs__AppDetachResponse *const*)ptr, "sgs:AppDetachResponse");
	case SOAP_TYPE_PointerTosgs__AppPutLogResponse:
		return soap_out_PointerTosgs__AppPutLogResponse(soap, tag, id, (struct sgs__AppPutLogResponse *const*)ptr, "sgs:AppPutLogResponse");
	case SOAP_TYPE_PointerTosgs__setServiceDataResponse:
		return soap_out_PointerTosgs__setServiceDataResponse(soap, tag, id, (struct sgs__setServiceDataResponse *const*)ptr, "sgs:setServiceDataResponse");
	case SOAP_TYPE_PointerTosgs__GetParamLogResponse:
		return soap_out_PointerTosgs__GetParamLogResponse(soap, tag, id, (struct sgs__GetParamLogResponse *const*)ptr, "sgs:GetParamLogResponse");
	case SOAP_TYPE_PointerTosgs__AppStartResponse:
		return soap_out_PointerTosgs__AppStartResponse(soap, tag, id, (struct sgs__AppStartResponse *const*)ptr, "sgs:AppStartResponse");
	case SOAP_TYPE_PointerTosgs__PutStatusResponse:
		return soap_out_PointerTosgs__PutStatusResponse(soap, tag, id, (struct sgs__PutStatusResponse *const*)ptr, "sgs:PutStatusResponse");
	case SOAP_TYPE_PointerTosgs__AppRecordChkpointResponse:
		return soap_out_PointerTosgs__AppRecordChkpointResponse(soap, tag, id, (struct sgs__AppRecordChkpointResponse *const*)ptr, "sgs:AppRecordChkpointResponse");
	case SOAP_TYPE_PointerTosgs__ResumeResponse:
		return soap_out_PointerTosgs__ResumeResponse(soap, tag, id, (struct sgs__ResumeResponse *const*)ptr, "sgs:ResumeResponse");
	case SOAP_TYPE_PointerTosgs__DetachResponse:
		return soap_out_PointerTosgs__DetachResponse(soap, tag, id, (struct sgs__DetachResponse *const*)ptr, "sgs:DetachResponse");
	case SOAP_TYPE_PointerTosgs__ClearStatusMsgQueueResponse:
		return soap_out_PointerTosgs__ClearStatusMsgQueueResponse(soap, tag, id, (struct sgs__ClearStatusMsgQueueResponse *const*)ptr, "sgs:ClearStatusMsgQueueResponse");
	case SOAP_TYPE_PointerTosgs__StopResponse:
		return soap_out_PointerTosgs__StopResponse(soap, tag, id, (struct sgs__StopResponse *const*)ptr, "sgs:StopResponse");
	case SOAP_TYPE_PointerTosgs__GetStatusResponse:
		return soap_out_PointerTosgs__GetStatusResponse(soap, tag, id, (struct sgs__GetStatusResponse *const*)ptr, "sgs:GetStatusResponse");
	case SOAP_TYPE_PointerTosgs__AttachResponse:
		return soap_out_PointerTosgs__AttachResponse(soap, tag, id, (struct sgs__AttachResponse *const*)ptr, "sgs:AttachResponse");
	case SOAP_TYPE_PointerTowsrp__DestroyResponse:
		return soap_out_PointerTowsrp__DestroyResponse(soap, tag, id, (struct wsrp__DestroyResponse *const*)ptr, "wsrp:DestroyResponse");
	case SOAP_TYPE_PointerTosws__PutParamLogResponse:
		return soap_out_PointerTosws__PutParamLogResponse(soap, tag, id, (struct sws__PutParamLogResponse *const*)ptr, "sws:PutParamLogResponse");
	case SOAP_TYPE_PointerTosws__GetParamLogResponse:
		return soap_out_PointerTosws__GetParamLogResponse(soap, tag, id, (struct sws__GetParamLogResponse *const*)ptr, "sws:GetParamLogResponse");
	case SOAP_TYPE_PointerTosws__RecordCheckpointResponse:
		return soap_out_PointerTosws__RecordCheckpointResponse(soap, tag, id, (struct sws__RecordCheckpointResponse *const*)ptr, "sws:RecordCheckpointResponse");
	case SOAP_TYPE_PointerTosws__DetachResponse:
		return soap_out_PointerTosws__DetachResponse(soap, tag, id, (struct sws__DetachResponse *const*)ptr, "sws:DetachResponse");
	case SOAP_TYPE_PointerTosws__AttachResponse:
		return soap_out_PointerTosws__AttachResponse(soap, tag, id, (struct sws__AttachResponse *const*)ptr, "sws:AttachResponse");
	case SOAP_TYPE_PointerTosws__AddChildResponse:
		return soap_out_PointerTosws__AddChildResponse(soap, tag, id, (struct sws__AddChildResponse *const*)ptr, "sws:AddChildResponse");
	case SOAP_TYPE_PointerTowsrp__SetResourcePropertiesResponse:
		return soap_out_PointerTowsrp__SetResourcePropertiesResponse(soap, tag, id, (struct wsrp__SetResourcePropertiesResponse *const*)ptr, "wsrp:SetResourcePropertiesResponse");
	case SOAP_TYPE_PointerToGetResourcePropertyRequest:
		return soap_out_PointerToGetResourcePropertyRequest(soap, tag, id, (struct GetResourcePropertyRequest *const*)ptr, "GetResourcePropertyRequest");
	case SOAP_TYPE_PointerTowsrp__ResourcePropertyStruct:
		return soap_out_PointerTowsrp__ResourcePropertyStruct(soap, tag, id, (struct wsrp__ResourcePropertyStruct *const*)ptr, "wsrp:ResourcePropertyStruct");
	case SOAP_TYPE_PointerToCommand:
		return soap_out_PointerToCommand(soap, tag, id, (struct Command *const*)ptr, "Command");
	case SOAP_TYPE_xsd__string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "QName", id, (char**)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_rgt__addNode:
		soap_serialize_rgt__addNode(soap, (const struct rgt__addNode *)ptr);
		break;
	case SOAP_TYPE_rgt__getParentNode:
		soap_serialize_rgt__getParentNode(soap, (const struct rgt__getParentNode *)ptr);
		break;
	case SOAP_TYPE_rgt__getCheckPointData:
		soap_serialize_rgt__getCheckPointData(soap, (const struct rgt__getCheckPointData *)ptr);
		break;
	case SOAP_TYPE_rgt__requestTerminationBefore:
		soap_serialize_rgt__requestTerminationBefore(soap, (const struct rgt__requestTerminationBefore *)ptr);
		break;
	case SOAP_TYPE_rgt__getSteeringCommands:
		soap_serialize_rgt__getSteeringCommands(soap, (const struct rgt__getSteeringCommands *)ptr);
		break;
	case SOAP_TYPE_rgt__destroy:
		soap_serialize_rgt__destroy(soap, (const struct rgt__destroy *)ptr);
		break;
	case SOAP_TYPE_rgt__setCheckPointData:
		soap_serialize_rgt__setCheckPointData(soap, (const struct rgt__setCheckPointData *)ptr);
		break;
	case SOAP_TYPE_rgt__findServiceData:
		soap_serialize_rgt__findServiceData(soap, (const struct rgt__findServiceData *)ptr);
		break;
	case SOAP_TYPE_rgt__getInputFile:
		soap_serialize_rgt__getInputFile(soap, (const struct rgt__getInputFile *)ptr);
		break;
	case SOAP_TYPE_rgt__getChildNodes:
		soap_serialize_rgt__getChildNodes(soap, (const struct rgt__getChildNodes *)ptr);
		break;
	case SOAP_TYPE_rgt__requestTerminationAfter:
		soap_serialize_rgt__requestTerminationAfter(soap, (const struct rgt__requestTerminationAfter *)ptr);
		break;
	case SOAP_TYPE_rgt__destroyResponse:
		soap_serialize_rgt__destroyResponse(soap, (const struct rgt__destroyResponse *)ptr);
		break;
	case SOAP_TYPE_rgt__getInputFileResponse:
		soap_serialize_rgt__getInputFileResponse(soap, (const struct rgt__getInputFileResponse *)ptr);
		break;
	case SOAP_TYPE_rgt__getSteeringCommandsResponse:
		soap_serialize_rgt__getSteeringCommandsResponse(soap, (const struct rgt__getSteeringCommandsResponse *)ptr);
		break;
	case SOAP_TYPE_rgt__requestTerminationBeforeResponse:
		soap_serialize_rgt__requestTerminationBeforeResponse(soap, (const struct rgt__requestTerminationBeforeResponse *)ptr);
		break;
	case SOAP_TYPE_rgt__getChildNodesResponse:
		soap_serialize_rgt__getChildNodesResponse(soap, (const struct rgt__getChildNodesResponse *)ptr);
		break;
	case SOAP_TYPE_rgt__setCheckPointDataResponse:
		soap_serialize_rgt__setCheckPointDataResponse(soap, (const struct rgt__setCheckPointDataResponse *)ptr);
		break;
	case SOAP_TYPE_rgt__findServiceDataResponse:
		soap_serialize_rgt__findServiceDataResponse(soap, (const struct rgt__findServiceDataResponse *)ptr);
		break;
	case SOAP_TYPE_rgt__getCheckPointDataResponse:
		soap_serialize_rgt__getCheckPointDataResponse(soap, (const struct rgt__getCheckPointDataResponse *)ptr);
		break;
	case SOAP_TYPE_rgt__addNodeResponse:
		soap_serialize_rgt__addNodeResponse(soap, (const struct rgt__addNodeResponse *)ptr);
		break;
	case SOAP_TYPE_rgt__requestTerminationAfterResponse:
		soap_serialize_rgt__requestTerminationAfterResponse(soap, (const struct rgt__requestTerminationAfterResponse *)ptr);
		break;
	case SOAP_TYPE_rgt__getParentNodeResponse:
		soap_serialize_rgt__getParentNodeResponse(soap, (const struct rgt__getParentNodeResponse *)ptr);
		break;
	case SOAP_TYPE_rgtf__requestTerminationAfter:
		soap_serialize_rgtf__requestTerminationAfter(soap, (const struct rgtf__requestTerminationAfter *)ptr);
		break;
	case SOAP_TYPE_rgtf__requestTerminationBefore:
		soap_serialize_rgtf__requestTerminationBefore(soap, (const struct rgtf__requestTerminationBefore *)ptr);
		break;
	case SOAP_TYPE_rgtf__getActiveTrees:
		soap_serialize_rgtf__getActiveTrees(soap, (const struct rgtf__getActiveTrees *)ptr);
		break;
	case SOAP_TYPE_rgtf__findServiceData:
		soap_serialize_rgtf__findServiceData(soap, (const struct rgtf__findServiceData *)ptr);
		break;
	case SOAP_TYPE_rgtf__destroy:
		soap_serialize_rgtf__destroy(soap, (const struct rgtf__destroy *)ptr);
		break;
	case SOAP_TYPE_rgtf__findByHandle:
		soap_serialize_rgtf__findByHandle(soap, (const struct rgtf__findByHandle *)ptr);
		break;
	case SOAP_TYPE_rgtf__createNewTree:
		soap_serialize_rgtf__createNewTree(soap, (const struct rgtf__createNewTree *)ptr);
		break;
	case SOAP_TYPE_rgtf__destroyResponse:
		soap_serialize_rgtf__destroyResponse(soap, (const struct rgtf__destroyResponse *)ptr);
		break;
	case SOAP_TYPE_rgtf__requestTerminationAfterResponse:
		soap_serialize_rgtf__requestTerminationAfterResponse(soap, (const struct rgtf__requestTerminationAfterResponse *)ptr);
		break;
	case SOAP_TYPE_rgtf__createNewTreeResponse:
		soap_serialize_rgtf__createNewTreeResponse(soap, (const struct rgtf__createNewTreeResponse *)ptr);
		break;
	case SOAP_TYPE_rgtf__getActiveTreesResponse:
		soap_serialize_rgtf__getActiveTreesResponse(soap, (const struct rgtf__getActiveTreesResponse *)ptr);
		break;
	case SOAP_TYPE_rgtf__findByHandleResponse:
		soap_serialize_rgtf__findByHandleResponse(soap, (const struct rgtf__findByHandleResponse *)ptr);
		break;
	case SOAP_TYPE_rgtf__findServiceDataResponse:
		soap_serialize_rgtf__findServiceDataResponse(soap, (const struct rgtf__findServiceDataResponse *)ptr);
		break;
	case SOAP_TYPE_rgtf__requestTerminationBeforeResponse:
		soap_serialize_rgtf__requestTerminationBeforeResponse(soap, (const struct rgtf__requestTerminationBeforeResponse *)ptr);
		break;
	case SOAP_TYPE_sgr__findServiceData:
		soap_serialize_sgr__findServiceData(soap, (const struct sgr__findServiceData *)ptr);
		break;
	case SOAP_TYPE_sgr__add:
		soap_serialize_sgr__add(soap, (const struct sgr__add *)ptr);
		break;
	case SOAP_TYPE_sgr__remove:
		soap_serialize_sgr__remove(soap, (const struct sgr__remove *)ptr);
		break;
	case SOAP_TYPE_sgr__removeResponse:
		soap_serialize_sgr__removeResponse(soap, (const struct sgr__removeResponse *)ptr);
		break;
	case SOAP_TYPE_ArrayOf_USCORE_xsd_USCORE_string:
		soap_serialize_ArrayOf_USCORE_xsd_USCORE_string(soap, (const struct ArrayOf_USCORE_xsd_USCORE_string *)ptr);
		break;
	case SOAP_TYPE_sgr__addResponse:
		soap_serialize_sgr__addResponse(soap, (const struct sgr__addResponse *)ptr);
		break;
	case SOAP_TYPE_sgr__findServiceDataResponse:
		soap_serialize_sgr__findServiceDataResponse(soap, (const struct sgr__findServiceDataResponse *)ptr);
		break;
	case SOAP_TYPE_swsf__createSWSResource:
		soap_serialize_swsf__createSWSResource(soap, (const struct swsf__createSWSResource *)ptr);
		break;
	case SOAP_TYPE_swsf__createSWSResourceResponse:
		soap_serialize_swsf__createSWSResourceResponse(soap, (const struct swsf__createSWSResourceResponse *)ptr);
		break;
	case SOAP_TYPE_epr:
		soap_serialize_epr(soap, (const struct epr *)ptr);
		break;
	case SOAP_TYPE_sgsf__createService:
		soap_serialize_sgsf__createService(soap, (const struct sgsf__createService *)ptr);
		break;
	case SOAP_TYPE_sgsf__destroy:
		soap_serialize_sgsf__destroy(soap, (const struct sgsf__destroy *)ptr);
		break;
	case SOAP_TYPE_sgsf__registerSelf:
		soap_serialize_sgsf__registerSelf(soap, (const struct sgsf__registerSelf *)ptr);
		break;
	case SOAP_TYPE_sgsf__registerSelfResponse:
		soap_serialize_sgsf__registerSelfResponse(soap, (const struct sgsf__registerSelfResponse *)ptr);
		break;
	case SOAP_TYPE_sgsf__destroyResponse:
		soap_serialize_sgsf__destroyResponse(soap, (const struct sgsf__destroyResponse *)ptr);
		break;
	case SOAP_TYPE_sgsf__createServiceResponse:
		soap_serialize_sgsf__createServiceResponse(soap, (const struct sgsf__createServiceResponse *)ptr);
		break;
	case SOAP_TYPE_sgs__AppStop:
		soap_serialize_sgs__AppStop(soap, (const struct sgs__AppStop *)ptr);
		break;
	case SOAP_TYPE_sgs__GetNotifications:
		soap_serialize_sgs__GetNotifications(soap, (const struct sgs__GetNotifications *)ptr);
		break;
	case SOAP_TYPE_sgs__GetControl:
		soap_serialize_sgs__GetControl(soap, (const struct sgs__GetControl *)ptr);
		break;
	case SOAP_TYPE_sgs__destroy:
		soap_serialize_sgs__destroy(soap, (const struct sgs__destroy *)ptr);
		break;
	case SOAP_TYPE_sgs__findServiceData:
		soap_serialize_sgs__findServiceData(soap, (const struct sgs__findServiceData *)ptr);
		break;
	case SOAP_TYPE_sgs__GetNthDataSource:
		soap_serialize_sgs__GetNthDataSource(soap, (const struct sgs__GetNthDataSource *)ptr);
		break;
	case SOAP_TYPE_sgs__Restart:
		soap_serialize_sgs__Restart(soap, (const struct sgs__Restart *)ptr);
		break;
	case SOAP_TYPE_sgs__PutControl:
		soap_serialize_sgs__PutControl(soap, (const struct sgs__PutControl *)ptr);
		break;
	case SOAP_TYPE_sgs__Pause:
		soap_serialize_sgs__Pause(soap, (const struct sgs__Pause *)ptr);
		break;
	case SOAP_TYPE_sgs__AppDetach:
		soap_serialize_sgs__AppDetach(soap, (const struct sgs__AppDetach *)ptr);
		break;
	case SOAP_TYPE_sgs__AppPutLog:
		soap_serialize_sgs__AppPutLog(soap, (const struct sgs__AppPutLog *)ptr);
		break;
	case SOAP_TYPE_sgs__setServiceData:
		soap_serialize_sgs__setServiceData(soap, (const struct sgs__setServiceData *)ptr);
		break;
	case SOAP_TYPE_sgs__GetParamLog:
		soap_serialize_sgs__GetParamLog(soap, (const struct sgs__GetParamLog *)ptr);
		break;
	case SOAP_TYPE_sgs__AppStart:
		soap_serialize_sgs__AppStart(soap, (const struct sgs__AppStart *)ptr);
		break;
	case SOAP_TYPE_sgs__PutStatus:
		soap_serialize_sgs__PutStatus(soap, (const struct sgs__PutStatus *)ptr);
		break;
	case SOAP_TYPE_sgs__AppRecordChkpoint:
		soap_serialize_sgs__AppRecordChkpoint(soap, (const struct sgs__AppRecordChkpoint *)ptr);
		break;
	case SOAP_TYPE_sgs__Resume:
		soap_serialize_sgs__Resume(soap, (const struct sgs__Resume *)ptr);
		break;
	case SOAP_TYPE_sgs__Detach:
		soap_serialize_sgs__Detach(soap, (const struct sgs__Detach *)ptr);
		break;
	case SOAP_TYPE_sgs__ClearStatusMsgQueue:
		soap_serialize_sgs__ClearStatusMsgQueue(soap, (const struct sgs__ClearStatusMsgQueue *)ptr);
		break;
	case SOAP_TYPE_sgs__Stop:
		soap_serialize_sgs__Stop(soap, (const struct sgs__Stop *)ptr);
		break;
	case SOAP_TYPE_sgs__GetStatus:
		soap_serialize_sgs__GetStatus(soap, (const struct sgs__GetStatus *)ptr);
		break;
	case SOAP_TYPE_sgs__Attach:
		soap_serialize_sgs__Attach(soap, (const struct sgs__Attach *)ptr);
		break;
	case SOAP_TYPE_sgs__AppDetachResponse:
		soap_serialize_sgs__AppDetachResponse(soap, (const struct sgs__AppDetachResponse *)ptr);
		break;
	case SOAP_TYPE_sgs__AppStartResponse:
		soap_serialize_sgs__AppStartResponse(soap, (const struct sgs__AppStartResponse *)ptr);
		break;
	case SOAP_TYPE_sgs__GetNthDataSourceResponse:
		soap_serialize_sgs__GetNthDataSourceResponse(soap, (const struct sgs__GetNthDataSourceResponse *)ptr);
		break;
	case SOAP_TYPE_sgs__AppPutLogResponse:
		soap_serialize_sgs__AppPutLogResponse(soap, (const struct sgs__AppPutLogResponse *)ptr);
		break;
	case SOAP_TYPE_sgs__ClearStatusMsgQueueResponse:
		soap_serialize_sgs__ClearStatusMsgQueueResponse(soap, (const struct sgs__ClearStatusMsgQueueResponse *)ptr);
		break;
	case SOAP_TYPE_sgs__destroyResponse:
		soap_serialize_sgs__destroyResponse(soap, (const struct sgs__destroyResponse *)ptr);
		break;
	case SOAP_TYPE_sgs__AppStopResponse:
		soap_serialize_sgs__AppStopResponse(soap, (const struct sgs__AppStopResponse *)ptr);
		break;
	case SOAP_TYPE_sgs__GetStatusResponse:
		soap_serialize_sgs__GetStatusResponse(soap, (const struct sgs__GetStatusResponse *)ptr);
		break;
	case SOAP_TYPE_sgs__GetControlResponse:
		soap_serialize_sgs__GetControlResponse(soap, (const struct sgs__GetControlResponse *)ptr);
		break;
	case SOAP_TYPE_sgs__StopResponse:
		soap_serialize_sgs__StopResponse(soap, (const struct sgs__StopResponse *)ptr);
		break;
	case SOAP_TYPE_sgs__GetNotificationsResponse:
		soap_serialize_sgs__GetNotificationsResponse(soap, (const struct sgs__GetNotificationsResponse *)ptr);
		break;
	case SOAP_TYPE_sgs__AttachResponse:
		soap_serialize_sgs__AttachResponse(soap, (const struct sgs__AttachResponse *)ptr);
		break;
	case SOAP_TYPE_sgs__ResumeResponse:
		soap_serialize_sgs__ResumeResponse(soap, (const struct sgs__ResumeResponse *)ptr);
		break;
	case SOAP_TYPE_sgs__PutControlResponse:
		soap_serialize_sgs__PutControlResponse(soap, (const struct sgs__PutControlResponse *)ptr);
		break;
	case SOAP_TYPE_sgs__RestartResponse:
		soap_serialize_sgs__RestartResponse(soap, (const struct sgs__RestartResponse *)ptr);
		break;
	case SOAP_TYPE_sgs__findServiceDataResponse:
		soap_serialize_sgs__findServiceDataResponse(soap, (const struct sgs__findServiceDataResponse *)ptr);
		break;
	case SOAP_TYPE_sgs__PauseResponse:
		soap_serialize_sgs__PauseResponse(soap, (const struct sgs__PauseResponse *)ptr);
		break;
	case SOAP_TYPE_sgs__setServiceDataResponse:
		soap_serialize_sgs__setServiceDataResponse(soap, (const struct sgs__setServiceDataResponse *)ptr);
		break;
	case SOAP_TYPE_sgs__PutStatusResponse:
		soap_serialize_sgs__PutStatusResponse(soap, (const struct sgs__PutStatusResponse *)ptr);
		break;
	case SOAP_TYPE_sgs__AppRecordChkpointResponse:
		soap_serialize_sgs__AppRecordChkpointResponse(soap, (const struct sgs__AppRecordChkpointResponse *)ptr);
		break;
	case SOAP_TYPE_sgs__DetachResponse:
		soap_serialize_sgs__DetachResponse(soap, (const struct sgs__DetachResponse *)ptr);
		break;
	case SOAP_TYPE_sgs__GetParamLogResponse:
		soap_serialize_sgs__GetParamLogResponse(soap, (const struct sgs__GetParamLogResponse *)ptr);
		break;
	case SOAP_TYPE_wsrp__Destroy:
		soap_serialize_wsrp__Destroy(soap, (const struct wsrp__Destroy *)ptr);
		break;
	case SOAP_TYPE_sws__PutParamLog:
		soap_serialize_sws__PutParamLog(soap, (const struct sws__PutParamLog *)ptr);
		break;
	case SOAP_TYPE_sws__GetParamLog:
		soap_serialize_sws__GetParamLog(soap, (const struct sws__GetParamLog *)ptr);
		break;
	case SOAP_TYPE_sws__RecordCheckpoint:
		soap_serialize_sws__RecordCheckpoint(soap, (const struct sws__RecordCheckpoint *)ptr);
		break;
	case SOAP_TYPE_sws__Detach:
		soap_serialize_sws__Detach(soap, (const struct sws__Detach *)ptr);
		break;
	case SOAP_TYPE_sws__Attach:
		soap_serialize_sws__Attach(soap, (const struct sws__Attach *)ptr);
		break;
	case SOAP_TYPE_sws__AddChild:
		soap_serialize_sws__AddChild(soap, (const struct sws__AddChild *)ptr);
		break;
	case SOAP_TYPE_wsrp__GetResourcePropertyDocument:
		soap_serialize_wsrp__GetResourcePropertyDocument(soap, (const struct wsrp__GetResourcePropertyDocument *)ptr);
		break;
	case SOAP_TYPE_wsrp__SetResourceProperties:
		soap_serialize_wsrp__SetResourceProperties(soap, (const struct wsrp__SetResourceProperties *)ptr);
		break;
	case SOAP_TYPE_wsrp__GetMultipleResourceProperties:
		soap_serialize_wsrp__GetMultipleResourceProperties(soap, (const struct wsrp__GetMultipleResourceProperties *)ptr);
		break;
	case SOAP_TYPE_wsrp__GetResourceProperty:
		soap_serialize_wsrp__GetResourceProperty(soap, (const struct wsrp__GetResourceProperty *)ptr);
		break;
	case SOAP_TYPE_sws__DetachResponse:
		soap_serialize_sws__DetachResponse(soap, (const struct sws__DetachResponse *)ptr);
		break;
	case SOAP_TYPE_sws__AddChildResponse:
		soap_serialize_sws__AddChildResponse(soap, (const struct sws__AddChildResponse *)ptr);
		break;
	case SOAP_TYPE_sws__AddChildRequest:
		soap_serialize_sws__AddChildRequest(soap, (const struct sws__AddChildRequest *)ptr);
		break;
	case SOAP_TYPE_wsrp__SetResourcePropertiesResponse:
		soap_serialize_wsrp__SetResourcePropertiesResponse(soap, (const struct wsrp__SetResourcePropertiesResponse *)ptr);
		break;
	case SOAP_TYPE_wsrp__GetMultipleResourcePropertiesRequest:
		soap_serialize_wsrp__GetMultipleResourcePropertiesRequest(soap, (const struct wsrp__GetMultipleResourcePropertiesRequest *)ptr);
		break;
	case SOAP_TYPE_wsrp__ResourcePropertyStruct:
		soap_serialize_wsrp__ResourcePropertyStruct(soap, (const struct wsrp__ResourcePropertyStruct *)ptr);
		break;
	case SOAP_TYPE_wsrp__GetResourcePropertyResponse:
		soap_serialize_wsrp__GetResourcePropertyResponse(soap, (const struct wsrp__GetResourcePropertyResponse *)ptr);
		break;
	case SOAP_TYPE_GetResourcePropertyRequest:
		soap_serialize_GetResourcePropertyRequest(soap, (const struct GetResourcePropertyRequest *)ptr);
		break;
	case SOAP_TYPE_sws__PutParamLogResponse:
		soap_serialize_sws__PutParamLogResponse(soap, (const struct sws__PutParamLogResponse *)ptr);
		break;
	case SOAP_TYPE_wsrp__DestroyResponse:
		soap_serialize_wsrp__DestroyResponse(soap, (const struct wsrp__DestroyResponse *)ptr);
		break;
	case SOAP_TYPE_sws__AttachResponse:
		soap_serialize_sws__AttachResponse(soap, (const struct sws__AttachResponse *)ptr);
		break;
	case SOAP_TYPE_steerMessage:
		soap_serialize_steerMessage(soap, (const struct steerMessage *)ptr);
		break;
	case SOAP_TYPE_supp_cmds:
		soap_serialize_supp_cmds(soap, (const struct supp_cmds *)ptr);
		break;
	case SOAP_TYPE_Command:
		soap_serialize_Command(soap, (const struct Command *)ptr);
		break;
	case SOAP_TYPE_sws__RecordCheckpointResponse:
		soap_serialize_sws__RecordCheckpointResponse(soap, (const struct sws__RecordCheckpointResponse *)ptr);
		break;
	case SOAP_TYPE_sws__GetParamLogResponse:
		soap_serialize_sws__GetParamLogResponse(soap, (const struct sws__GetParamLogResponse *)ptr);
		break;
	case SOAP_TYPE_PointerTorgt__addNodeResponse:
		soap_serialize_PointerTorgt__addNodeResponse(soap, (struct rgt__addNodeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorgt__getParentNodeResponse:
		soap_serialize_PointerTorgt__getParentNodeResponse(soap, (struct rgt__getParentNodeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorgt__getCheckPointDataResponse:
		soap_serialize_PointerTorgt__getCheckPointDataResponse(soap, (struct rgt__getCheckPointDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorgt__requestTerminationBeforeResponse:
		soap_serialize_PointerTorgt__requestTerminationBeforeResponse(soap, (struct rgt__requestTerminationBeforeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorgt__getSteeringCommandsResponse:
		soap_serialize_PointerTorgt__getSteeringCommandsResponse(soap, (struct rgt__getSteeringCommandsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorgt__destroyResponse:
		soap_serialize_PointerTorgt__destroyResponse(soap, (struct rgt__destroyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorgt__setCheckPointDataResponse:
		soap_serialize_PointerTorgt__setCheckPointDataResponse(soap, (struct rgt__setCheckPointDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorgt__findServiceDataResponse:
		soap_serialize_PointerTorgt__findServiceDataResponse(soap, (struct rgt__findServiceDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorgt__getInputFileResponse:
		soap_serialize_PointerTorgt__getInputFileResponse(soap, (struct rgt__getInputFileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorgt__getChildNodesResponse:
		soap_serialize_PointerTorgt__getChildNodesResponse(soap, (struct rgt__getChildNodesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorgt__requestTerminationAfterResponse:
		soap_serialize_PointerTorgt__requestTerminationAfterResponse(soap, (struct rgt__requestTerminationAfterResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorgtf__requestTerminationAfterResponse:
		soap_serialize_PointerTorgtf__requestTerminationAfterResponse(soap, (struct rgtf__requestTerminationAfterResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorgtf__requestTerminationBeforeResponse:
		soap_serialize_PointerTorgtf__requestTerminationBeforeResponse(soap, (struct rgtf__requestTerminationBeforeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorgtf__getActiveTreesResponse:
		soap_serialize_PointerTorgtf__getActiveTreesResponse(soap, (struct rgtf__getActiveTreesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorgtf__findServiceDataResponse:
		soap_serialize_PointerTorgtf__findServiceDataResponse(soap, (struct rgtf__findServiceDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorgtf__destroyResponse:
		soap_serialize_PointerTorgtf__destroyResponse(soap, (struct rgtf__destroyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorgtf__findByHandleResponse:
		soap_serialize_PointerTorgtf__findByHandleResponse(soap, (struct rgtf__findByHandleResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorgtf__createNewTreeResponse:
		soap_serialize_PointerTorgtf__createNewTreeResponse(soap, (struct rgtf__createNewTreeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgr__findServiceDataResponse:
		soap_serialize_PointerTosgr__findServiceDataResponse(soap, (struct sgr__findServiceDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgr__addResponse:
		soap_serialize_PointerTosgr__addResponse(soap, (struct sgr__addResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgr__removeResponse:
		soap_serialize_PointerTosgr__removeResponse(soap, (struct sgr__removeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__string:
		soap_serialize_PointerToxsd__string(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOf_USCORE_xsd_USCORE_string:
		soap_serialize_PointerToArrayOf_USCORE_xsd_USCORE_string(soap, (struct ArrayOf_USCORE_xsd_USCORE_string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswsf__createSWSResourceResponse:
		soap_serialize_PointerToswsf__createSWSResourceResponse(soap, (struct swsf__createSWSResourceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgsf__createServiceResponse:
		soap_serialize_PointerTosgsf__createServiceResponse(soap, (struct sgsf__createServiceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgsf__destroyResponse:
		soap_serialize_PointerTosgsf__destroyResponse(soap, (struct sgsf__destroyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgsf__registerSelfResponse:
		soap_serialize_PointerTosgsf__registerSelfResponse(soap, (struct sgsf__registerSelfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgs__AppStopResponse:
		soap_serialize_PointerTosgs__AppStopResponse(soap, (struct sgs__AppStopResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgs__GetNotificationsResponse:
		soap_serialize_PointerTosgs__GetNotificationsResponse(soap, (struct sgs__GetNotificationsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgs__GetControlResponse:
		soap_serialize_PointerTosgs__GetControlResponse(soap, (struct sgs__GetControlResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgs__destroyResponse:
		soap_serialize_PointerTosgs__destroyResponse(soap, (struct sgs__destroyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgs__findServiceDataResponse:
		soap_serialize_PointerTosgs__findServiceDataResponse(soap, (struct sgs__findServiceDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgs__GetNthDataSourceResponse:
		soap_serialize_PointerTosgs__GetNthDataSourceResponse(soap, (struct sgs__GetNthDataSourceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgs__RestartResponse:
		soap_serialize_PointerTosgs__RestartResponse(soap, (struct sgs__RestartResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgs__PutControlResponse:
		soap_serialize_PointerTosgs__PutControlResponse(soap, (struct sgs__PutControlResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgs__PauseResponse:
		soap_serialize_PointerTosgs__PauseResponse(soap, (struct sgs__PauseResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgs__AppDetachResponse:
		soap_serialize_PointerTosgs__AppDetachResponse(soap, (struct sgs__AppDetachResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgs__AppPutLogResponse:
		soap_serialize_PointerTosgs__AppPutLogResponse(soap, (struct sgs__AppPutLogResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgs__setServiceDataResponse:
		soap_serialize_PointerTosgs__setServiceDataResponse(soap, (struct sgs__setServiceDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgs__GetParamLogResponse:
		soap_serialize_PointerTosgs__GetParamLogResponse(soap, (struct sgs__GetParamLogResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgs__AppStartResponse:
		soap_serialize_PointerTosgs__AppStartResponse(soap, (struct sgs__AppStartResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgs__PutStatusResponse:
		soap_serialize_PointerTosgs__PutStatusResponse(soap, (struct sgs__PutStatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgs__AppRecordChkpointResponse:
		soap_serialize_PointerTosgs__AppRecordChkpointResponse(soap, (struct sgs__AppRecordChkpointResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgs__ResumeResponse:
		soap_serialize_PointerTosgs__ResumeResponse(soap, (struct sgs__ResumeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgs__DetachResponse:
		soap_serialize_PointerTosgs__DetachResponse(soap, (struct sgs__DetachResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgs__ClearStatusMsgQueueResponse:
		soap_serialize_PointerTosgs__ClearStatusMsgQueueResponse(soap, (struct sgs__ClearStatusMsgQueueResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgs__StopResponse:
		soap_serialize_PointerTosgs__StopResponse(soap, (struct sgs__StopResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgs__GetStatusResponse:
		soap_serialize_PointerTosgs__GetStatusResponse(soap, (struct sgs__GetStatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosgs__AttachResponse:
		soap_serialize_PointerTosgs__AttachResponse(soap, (struct sgs__AttachResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrp__DestroyResponse:
		soap_serialize_PointerTowsrp__DestroyResponse(soap, (struct wsrp__DestroyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosws__PutParamLogResponse:
		soap_serialize_PointerTosws__PutParamLogResponse(soap, (struct sws__PutParamLogResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosws__GetParamLogResponse:
		soap_serialize_PointerTosws__GetParamLogResponse(soap, (struct sws__GetParamLogResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosws__RecordCheckpointResponse:
		soap_serialize_PointerTosws__RecordCheckpointResponse(soap, (struct sws__RecordCheckpointResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosws__DetachResponse:
		soap_serialize_PointerTosws__DetachResponse(soap, (struct sws__DetachResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosws__AttachResponse:
		soap_serialize_PointerTosws__AttachResponse(soap, (struct sws__AttachResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosws__AddChildResponse:
		soap_serialize_PointerTosws__AddChildResponse(soap, (struct sws__AddChildResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrp__SetResourcePropertiesResponse:
		soap_serialize_PointerTowsrp__SetResourcePropertiesResponse(soap, (struct wsrp__SetResourcePropertiesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToGetResourcePropertyRequest:
		soap_serialize_PointerToGetResourcePropertyRequest(soap, (struct GetResourcePropertyRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrp__ResourcePropertyStruct:
		soap_serialize_PointerTowsrp__ResourcePropertyStruct(soap, (struct wsrp__ResourcePropertyStruct *const*)ptr);
		break;
	case SOAP_TYPE_PointerToCommand:
		soap_serialize_PointerToCommand(soap, (struct Command *const*)ptr);
		break;
	case SOAP_TYPE_xsd__string:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	}
}
#endif

#ifndef WITH_LEANER
SOAP_FMAC3 int SOAP_FMAC4 soap_resolve_attachments(struct soap *soap)
{
	if (!(soap->mode & SOAP_ENC_DIME))
		return SOAP_OK;
	while (soap->dime.flags & SOAP_DIME_CF)
	{	if (soap_getdimehdr(soap))
			return soap->error;
		if (soap_move(soap, soap->dime.size))
			return soap->error = SOAP_EOF;
	}
	if (soap_move(soap, ((soap->dime.size+3)&(~3))-soap_tell(soap)))
		return soap->error = SOAP_EOF;
	for (;;)
	{	if (soap_getdime(soap))
			break;
		switch (soap_lookup_type(soap, soap->dime.id))
		{
		}
	}
	if (soap->error == SOAP_DIME_END)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__int(struct soap *soap, int *a)
{	soap_default_int(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__int);
	if (soap_out_xsd__int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_xsd__int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_xsd__int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_xsd__int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_xsd__int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->faultcode, SOAP_TYPE__QName);
	soap_serialize__QName(soap, &a->faultcode);
	soap_embedded(soap, &a->faultstring, SOAP_TYPE_string);
	soap_serialize_string(soap, &a->faultstring);
	soap_embedded(soap, &a->faultactor, SOAP_TYPE_string);
	soap_serialize_string(soap, &a->faultactor);
	soap_embedded(soap, &a->detail, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_embedded(soap, &a->SOAP_ENV__Code, SOAP_TYPE_PointerToSOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_embedded(soap, &a->SOAP_ENV__Reason, SOAP_TYPE_string);
	soap_serialize_string(soap, &a->SOAP_ENV__Reason);
	soap_embedded(soap, &a->SOAP_ENV__Node, SOAP_TYPE_string);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_embedded(soap, &a->SOAP_ENV__Role, SOAP_TYPE_string);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_embedded(soap, &a->SOAP_ENV__Detail, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Reason);
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_string(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode = 0;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, ""))
				{	soap_flag_faultstring = 0;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, ""))
				{	soap_flag_faultactor = 0;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, ""))
				{	soap_flag_SOAP_ENV__Node = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, ""))
				{	soap_flag_SOAP_ENV__Role = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type);
	soap_putelement(soap, a->fault, "fault", -1, a->__type);
	soap_outliteral(soap, "-any", &a->__any);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->SOAP_ENV__Value, SOAP_TYPE__QName);
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_embedded(soap, &a->SOAP_ENV__Subcode, SOAP_TYPE_PointerToSOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	/* transient dummy skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient dummy skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgt__addNode(struct soap *soap, const struct rgt__addNode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in0);
	soap_embedded(soap, &a->in1, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in1);
	soap_embedded(soap, &a->in2, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in2);
	soap_embedded(soap, &a->in3, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in3);
	soap_embedded(soap, &a->in4, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in4);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgt__addNode(struct soap *soap, struct rgt__addNode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
	soap_default_xsd__string(soap, &a->in1);
	soap_default_xsd__string(soap, &a->in2);
	soap_default_xsd__string(soap, &a->in3);
	soap_default_xsd__string(soap, &a->in4);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgt__addNode(struct soap *soap, const struct rgt__addNode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgt__addNode);
	if (soap_out_rgt__addNode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgt__addNode(struct soap *soap, const char *tag, int id, const struct rgt__addNode *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__addNode), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "");
	soap_out_xsd__string(soap, "in1", -1, &a->in1, "");
	soap_out_xsd__string(soap, "in2", -1, &a->in2, "");
	soap_out_xsd__string(soap, "in3", -1, &a->in3, "");
	soap_out_xsd__string(soap, "in4", -1, &a->in4, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgt__addNode * SOAP_FMAC4 soap_get_rgt__addNode(struct soap *soap, struct rgt__addNode *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__addNode(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__addNode * SOAP_FMAC4 soap_in_rgt__addNode(struct soap *soap, const char *tag, struct rgt__addNode *a, const char *type)
{
	short soap_flag_in0 = 1, soap_flag_in1 = 1, soap_flag_in2 = 1, soap_flag_in3 = 1, soap_flag_in4 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgt__addNode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__addNode, sizeof(struct rgt__addNode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgt__addNode(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap_flag_in1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in1", &a->in1, "xsd:string"))
				{	soap_flag_in1 = 0;
					continue;
				}
			if (soap_flag_in2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in2", &a->in2, "xsd:string"))
				{	soap_flag_in2 = 0;
					continue;
				}
			if (soap_flag_in3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in3", &a->in3, "xsd:string"))
				{	soap_flag_in3 = 0;
					continue;
				}
			if (soap_flag_in4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in4", &a->in4, "xsd:string"))
				{	soap_flag_in4 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgt__addNode *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgt__addNode, 0, sizeof(struct rgt__addNode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgt__getParentNode(struct soap *soap, const struct rgt__getParentNode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgt__getParentNode(struct soap *soap, struct rgt__getParentNode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgt__getParentNode(struct soap *soap, const struct rgt__getParentNode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgt__getParentNode);
	if (soap_out_rgt__getParentNode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgt__getParentNode(struct soap *soap, const char *tag, int id, const struct rgt__getParentNode *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__getParentNode), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgt__getParentNode * SOAP_FMAC4 soap_get_rgt__getParentNode(struct soap *soap, struct rgt__getParentNode *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__getParentNode(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__getParentNode * SOAP_FMAC4 soap_in_rgt__getParentNode(struct soap *soap, const char *tag, struct rgt__getParentNode *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgt__getParentNode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getParentNode, sizeof(struct rgt__getParentNode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgt__getParentNode(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgt__getParentNode *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgt__getParentNode, 0, sizeof(struct rgt__getParentNode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgt__getCheckPointData(struct soap *soap, const struct rgt__getCheckPointData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgt__getCheckPointData(struct soap *soap, struct rgt__getCheckPointData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgt__getCheckPointData(struct soap *soap, const struct rgt__getCheckPointData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgt__getCheckPointData);
	if (soap_out_rgt__getCheckPointData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgt__getCheckPointData(struct soap *soap, const char *tag, int id, const struct rgt__getCheckPointData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__getCheckPointData), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgt__getCheckPointData * SOAP_FMAC4 soap_get_rgt__getCheckPointData(struct soap *soap, struct rgt__getCheckPointData *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__getCheckPointData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__getCheckPointData * SOAP_FMAC4 soap_in_rgt__getCheckPointData(struct soap *soap, const char *tag, struct rgt__getCheckPointData *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgt__getCheckPointData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getCheckPointData, sizeof(struct rgt__getCheckPointData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgt__getCheckPointData(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgt__getCheckPointData *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgt__getCheckPointData, 0, sizeof(struct rgt__getCheckPointData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgt__requestTerminationBefore(struct soap *soap, const struct rgt__requestTerminationBefore *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgt__requestTerminationBefore(struct soap *soap, struct rgt__requestTerminationBefore *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgt__requestTerminationBefore(struct soap *soap, const struct rgt__requestTerminationBefore *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgt__requestTerminationBefore);
	if (soap_out_rgt__requestTerminationBefore(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgt__requestTerminationBefore(struct soap *soap, const char *tag, int id, const struct rgt__requestTerminationBefore *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__requestTerminationBefore), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgt__requestTerminationBefore * SOAP_FMAC4 soap_get_rgt__requestTerminationBefore(struct soap *soap, struct rgt__requestTerminationBefore *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__requestTerminationBefore(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__requestTerminationBefore * SOAP_FMAC4 soap_in_rgt__requestTerminationBefore(struct soap *soap, const char *tag, struct rgt__requestTerminationBefore *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgt__requestTerminationBefore *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__requestTerminationBefore, sizeof(struct rgt__requestTerminationBefore), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgt__requestTerminationBefore(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgt__requestTerminationBefore *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgt__requestTerminationBefore, 0, sizeof(struct rgt__requestTerminationBefore), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgt__getSteeringCommands(struct soap *soap, const struct rgt__getSteeringCommands *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgt__getSteeringCommands(struct soap *soap, struct rgt__getSteeringCommands *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgt__getSteeringCommands(struct soap *soap, const struct rgt__getSteeringCommands *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgt__getSteeringCommands);
	if (soap_out_rgt__getSteeringCommands(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgt__getSteeringCommands(struct soap *soap, const char *tag, int id, const struct rgt__getSteeringCommands *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__getSteeringCommands), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgt__getSteeringCommands * SOAP_FMAC4 soap_get_rgt__getSteeringCommands(struct soap *soap, struct rgt__getSteeringCommands *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__getSteeringCommands(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__getSteeringCommands * SOAP_FMAC4 soap_in_rgt__getSteeringCommands(struct soap *soap, const char *tag, struct rgt__getSteeringCommands *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgt__getSteeringCommands *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getSteeringCommands, sizeof(struct rgt__getSteeringCommands), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgt__getSteeringCommands(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgt__getSteeringCommands *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgt__getSteeringCommands, 0, sizeof(struct rgt__getSteeringCommands), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgt__destroy(struct soap *soap, const struct rgt__destroy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgt__destroy(struct soap *soap, struct rgt__destroy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgt__destroy(struct soap *soap, const struct rgt__destroy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgt__destroy);
	if (soap_out_rgt__destroy(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgt__destroy(struct soap *soap, const char *tag, int id, const struct rgt__destroy *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__destroy), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgt__destroy * SOAP_FMAC4 soap_get_rgt__destroy(struct soap *soap, struct rgt__destroy *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__destroy(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__destroy * SOAP_FMAC4 soap_in_rgt__destroy(struct soap *soap, const char *tag, struct rgt__destroy *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgt__destroy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__destroy, sizeof(struct rgt__destroy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgt__destroy(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgt__destroy *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgt__destroy, 0, sizeof(struct rgt__destroy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgt__setCheckPointData(struct soap *soap, const struct rgt__setCheckPointData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgt__setCheckPointData(struct soap *soap, struct rgt__setCheckPointData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgt__setCheckPointData(struct soap *soap, const struct rgt__setCheckPointData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgt__setCheckPointData);
	if (soap_out_rgt__setCheckPointData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgt__setCheckPointData(struct soap *soap, const char *tag, int id, const struct rgt__setCheckPointData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__setCheckPointData), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgt__setCheckPointData * SOAP_FMAC4 soap_get_rgt__setCheckPointData(struct soap *soap, struct rgt__setCheckPointData *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__setCheckPointData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__setCheckPointData * SOAP_FMAC4 soap_in_rgt__setCheckPointData(struct soap *soap, const char *tag, struct rgt__setCheckPointData *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgt__setCheckPointData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__setCheckPointData, sizeof(struct rgt__setCheckPointData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgt__setCheckPointData(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgt__setCheckPointData *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgt__setCheckPointData, 0, sizeof(struct rgt__setCheckPointData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgt__findServiceData(struct soap *soap, const struct rgt__findServiceData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgt__findServiceData(struct soap *soap, struct rgt__findServiceData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgt__findServiceData(struct soap *soap, const struct rgt__findServiceData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgt__findServiceData);
	if (soap_out_rgt__findServiceData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgt__findServiceData(struct soap *soap, const char *tag, int id, const struct rgt__findServiceData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__findServiceData), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgt__findServiceData * SOAP_FMAC4 soap_get_rgt__findServiceData(struct soap *soap, struct rgt__findServiceData *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__findServiceData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__findServiceData * SOAP_FMAC4 soap_in_rgt__findServiceData(struct soap *soap, const char *tag, struct rgt__findServiceData *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgt__findServiceData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__findServiceData, sizeof(struct rgt__findServiceData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgt__findServiceData(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgt__findServiceData *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgt__findServiceData, 0, sizeof(struct rgt__findServiceData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgt__getInputFile(struct soap *soap, const struct rgt__getInputFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgt__getInputFile(struct soap *soap, struct rgt__getInputFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgt__getInputFile(struct soap *soap, const struct rgt__getInputFile *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgt__getInputFile);
	if (soap_out_rgt__getInputFile(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgt__getInputFile(struct soap *soap, const char *tag, int id, const struct rgt__getInputFile *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__getInputFile), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgt__getInputFile * SOAP_FMAC4 soap_get_rgt__getInputFile(struct soap *soap, struct rgt__getInputFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__getInputFile(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__getInputFile * SOAP_FMAC4 soap_in_rgt__getInputFile(struct soap *soap, const char *tag, struct rgt__getInputFile *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgt__getInputFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getInputFile, sizeof(struct rgt__getInputFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgt__getInputFile(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgt__getInputFile *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgt__getInputFile, 0, sizeof(struct rgt__getInputFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgt__getChildNodes(struct soap *soap, const struct rgt__getChildNodes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgt__getChildNodes(struct soap *soap, struct rgt__getChildNodes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgt__getChildNodes(struct soap *soap, const struct rgt__getChildNodes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgt__getChildNodes);
	if (soap_out_rgt__getChildNodes(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgt__getChildNodes(struct soap *soap, const char *tag, int id, const struct rgt__getChildNodes *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__getChildNodes), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgt__getChildNodes * SOAP_FMAC4 soap_get_rgt__getChildNodes(struct soap *soap, struct rgt__getChildNodes *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__getChildNodes(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__getChildNodes * SOAP_FMAC4 soap_in_rgt__getChildNodes(struct soap *soap, const char *tag, struct rgt__getChildNodes *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgt__getChildNodes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getChildNodes, sizeof(struct rgt__getChildNodes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgt__getChildNodes(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgt__getChildNodes *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgt__getChildNodes, 0, sizeof(struct rgt__getChildNodes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgt__requestTerminationAfter(struct soap *soap, const struct rgt__requestTerminationAfter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgt__requestTerminationAfter(struct soap *soap, struct rgt__requestTerminationAfter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgt__requestTerminationAfter(struct soap *soap, const struct rgt__requestTerminationAfter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgt__requestTerminationAfter);
	if (soap_out_rgt__requestTerminationAfter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgt__requestTerminationAfter(struct soap *soap, const char *tag, int id, const struct rgt__requestTerminationAfter *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__requestTerminationAfter), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgt__requestTerminationAfter * SOAP_FMAC4 soap_get_rgt__requestTerminationAfter(struct soap *soap, struct rgt__requestTerminationAfter *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__requestTerminationAfter(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__requestTerminationAfter * SOAP_FMAC4 soap_in_rgt__requestTerminationAfter(struct soap *soap, const char *tag, struct rgt__requestTerminationAfter *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgt__requestTerminationAfter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__requestTerminationAfter, sizeof(struct rgt__requestTerminationAfter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgt__requestTerminationAfter(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgt__requestTerminationAfter *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgt__requestTerminationAfter, 0, sizeof(struct rgt__requestTerminationAfter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgt__destroyResponse(struct soap *soap, const struct rgt__destroyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgt__destroyResponse(struct soap *soap, struct rgt__destroyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgt__destroyResponse(struct soap *soap, const struct rgt__destroyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgt__destroyResponse);
	if (soap_out_rgt__destroyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgt__destroyResponse(struct soap *soap, const char *tag, int id, const struct rgt__destroyResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__destroyResponse), type);
	if (a->_)
		soap_element_result(soap, "");
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgt__destroyResponse * SOAP_FMAC4 soap_get_rgt__destroyResponse(struct soap *soap, struct rgt__destroyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__destroyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__destroyResponse * SOAP_FMAC4 soap_in_rgt__destroyResponse(struct soap *soap, const char *tag, struct rgt__destroyResponse *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgt__destroyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__destroyResponse, sizeof(struct rgt__destroyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgt__destroyResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgt__destroyResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgt__destroyResponse, 0, sizeof(struct rgt__destroyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgt__getInputFileResponse(struct soap *soap, const struct rgt__getInputFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_getInputFileReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_getInputFileReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgt__getInputFileResponse(struct soap *soap, struct rgt__getInputFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_getInputFileReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgt__getInputFileResponse(struct soap *soap, const struct rgt__getInputFileResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgt__getInputFileResponse);
	if (soap_out_rgt__getInputFileResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgt__getInputFileResponse(struct soap *soap, const char *tag, int id, const struct rgt__getInputFileResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__getInputFileResponse), type);
	if (a->_getInputFileReturn)
		soap_element_result(soap, "getInputFileReturn");
	soap_out_xsd__string(soap, "getInputFileReturn", -1, &a->_getInputFileReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgt__getInputFileResponse * SOAP_FMAC4 soap_get_rgt__getInputFileResponse(struct soap *soap, struct rgt__getInputFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__getInputFileResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__getInputFileResponse * SOAP_FMAC4 soap_in_rgt__getInputFileResponse(struct soap *soap, const char *tag, struct rgt__getInputFileResponse *a, const char *type)
{
	short soap_flag__getInputFileReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgt__getInputFileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getInputFileResponse, sizeof(struct rgt__getInputFileResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgt__getInputFileResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getInputFileReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_getInputFileReturn, "xsd:string"))
				{	soap_flag__getInputFileReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgt__getInputFileResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgt__getInputFileResponse, 0, sizeof(struct rgt__getInputFileResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgt__getSteeringCommandsResponse(struct soap *soap, const struct rgt__getSteeringCommandsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_getSteeringCommandsReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_getSteeringCommandsReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgt__getSteeringCommandsResponse(struct soap *soap, struct rgt__getSteeringCommandsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_getSteeringCommandsReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgt__getSteeringCommandsResponse(struct soap *soap, const struct rgt__getSteeringCommandsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgt__getSteeringCommandsResponse);
	if (soap_out_rgt__getSteeringCommandsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgt__getSteeringCommandsResponse(struct soap *soap, const char *tag, int id, const struct rgt__getSteeringCommandsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__getSteeringCommandsResponse), type);
	if (a->_getSteeringCommandsReturn)
		soap_element_result(soap, "getSteeringCommandsReturn");
	soap_out_xsd__string(soap, "getSteeringCommandsReturn", -1, &a->_getSteeringCommandsReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgt__getSteeringCommandsResponse * SOAP_FMAC4 soap_get_rgt__getSteeringCommandsResponse(struct soap *soap, struct rgt__getSteeringCommandsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__getSteeringCommandsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__getSteeringCommandsResponse * SOAP_FMAC4 soap_in_rgt__getSteeringCommandsResponse(struct soap *soap, const char *tag, struct rgt__getSteeringCommandsResponse *a, const char *type)
{
	short soap_flag__getSteeringCommandsReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgt__getSteeringCommandsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getSteeringCommandsResponse, sizeof(struct rgt__getSteeringCommandsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgt__getSteeringCommandsResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getSteeringCommandsReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_getSteeringCommandsReturn, "xsd:string"))
				{	soap_flag__getSteeringCommandsReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgt__getSteeringCommandsResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgt__getSteeringCommandsResponse, 0, sizeof(struct rgt__getSteeringCommandsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgt__requestTerminationBeforeResponse(struct soap *soap, const struct rgt__requestTerminationBeforeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_requestTerminationBeforeReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_requestTerminationBeforeReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgt__requestTerminationBeforeResponse(struct soap *soap, struct rgt__requestTerminationBeforeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_requestTerminationBeforeReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgt__requestTerminationBeforeResponse(struct soap *soap, const struct rgt__requestTerminationBeforeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgt__requestTerminationBeforeResponse);
	if (soap_out_rgt__requestTerminationBeforeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgt__requestTerminationBeforeResponse(struct soap *soap, const char *tag, int id, const struct rgt__requestTerminationBeforeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__requestTerminationBeforeResponse), type);
	if (a->_requestTerminationBeforeReturn)
		soap_element_result(soap, "requestTerminationBeforeReturn");
	soap_out_xsd__string(soap, "requestTerminationBeforeReturn", -1, &a->_requestTerminationBeforeReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgt__requestTerminationBeforeResponse * SOAP_FMAC4 soap_get_rgt__requestTerminationBeforeResponse(struct soap *soap, struct rgt__requestTerminationBeforeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__requestTerminationBeforeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__requestTerminationBeforeResponse * SOAP_FMAC4 soap_in_rgt__requestTerminationBeforeResponse(struct soap *soap, const char *tag, struct rgt__requestTerminationBeforeResponse *a, const char *type)
{
	short soap_flag__requestTerminationBeforeReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgt__requestTerminationBeforeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__requestTerminationBeforeResponse, sizeof(struct rgt__requestTerminationBeforeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgt__requestTerminationBeforeResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__requestTerminationBeforeReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_requestTerminationBeforeReturn, "xsd:string"))
				{	soap_flag__requestTerminationBeforeReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgt__requestTerminationBeforeResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgt__requestTerminationBeforeResponse, 0, sizeof(struct rgt__requestTerminationBeforeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgt__getChildNodesResponse(struct soap *soap, const struct rgt__getChildNodesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_getChildNodesReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_getChildNodesReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgt__getChildNodesResponse(struct soap *soap, struct rgt__getChildNodesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_getChildNodesReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgt__getChildNodesResponse(struct soap *soap, const struct rgt__getChildNodesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgt__getChildNodesResponse);
	if (soap_out_rgt__getChildNodesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgt__getChildNodesResponse(struct soap *soap, const char *tag, int id, const struct rgt__getChildNodesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__getChildNodesResponse), type);
	if (a->_getChildNodesReturn)
		soap_element_result(soap, "getChildNodesReturn");
	soap_out_xsd__string(soap, "getChildNodesReturn", -1, &a->_getChildNodesReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgt__getChildNodesResponse * SOAP_FMAC4 soap_get_rgt__getChildNodesResponse(struct soap *soap, struct rgt__getChildNodesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__getChildNodesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__getChildNodesResponse * SOAP_FMAC4 soap_in_rgt__getChildNodesResponse(struct soap *soap, const char *tag, struct rgt__getChildNodesResponse *a, const char *type)
{
	short soap_flag__getChildNodesReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgt__getChildNodesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getChildNodesResponse, sizeof(struct rgt__getChildNodesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgt__getChildNodesResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getChildNodesReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_getChildNodesReturn, "xsd:string"))
				{	soap_flag__getChildNodesReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgt__getChildNodesResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgt__getChildNodesResponse, 0, sizeof(struct rgt__getChildNodesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgt__setCheckPointDataResponse(struct soap *soap, const struct rgt__setCheckPointDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgt__setCheckPointDataResponse(struct soap *soap, struct rgt__setCheckPointDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgt__setCheckPointDataResponse(struct soap *soap, const struct rgt__setCheckPointDataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgt__setCheckPointDataResponse);
	if (soap_out_rgt__setCheckPointDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgt__setCheckPointDataResponse(struct soap *soap, const char *tag, int id, const struct rgt__setCheckPointDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__setCheckPointDataResponse), type);
	if (a->_)
		soap_element_result(soap, "");
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgt__setCheckPointDataResponse * SOAP_FMAC4 soap_get_rgt__setCheckPointDataResponse(struct soap *soap, struct rgt__setCheckPointDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__setCheckPointDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__setCheckPointDataResponse * SOAP_FMAC4 soap_in_rgt__setCheckPointDataResponse(struct soap *soap, const char *tag, struct rgt__setCheckPointDataResponse *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgt__setCheckPointDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__setCheckPointDataResponse, sizeof(struct rgt__setCheckPointDataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgt__setCheckPointDataResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgt__setCheckPointDataResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgt__setCheckPointDataResponse, 0, sizeof(struct rgt__setCheckPointDataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgt__findServiceDataResponse(struct soap *soap, const struct rgt__findServiceDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_findServiceDataReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_findServiceDataReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgt__findServiceDataResponse(struct soap *soap, struct rgt__findServiceDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_findServiceDataReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgt__findServiceDataResponse(struct soap *soap, const struct rgt__findServiceDataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgt__findServiceDataResponse);
	if (soap_out_rgt__findServiceDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgt__findServiceDataResponse(struct soap *soap, const char *tag, int id, const struct rgt__findServiceDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__findServiceDataResponse), type);
	if (a->_findServiceDataReturn)
		soap_element_result(soap, "findServiceDataReturn");
	soap_out_xsd__string(soap, "findServiceDataReturn", -1, &a->_findServiceDataReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgt__findServiceDataResponse * SOAP_FMAC4 soap_get_rgt__findServiceDataResponse(struct soap *soap, struct rgt__findServiceDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__findServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__findServiceDataResponse * SOAP_FMAC4 soap_in_rgt__findServiceDataResponse(struct soap *soap, const char *tag, struct rgt__findServiceDataResponse *a, const char *type)
{
	short soap_flag__findServiceDataReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgt__findServiceDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__findServiceDataResponse, sizeof(struct rgt__findServiceDataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgt__findServiceDataResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__findServiceDataReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_findServiceDataReturn, "xsd:string"))
				{	soap_flag__findServiceDataReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgt__findServiceDataResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgt__findServiceDataResponse, 0, sizeof(struct rgt__findServiceDataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgt__getCheckPointDataResponse(struct soap *soap, const struct rgt__getCheckPointDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_getCheckPointDataReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_getCheckPointDataReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgt__getCheckPointDataResponse(struct soap *soap, struct rgt__getCheckPointDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_getCheckPointDataReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgt__getCheckPointDataResponse(struct soap *soap, const struct rgt__getCheckPointDataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgt__getCheckPointDataResponse);
	if (soap_out_rgt__getCheckPointDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgt__getCheckPointDataResponse(struct soap *soap, const char *tag, int id, const struct rgt__getCheckPointDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__getCheckPointDataResponse), type);
	if (a->_getCheckPointDataReturn)
		soap_element_result(soap, "getCheckPointDataReturn");
	soap_out_xsd__string(soap, "getCheckPointDataReturn", -1, &a->_getCheckPointDataReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgt__getCheckPointDataResponse * SOAP_FMAC4 soap_get_rgt__getCheckPointDataResponse(struct soap *soap, struct rgt__getCheckPointDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__getCheckPointDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__getCheckPointDataResponse * SOAP_FMAC4 soap_in_rgt__getCheckPointDataResponse(struct soap *soap, const char *tag, struct rgt__getCheckPointDataResponse *a, const char *type)
{
	short soap_flag__getCheckPointDataReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgt__getCheckPointDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getCheckPointDataResponse, sizeof(struct rgt__getCheckPointDataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgt__getCheckPointDataResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getCheckPointDataReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_getCheckPointDataReturn, "xsd:string"))
				{	soap_flag__getCheckPointDataReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgt__getCheckPointDataResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgt__getCheckPointDataResponse, 0, sizeof(struct rgt__getCheckPointDataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgt__addNodeResponse(struct soap *soap, const struct rgt__addNodeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_addNodeReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_addNodeReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgt__addNodeResponse(struct soap *soap, struct rgt__addNodeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_addNodeReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgt__addNodeResponse(struct soap *soap, const struct rgt__addNodeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgt__addNodeResponse);
	if (soap_out_rgt__addNodeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgt__addNodeResponse(struct soap *soap, const char *tag, int id, const struct rgt__addNodeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__addNodeResponse), type);
	if (a->_addNodeReturn)
		soap_element_result(soap, "addNodeReturn");
	soap_out_xsd__string(soap, "addNodeReturn", -1, &a->_addNodeReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgt__addNodeResponse * SOAP_FMAC4 soap_get_rgt__addNodeResponse(struct soap *soap, struct rgt__addNodeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__addNodeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__addNodeResponse * SOAP_FMAC4 soap_in_rgt__addNodeResponse(struct soap *soap, const char *tag, struct rgt__addNodeResponse *a, const char *type)
{
	short soap_flag__addNodeReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgt__addNodeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__addNodeResponse, sizeof(struct rgt__addNodeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgt__addNodeResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__addNodeReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_addNodeReturn, "xsd:string"))
				{	soap_flag__addNodeReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgt__addNodeResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgt__addNodeResponse, 0, sizeof(struct rgt__addNodeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgt__requestTerminationAfterResponse(struct soap *soap, const struct rgt__requestTerminationAfterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_requestTerminationAfterReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_requestTerminationAfterReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgt__requestTerminationAfterResponse(struct soap *soap, struct rgt__requestTerminationAfterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_requestTerminationAfterReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgt__requestTerminationAfterResponse(struct soap *soap, const struct rgt__requestTerminationAfterResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgt__requestTerminationAfterResponse);
	if (soap_out_rgt__requestTerminationAfterResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgt__requestTerminationAfterResponse(struct soap *soap, const char *tag, int id, const struct rgt__requestTerminationAfterResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__requestTerminationAfterResponse), type);
	if (a->_requestTerminationAfterReturn)
		soap_element_result(soap, "requestTerminationAfterReturn");
	soap_out_xsd__string(soap, "requestTerminationAfterReturn", -1, &a->_requestTerminationAfterReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgt__requestTerminationAfterResponse * SOAP_FMAC4 soap_get_rgt__requestTerminationAfterResponse(struct soap *soap, struct rgt__requestTerminationAfterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__requestTerminationAfterResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__requestTerminationAfterResponse * SOAP_FMAC4 soap_in_rgt__requestTerminationAfterResponse(struct soap *soap, const char *tag, struct rgt__requestTerminationAfterResponse *a, const char *type)
{
	short soap_flag__requestTerminationAfterReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgt__requestTerminationAfterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__requestTerminationAfterResponse, sizeof(struct rgt__requestTerminationAfterResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgt__requestTerminationAfterResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__requestTerminationAfterReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_requestTerminationAfterReturn, "xsd:string"))
				{	soap_flag__requestTerminationAfterReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgt__requestTerminationAfterResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgt__requestTerminationAfterResponse, 0, sizeof(struct rgt__requestTerminationAfterResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgt__getParentNodeResponse(struct soap *soap, const struct rgt__getParentNodeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_getParentNodeReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_getParentNodeReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgt__getParentNodeResponse(struct soap *soap, struct rgt__getParentNodeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_getParentNodeReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgt__getParentNodeResponse(struct soap *soap, const struct rgt__getParentNodeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgt__getParentNodeResponse);
	if (soap_out_rgt__getParentNodeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgt__getParentNodeResponse(struct soap *soap, const char *tag, int id, const struct rgt__getParentNodeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__getParentNodeResponse), type);
	if (a->_getParentNodeReturn)
		soap_element_result(soap, "getParentNodeReturn");
	soap_out_xsd__string(soap, "getParentNodeReturn", -1, &a->_getParentNodeReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgt__getParentNodeResponse * SOAP_FMAC4 soap_get_rgt__getParentNodeResponse(struct soap *soap, struct rgt__getParentNodeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__getParentNodeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__getParentNodeResponse * SOAP_FMAC4 soap_in_rgt__getParentNodeResponse(struct soap *soap, const char *tag, struct rgt__getParentNodeResponse *a, const char *type)
{
	short soap_flag__getParentNodeReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgt__getParentNodeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getParentNodeResponse, sizeof(struct rgt__getParentNodeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgt__getParentNodeResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getParentNodeReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_getParentNodeReturn, "xsd:string"))
				{	soap_flag__getParentNodeReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgt__getParentNodeResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgt__getParentNodeResponse, 0, sizeof(struct rgt__getParentNodeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgtf__requestTerminationAfter(struct soap *soap, const struct rgtf__requestTerminationAfter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgtf__requestTerminationAfter(struct soap *soap, struct rgtf__requestTerminationAfter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgtf__requestTerminationAfter(struct soap *soap, const struct rgtf__requestTerminationAfter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgtf__requestTerminationAfter);
	if (soap_out_rgtf__requestTerminationAfter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgtf__requestTerminationAfter(struct soap *soap, const char *tag, int id, const struct rgtf__requestTerminationAfter *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__requestTerminationAfter), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgtf__requestTerminationAfter * SOAP_FMAC4 soap_get_rgtf__requestTerminationAfter(struct soap *soap, struct rgtf__requestTerminationAfter *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__requestTerminationAfter(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgtf__requestTerminationAfter * SOAP_FMAC4 soap_in_rgtf__requestTerminationAfter(struct soap *soap, const char *tag, struct rgtf__requestTerminationAfter *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgtf__requestTerminationAfter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__requestTerminationAfter, sizeof(struct rgtf__requestTerminationAfter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgtf__requestTerminationAfter(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgtf__requestTerminationAfter *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgtf__requestTerminationAfter, 0, sizeof(struct rgtf__requestTerminationAfter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgtf__requestTerminationBefore(struct soap *soap, const struct rgtf__requestTerminationBefore *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgtf__requestTerminationBefore(struct soap *soap, struct rgtf__requestTerminationBefore *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgtf__requestTerminationBefore(struct soap *soap, const struct rgtf__requestTerminationBefore *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgtf__requestTerminationBefore);
	if (soap_out_rgtf__requestTerminationBefore(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgtf__requestTerminationBefore(struct soap *soap, const char *tag, int id, const struct rgtf__requestTerminationBefore *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__requestTerminationBefore), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgtf__requestTerminationBefore * SOAP_FMAC4 soap_get_rgtf__requestTerminationBefore(struct soap *soap, struct rgtf__requestTerminationBefore *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__requestTerminationBefore(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgtf__requestTerminationBefore * SOAP_FMAC4 soap_in_rgtf__requestTerminationBefore(struct soap *soap, const char *tag, struct rgtf__requestTerminationBefore *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgtf__requestTerminationBefore *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__requestTerminationBefore, sizeof(struct rgtf__requestTerminationBefore), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgtf__requestTerminationBefore(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgtf__requestTerminationBefore *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgtf__requestTerminationBefore, 0, sizeof(struct rgtf__requestTerminationBefore), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgtf__getActiveTrees(struct soap *soap, const struct rgtf__getActiveTrees *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgtf__getActiveTrees(struct soap *soap, struct rgtf__getActiveTrees *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgtf__getActiveTrees(struct soap *soap, const struct rgtf__getActiveTrees *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgtf__getActiveTrees);
	if (soap_out_rgtf__getActiveTrees(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgtf__getActiveTrees(struct soap *soap, const char *tag, int id, const struct rgtf__getActiveTrees *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__getActiveTrees), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgtf__getActiveTrees * SOAP_FMAC4 soap_get_rgtf__getActiveTrees(struct soap *soap, struct rgtf__getActiveTrees *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__getActiveTrees(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgtf__getActiveTrees * SOAP_FMAC4 soap_in_rgtf__getActiveTrees(struct soap *soap, const char *tag, struct rgtf__getActiveTrees *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgtf__getActiveTrees *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__getActiveTrees, sizeof(struct rgtf__getActiveTrees), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgtf__getActiveTrees(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgtf__getActiveTrees *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgtf__getActiveTrees, 0, sizeof(struct rgtf__getActiveTrees), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgtf__findServiceData(struct soap *soap, const struct rgtf__findServiceData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgtf__findServiceData(struct soap *soap, struct rgtf__findServiceData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgtf__findServiceData(struct soap *soap, const struct rgtf__findServiceData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgtf__findServiceData);
	if (soap_out_rgtf__findServiceData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgtf__findServiceData(struct soap *soap, const char *tag, int id, const struct rgtf__findServiceData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__findServiceData), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgtf__findServiceData * SOAP_FMAC4 soap_get_rgtf__findServiceData(struct soap *soap, struct rgtf__findServiceData *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__findServiceData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgtf__findServiceData * SOAP_FMAC4 soap_in_rgtf__findServiceData(struct soap *soap, const char *tag, struct rgtf__findServiceData *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgtf__findServiceData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__findServiceData, sizeof(struct rgtf__findServiceData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgtf__findServiceData(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgtf__findServiceData *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgtf__findServiceData, 0, sizeof(struct rgtf__findServiceData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgtf__destroy(struct soap *soap, const struct rgtf__destroy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgtf__destroy(struct soap *soap, struct rgtf__destroy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgtf__destroy(struct soap *soap, const struct rgtf__destroy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgtf__destroy);
	if (soap_out_rgtf__destroy(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgtf__destroy(struct soap *soap, const char *tag, int id, const struct rgtf__destroy *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__destroy), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgtf__destroy * SOAP_FMAC4 soap_get_rgtf__destroy(struct soap *soap, struct rgtf__destroy *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__destroy(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgtf__destroy * SOAP_FMAC4 soap_in_rgtf__destroy(struct soap *soap, const char *tag, struct rgtf__destroy *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgtf__destroy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__destroy, sizeof(struct rgtf__destroy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgtf__destroy(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgtf__destroy *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgtf__destroy, 0, sizeof(struct rgtf__destroy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgtf__findByHandle(struct soap *soap, const struct rgtf__findByHandle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in0);
	soap_embedded(soap, &a->in1, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgtf__findByHandle(struct soap *soap, struct rgtf__findByHandle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
	soap_default_xsd__string(soap, &a->in1);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgtf__findByHandle(struct soap *soap, const struct rgtf__findByHandle *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgtf__findByHandle);
	if (soap_out_rgtf__findByHandle(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgtf__findByHandle(struct soap *soap, const char *tag, int id, const struct rgtf__findByHandle *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__findByHandle), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "");
	soap_out_xsd__string(soap, "in1", -1, &a->in1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgtf__findByHandle * SOAP_FMAC4 soap_get_rgtf__findByHandle(struct soap *soap, struct rgtf__findByHandle *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__findByHandle(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgtf__findByHandle * SOAP_FMAC4 soap_in_rgtf__findByHandle(struct soap *soap, const char *tag, struct rgtf__findByHandle *a, const char *type)
{
	short soap_flag_in0 = 1, soap_flag_in1 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgtf__findByHandle *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__findByHandle, sizeof(struct rgtf__findByHandle), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgtf__findByHandle(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap_flag_in1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in1", &a->in1, "xsd:string"))
				{	soap_flag_in1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgtf__findByHandle *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgtf__findByHandle, 0, sizeof(struct rgtf__findByHandle), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgtf__createNewTree(struct soap *soap, const struct rgtf__createNewTree *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in0);
	soap_embedded(soap, &a->in1, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in1);
	soap_embedded(soap, &a->in2, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in2);
	soap_embedded(soap, &a->in3, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in3);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgtf__createNewTree(struct soap *soap, struct rgtf__createNewTree *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
	soap_default_xsd__string(soap, &a->in1);
	soap_default_xsd__string(soap, &a->in2);
	soap_default_xsd__string(soap, &a->in3);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgtf__createNewTree(struct soap *soap, const struct rgtf__createNewTree *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgtf__createNewTree);
	if (soap_out_rgtf__createNewTree(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgtf__createNewTree(struct soap *soap, const char *tag, int id, const struct rgtf__createNewTree *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__createNewTree), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "");
	soap_out_xsd__string(soap, "in1", -1, &a->in1, "");
	soap_out_xsd__string(soap, "in2", -1, &a->in2, "");
	soap_out_xsd__string(soap, "in3", -1, &a->in3, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgtf__createNewTree * SOAP_FMAC4 soap_get_rgtf__createNewTree(struct soap *soap, struct rgtf__createNewTree *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__createNewTree(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgtf__createNewTree * SOAP_FMAC4 soap_in_rgtf__createNewTree(struct soap *soap, const char *tag, struct rgtf__createNewTree *a, const char *type)
{
	short soap_flag_in0 = 1, soap_flag_in1 = 1, soap_flag_in2 = 1, soap_flag_in3 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgtf__createNewTree *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__createNewTree, sizeof(struct rgtf__createNewTree), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgtf__createNewTree(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap_flag_in1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in1", &a->in1, "xsd:string"))
				{	soap_flag_in1 = 0;
					continue;
				}
			if (soap_flag_in2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in2", &a->in2, "xsd:string"))
				{	soap_flag_in2 = 0;
					continue;
				}
			if (soap_flag_in3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in3", &a->in3, "xsd:string"))
				{	soap_flag_in3 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgtf__createNewTree *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgtf__createNewTree, 0, sizeof(struct rgtf__createNewTree), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgtf__destroyResponse(struct soap *soap, const struct rgtf__destroyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgtf__destroyResponse(struct soap *soap, struct rgtf__destroyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgtf__destroyResponse(struct soap *soap, const struct rgtf__destroyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgtf__destroyResponse);
	if (soap_out_rgtf__destroyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgtf__destroyResponse(struct soap *soap, const char *tag, int id, const struct rgtf__destroyResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__destroyResponse), type);
	if (a->_)
		soap_element_result(soap, "");
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgtf__destroyResponse * SOAP_FMAC4 soap_get_rgtf__destroyResponse(struct soap *soap, struct rgtf__destroyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__destroyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgtf__destroyResponse * SOAP_FMAC4 soap_in_rgtf__destroyResponse(struct soap *soap, const char *tag, struct rgtf__destroyResponse *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgtf__destroyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__destroyResponse, sizeof(struct rgtf__destroyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgtf__destroyResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgtf__destroyResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgtf__destroyResponse, 0, sizeof(struct rgtf__destroyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgtf__requestTerminationAfterResponse(struct soap *soap, const struct rgtf__requestTerminationAfterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_requestTerminationAfterReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_requestTerminationAfterReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgtf__requestTerminationAfterResponse(struct soap *soap, struct rgtf__requestTerminationAfterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_requestTerminationAfterReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgtf__requestTerminationAfterResponse(struct soap *soap, const struct rgtf__requestTerminationAfterResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgtf__requestTerminationAfterResponse);
	if (soap_out_rgtf__requestTerminationAfterResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgtf__requestTerminationAfterResponse(struct soap *soap, const char *tag, int id, const struct rgtf__requestTerminationAfterResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__requestTerminationAfterResponse), type);
	if (a->_requestTerminationAfterReturn)
		soap_element_result(soap, "requestTerminationAfterReturn");
	soap_out_xsd__string(soap, "requestTerminationAfterReturn", -1, &a->_requestTerminationAfterReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgtf__requestTerminationAfterResponse * SOAP_FMAC4 soap_get_rgtf__requestTerminationAfterResponse(struct soap *soap, struct rgtf__requestTerminationAfterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__requestTerminationAfterResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgtf__requestTerminationAfterResponse * SOAP_FMAC4 soap_in_rgtf__requestTerminationAfterResponse(struct soap *soap, const char *tag, struct rgtf__requestTerminationAfterResponse *a, const char *type)
{
	short soap_flag__requestTerminationAfterReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgtf__requestTerminationAfterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__requestTerminationAfterResponse, sizeof(struct rgtf__requestTerminationAfterResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgtf__requestTerminationAfterResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__requestTerminationAfterReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_requestTerminationAfterReturn, "xsd:string"))
				{	soap_flag__requestTerminationAfterReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgtf__requestTerminationAfterResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgtf__requestTerminationAfterResponse, 0, sizeof(struct rgtf__requestTerminationAfterResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgtf__createNewTreeResponse(struct soap *soap, const struct rgtf__createNewTreeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_createNewTreeReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_createNewTreeReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgtf__createNewTreeResponse(struct soap *soap, struct rgtf__createNewTreeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_createNewTreeReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgtf__createNewTreeResponse(struct soap *soap, const struct rgtf__createNewTreeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgtf__createNewTreeResponse);
	if (soap_out_rgtf__createNewTreeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgtf__createNewTreeResponse(struct soap *soap, const char *tag, int id, const struct rgtf__createNewTreeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__createNewTreeResponse), type);
	if (a->_createNewTreeReturn)
		soap_element_result(soap, "createNewTreeReturn");
	soap_out_xsd__string(soap, "createNewTreeReturn", -1, &a->_createNewTreeReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgtf__createNewTreeResponse * SOAP_FMAC4 soap_get_rgtf__createNewTreeResponse(struct soap *soap, struct rgtf__createNewTreeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__createNewTreeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgtf__createNewTreeResponse * SOAP_FMAC4 soap_in_rgtf__createNewTreeResponse(struct soap *soap, const char *tag, struct rgtf__createNewTreeResponse *a, const char *type)
{
	short soap_flag__createNewTreeReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgtf__createNewTreeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__createNewTreeResponse, sizeof(struct rgtf__createNewTreeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgtf__createNewTreeResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__createNewTreeReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_createNewTreeReturn, "xsd:string"))
				{	soap_flag__createNewTreeReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgtf__createNewTreeResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgtf__createNewTreeResponse, 0, sizeof(struct rgtf__createNewTreeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgtf__getActiveTreesResponse(struct soap *soap, const struct rgtf__getActiveTreesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_getActiveTreesReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_getActiveTreesReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgtf__getActiveTreesResponse(struct soap *soap, struct rgtf__getActiveTreesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_getActiveTreesReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgtf__getActiveTreesResponse(struct soap *soap, const struct rgtf__getActiveTreesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgtf__getActiveTreesResponse);
	if (soap_out_rgtf__getActiveTreesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgtf__getActiveTreesResponse(struct soap *soap, const char *tag, int id, const struct rgtf__getActiveTreesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__getActiveTreesResponse), type);
	if (a->_getActiveTreesReturn)
		soap_element_result(soap, "getActiveTreesReturn");
	soap_out_xsd__string(soap, "getActiveTreesReturn", -1, &a->_getActiveTreesReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgtf__getActiveTreesResponse * SOAP_FMAC4 soap_get_rgtf__getActiveTreesResponse(struct soap *soap, struct rgtf__getActiveTreesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__getActiveTreesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgtf__getActiveTreesResponse * SOAP_FMAC4 soap_in_rgtf__getActiveTreesResponse(struct soap *soap, const char *tag, struct rgtf__getActiveTreesResponse *a, const char *type)
{
	short soap_flag__getActiveTreesReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgtf__getActiveTreesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__getActiveTreesResponse, sizeof(struct rgtf__getActiveTreesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgtf__getActiveTreesResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getActiveTreesReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_getActiveTreesReturn, "xsd:string"))
				{	soap_flag__getActiveTreesReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgtf__getActiveTreesResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgtf__getActiveTreesResponse, 0, sizeof(struct rgtf__getActiveTreesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgtf__findByHandleResponse(struct soap *soap, const struct rgtf__findByHandleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_findByHandleReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_findByHandleReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgtf__findByHandleResponse(struct soap *soap, struct rgtf__findByHandleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_findByHandleReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgtf__findByHandleResponse(struct soap *soap, const struct rgtf__findByHandleResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgtf__findByHandleResponse);
	if (soap_out_rgtf__findByHandleResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgtf__findByHandleResponse(struct soap *soap, const char *tag, int id, const struct rgtf__findByHandleResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__findByHandleResponse), type);
	if (a->_findByHandleReturn)
		soap_element_result(soap, "findByHandleReturn");
	soap_out_xsd__string(soap, "findByHandleReturn", -1, &a->_findByHandleReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgtf__findByHandleResponse * SOAP_FMAC4 soap_get_rgtf__findByHandleResponse(struct soap *soap, struct rgtf__findByHandleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__findByHandleResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgtf__findByHandleResponse * SOAP_FMAC4 soap_in_rgtf__findByHandleResponse(struct soap *soap, const char *tag, struct rgtf__findByHandleResponse *a, const char *type)
{
	short soap_flag__findByHandleReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgtf__findByHandleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__findByHandleResponse, sizeof(struct rgtf__findByHandleResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgtf__findByHandleResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__findByHandleReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_findByHandleReturn, "xsd:string"))
				{	soap_flag__findByHandleReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgtf__findByHandleResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgtf__findByHandleResponse, 0, sizeof(struct rgtf__findByHandleResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgtf__findServiceDataResponse(struct soap *soap, const struct rgtf__findServiceDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_findServiceDataReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_findServiceDataReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgtf__findServiceDataResponse(struct soap *soap, struct rgtf__findServiceDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_findServiceDataReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgtf__findServiceDataResponse(struct soap *soap, const struct rgtf__findServiceDataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgtf__findServiceDataResponse);
	if (soap_out_rgtf__findServiceDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgtf__findServiceDataResponse(struct soap *soap, const char *tag, int id, const struct rgtf__findServiceDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__findServiceDataResponse), type);
	if (a->_findServiceDataReturn)
		soap_element_result(soap, "findServiceDataReturn");
	soap_out_xsd__string(soap, "findServiceDataReturn", -1, &a->_findServiceDataReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgtf__findServiceDataResponse * SOAP_FMAC4 soap_get_rgtf__findServiceDataResponse(struct soap *soap, struct rgtf__findServiceDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__findServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgtf__findServiceDataResponse * SOAP_FMAC4 soap_in_rgtf__findServiceDataResponse(struct soap *soap, const char *tag, struct rgtf__findServiceDataResponse *a, const char *type)
{
	short soap_flag__findServiceDataReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgtf__findServiceDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__findServiceDataResponse, sizeof(struct rgtf__findServiceDataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgtf__findServiceDataResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__findServiceDataReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_findServiceDataReturn, "xsd:string"))
				{	soap_flag__findServiceDataReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgtf__findServiceDataResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgtf__findServiceDataResponse, 0, sizeof(struct rgtf__findServiceDataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rgtf__requestTerminationBeforeResponse(struct soap *soap, const struct rgtf__requestTerminationBeforeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_requestTerminationBeforeReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_requestTerminationBeforeReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rgtf__requestTerminationBeforeResponse(struct soap *soap, struct rgtf__requestTerminationBeforeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_requestTerminationBeforeReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rgtf__requestTerminationBeforeResponse(struct soap *soap, const struct rgtf__requestTerminationBeforeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rgtf__requestTerminationBeforeResponse);
	if (soap_out_rgtf__requestTerminationBeforeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rgtf__requestTerminationBeforeResponse(struct soap *soap, const char *tag, int id, const struct rgtf__requestTerminationBeforeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__requestTerminationBeforeResponse), type);
	if (a->_requestTerminationBeforeReturn)
		soap_element_result(soap, "requestTerminationBeforeReturn");
	soap_out_xsd__string(soap, "requestTerminationBeforeReturn", -1, &a->_requestTerminationBeforeReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct rgtf__requestTerminationBeforeResponse * SOAP_FMAC4 soap_get_rgtf__requestTerminationBeforeResponse(struct soap *soap, struct rgtf__requestTerminationBeforeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__requestTerminationBeforeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgtf__requestTerminationBeforeResponse * SOAP_FMAC4 soap_in_rgtf__requestTerminationBeforeResponse(struct soap *soap, const char *tag, struct rgtf__requestTerminationBeforeResponse *a, const char *type)
{
	short soap_flag__requestTerminationBeforeReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct rgtf__requestTerminationBeforeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__requestTerminationBeforeResponse, sizeof(struct rgtf__requestTerminationBeforeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_rgtf__requestTerminationBeforeResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__requestTerminationBeforeReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_requestTerminationBeforeReturn, "xsd:string"))
				{	soap_flag__requestTerminationBeforeReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rgtf__requestTerminationBeforeResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_rgtf__requestTerminationBeforeResponse, 0, sizeof(struct rgtf__requestTerminationBeforeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgr__findServiceData(struct soap *soap, const struct sgr__findServiceData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgr__findServiceData(struct soap *soap, struct sgr__findServiceData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgr__findServiceData(struct soap *soap, const struct sgr__findServiceData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgr__findServiceData);
	if (soap_out_sgr__findServiceData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgr__findServiceData(struct soap *soap, const char *tag, int id, const struct sgr__findServiceData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgr__findServiceData), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgr__findServiceData * SOAP_FMAC4 soap_get_sgr__findServiceData(struct soap *soap, struct sgr__findServiceData *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgr__findServiceData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgr__findServiceData * SOAP_FMAC4 soap_in_sgr__findServiceData(struct soap *soap, const char *tag, struct sgr__findServiceData *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgr__findServiceData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgr__findServiceData, sizeof(struct sgr__findServiceData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgr__findServiceData(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgr__findServiceData *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgr__findServiceData, 0, sizeof(struct sgr__findServiceData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgr__add(struct soap *soap, const struct sgr__add *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in0);
	soap_embedded(soap, &a->in1, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in1);
	soap_embedded(soap, &a->in2, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in2);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgr__add(struct soap *soap, struct sgr__add *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
	soap_default_xsd__string(soap, &a->in1);
	soap_default_xsd__string(soap, &a->in2);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgr__add(struct soap *soap, const struct sgr__add *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgr__add);
	if (soap_out_sgr__add(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgr__add(struct soap *soap, const char *tag, int id, const struct sgr__add *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgr__add), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "");
	soap_out_xsd__string(soap, "in1", -1, &a->in1, "");
	soap_out_xsd__string(soap, "in2", -1, &a->in2, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgr__add * SOAP_FMAC4 soap_get_sgr__add(struct soap *soap, struct sgr__add *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgr__add(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgr__add * SOAP_FMAC4 soap_in_sgr__add(struct soap *soap, const char *tag, struct sgr__add *a, const char *type)
{
	short soap_flag_in0 = 1, soap_flag_in1 = 1, soap_flag_in2 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgr__add *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgr__add, sizeof(struct sgr__add), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgr__add(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap_flag_in1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in1", &a->in1, "xsd:string"))
				{	soap_flag_in1 = 0;
					continue;
				}
			if (soap_flag_in2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in2", &a->in2, "xsd:string"))
				{	soap_flag_in2 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgr__add *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgr__add, 0, sizeof(struct sgr__add), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgr__remove(struct soap *soap, const struct sgr__remove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgr__remove(struct soap *soap, struct sgr__remove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgr__remove(struct soap *soap, const struct sgr__remove *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgr__remove);
	if (soap_out_sgr__remove(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgr__remove(struct soap *soap, const char *tag, int id, const struct sgr__remove *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgr__remove), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgr__remove * SOAP_FMAC4 soap_get_sgr__remove(struct soap *soap, struct sgr__remove *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgr__remove(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgr__remove * SOAP_FMAC4 soap_in_sgr__remove(struct soap *soap, const char *tag, struct sgr__remove *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgr__remove *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgr__remove, sizeof(struct sgr__remove), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgr__remove(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgr__remove *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgr__remove, 0, sizeof(struct sgr__remove), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgr__removeResponse(struct soap *soap, const struct sgr__removeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgr__removeResponse(struct soap *soap, struct sgr__removeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgr__removeResponse(struct soap *soap, const struct sgr__removeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgr__removeResponse);
	if (soap_out_sgr__removeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgr__removeResponse(struct soap *soap, const char *tag, int id, const struct sgr__removeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgr__removeResponse), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgr__removeResponse * SOAP_FMAC4 soap_get_sgr__removeResponse(struct soap *soap, struct sgr__removeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgr__removeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgr__removeResponse * SOAP_FMAC4 soap_in_sgr__removeResponse(struct soap *soap, const char *tag, struct sgr__removeResponse *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgr__removeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgr__removeResponse, sizeof(struct sgr__removeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgr__removeResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgr__removeResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgr__removeResponse, 0, sizeof(struct sgr__removeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOf_USCORE_xsd_USCORE_string(struct soap *soap, struct ArrayOf_USCORE_xsd_USCORE_string const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOf_USCORE_xsd_USCORE_string))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_xsd__string);
			soap_serialize_xsd__string(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOf_USCORE_xsd_USCORE_string(struct soap *soap, struct ArrayOf_USCORE_xsd_USCORE_string *a)
{
	a->__size = 0;
	a->__ptr = NULL;
	a->__offset = 0;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOf_USCORE_xsd_USCORE_string(struct soap *soap, const struct ArrayOf_USCORE_xsd_USCORE_string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOf_USCORE_xsd_USCORE_string);
	if (soap_out_ArrayOf_USCORE_xsd_USCORE_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOf_USCORE_xsd_USCORE_string(struct soap *soap, const char *tag, int id, const struct ArrayOf_USCORE_xsd_USCORE_string *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "xsd:string", n + a->__offset);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCORE_xsd_USCORE_string);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, soap_putoffset(soap, a->__offset));
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_xsd__string(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ArrayOf_USCORE_xsd_USCORE_string * SOAP_FMAC4 soap_get_ArrayOf_USCORE_xsd_USCORE_string(struct soap *soap, struct ArrayOf_USCORE_xsd_USCORE_string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOf_USCORE_xsd_USCORE_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ArrayOf_USCORE_xsd_USCORE_string * SOAP_FMAC4 soap_in_ArrayOf_USCORE_xsd_USCORE_string(struct soap *soap, const char *tag, struct ArrayOf_USCORE_xsd_USCORE_string *a, const char *type)
{	int i, j;
	char **p;
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOf_USCORE_xsd_USCORE_string *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOf_USCORE_xsd_USCORE_string, sizeof(struct ArrayOf_USCORE_xsd_USCORE_string), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_ArrayOf_USCORE_xsd_USCORE_string(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		a->__offset = j;
		if (a->__size >= 0)
		{	a->__ptr = (char **)soap_malloc(soap, sizeof(char *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_xsd__string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (char **)soap_push_block(soap, sizeof(char *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_xsd__string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (char **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 0);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOf_USCORE_xsd_USCORE_string *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCORE_xsd_USCORE_string, 0, sizeof(struct ArrayOf_USCORE_xsd_USCORE_string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgr__addResponse(struct soap *soap, const struct sgr__addResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_addReturn, SOAP_TYPE_PointerToArrayOf_USCORE_xsd_USCORE_string);
	soap_serialize_PointerToArrayOf_USCORE_xsd_USCORE_string(soap, &a->_addReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgr__addResponse(struct soap *soap, struct sgr__addResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_addReturn = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgr__addResponse(struct soap *soap, const struct sgr__addResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgr__addResponse);
	if (soap_out_sgr__addResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgr__addResponse(struct soap *soap, const char *tag, int id, const struct sgr__addResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgr__addResponse), type);
	if (a->_addReturn)
		soap_element_result(soap, "addReturn");
	soap_out_PointerToArrayOf_USCORE_xsd_USCORE_string(soap, "addReturn", -1, &a->_addReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgr__addResponse * SOAP_FMAC4 soap_get_sgr__addResponse(struct soap *soap, struct sgr__addResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgr__addResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgr__addResponse * SOAP_FMAC4 soap_in_sgr__addResponse(struct soap *soap, const char *tag, struct sgr__addResponse *a, const char *type)
{
	short soap_flag__addReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgr__addResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgr__addResponse, sizeof(struct sgr__addResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgr__addResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__addReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCORE_xsd_USCORE_string(soap, NULL, &a->_addReturn, "xsd:string"))
				{	soap_flag__addReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgr__addResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgr__addResponse, 0, sizeof(struct sgr__addResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgr__findServiceDataResponse(struct soap *soap, const struct sgr__findServiceDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_findServiceDataReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_findServiceDataReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgr__findServiceDataResponse(struct soap *soap, struct sgr__findServiceDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_findServiceDataReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgr__findServiceDataResponse(struct soap *soap, const struct sgr__findServiceDataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgr__findServiceDataResponse);
	if (soap_out_sgr__findServiceDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgr__findServiceDataResponse(struct soap *soap, const char *tag, int id, const struct sgr__findServiceDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgr__findServiceDataResponse), type);
	if (a->_findServiceDataReturn)
		soap_element_result(soap, "findServiceDataReturn");
	soap_out_xsd__string(soap, "findServiceDataReturn", -1, &a->_findServiceDataReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgr__findServiceDataResponse * SOAP_FMAC4 soap_get_sgr__findServiceDataResponse(struct soap *soap, struct sgr__findServiceDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgr__findServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgr__findServiceDataResponse * SOAP_FMAC4 soap_in_sgr__findServiceDataResponse(struct soap *soap, const char *tag, struct sgr__findServiceDataResponse *a, const char *type)
{
	short soap_flag__findServiceDataReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgr__findServiceDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgr__findServiceDataResponse, sizeof(struct sgr__findServiceDataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgr__findServiceDataResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__findServiceDataReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_findServiceDataReturn, "xsd:string"))
				{	soap_flag__findServiceDataReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgr__findServiceDataResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgr__findServiceDataResponse, 0, sizeof(struct sgr__findServiceDataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swsf__createSWSResource(struct soap *soap, const struct swsf__createSWSResource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->timeToLive, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &a->registryEPR, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->registryEPR);
	soap_embedded(soap, &a->jobDescription, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->jobDescription);
	soap_embedded(soap, &a->chkpointEPR, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->chkpointEPR);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swsf__createSWSResource(struct soap *soap, struct swsf__createSWSResource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__int(soap, &a->timeToLive);
	soap_default_xsd__string(soap, &a->registryEPR);
	soap_default_xsd__string(soap, &a->jobDescription);
	soap_default_xsd__string(soap, &a->chkpointEPR);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swsf__createSWSResource(struct soap *soap, const struct swsf__createSWSResource *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swsf__createSWSResource);
	if (soap_out_swsf__createSWSResource(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swsf__createSWSResource(struct soap *soap, const char *tag, int id, const struct swsf__createSWSResource *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swsf__createSWSResource), type);
	soap_out_xsd__int(soap, "timeToLive", -1, &a->timeToLive, "");
	soap_out_xsd__string(soap, "registryEPR", -1, &a->registryEPR, "");
	soap_out_xsd__string(soap, "jobDescription", -1, &a->jobDescription, "");
	soap_out_xsd__string(soap, "chkpointEPR", -1, &a->chkpointEPR, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct swsf__createSWSResource * SOAP_FMAC4 soap_get_swsf__createSWSResource(struct soap *soap, struct swsf__createSWSResource *p, const char *tag, const char *type)
{
	if ((p = soap_in_swsf__createSWSResource(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct swsf__createSWSResource * SOAP_FMAC4 soap_in_swsf__createSWSResource(struct soap *soap, const char *tag, struct swsf__createSWSResource *a, const char *type)
{
	short soap_flag_timeToLive = 1, soap_flag_registryEPR = 1, soap_flag_jobDescription = 1, soap_flag_chkpointEPR = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct swsf__createSWSResource *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swsf__createSWSResource, sizeof(struct swsf__createSWSResource), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_swsf__createSWSResource(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timeToLive && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "timeToLive", &a->timeToLive, "xsd:int"))
				{	soap_flag_timeToLive = 0;
					continue;
				}
			if (soap_flag_registryEPR && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "registryEPR", &a->registryEPR, "xsd:string"))
				{	soap_flag_registryEPR = 0;
					continue;
				}
			if (soap_flag_jobDescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "jobDescription", &a->jobDescription, "xsd:string"))
				{	soap_flag_jobDescription = 0;
					continue;
				}
			if (soap_flag_chkpointEPR && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "chkpointEPR", &a->chkpointEPR, "xsd:string"))
				{	soap_flag_chkpointEPR = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_timeToLive))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swsf__createSWSResource *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_swsf__createSWSResource, 0, sizeof(struct swsf__createSWSResource), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swsf__createSWSResourceResponse(struct soap *soap, const struct swsf__createSWSResourceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->wsa__EndpointReference, SOAP_TYPE_epr);
	soap_serialize_epr(soap, &a->wsa__EndpointReference);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swsf__createSWSResourceResponse(struct soap *soap, struct swsf__createSWSResourceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_epr(soap, &a->wsa__EndpointReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swsf__createSWSResourceResponse(struct soap *soap, const struct swsf__createSWSResourceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swsf__createSWSResourceResponse);
	if (soap_out_swsf__createSWSResourceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swsf__createSWSResourceResponse(struct soap *soap, const char *tag, int id, const struct swsf__createSWSResourceResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swsf__createSWSResourceResponse), type);
	soap_element_result(soap, "wsa:EndpointReference");
	soap_out_epr(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct swsf__createSWSResourceResponse * SOAP_FMAC4 soap_get_swsf__createSWSResourceResponse(struct soap *soap, struct swsf__createSWSResourceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_swsf__createSWSResourceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct swsf__createSWSResourceResponse * SOAP_FMAC4 soap_in_swsf__createSWSResourceResponse(struct soap *soap, const char *tag, struct swsf__createSWSResourceResponse *a, const char *type)
{
	short soap_flag_wsa__EndpointReference = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct swsf__createSWSResourceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swsf__createSWSResourceResponse, sizeof(struct swsf__createSWSResourceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_swsf__createSWSResourceResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_epr(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, "epr"))
				{	soap_flag_wsa__EndpointReference = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swsf__createSWSResourceResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_swsf__createSWSResourceResponse, 0, sizeof(struct swsf__createSWSResourceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_epr(struct soap *soap, const struct epr *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->wsa__Address, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->wsa__Address);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_epr(struct soap *soap, struct epr *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->wsa__Address);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_epr(struct soap *soap, const struct epr *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_epr);
	if (soap_out_epr(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_epr(struct soap *soap, const char *tag, int id, const struct epr *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_epr), type);
	soap_out_xsd__string(soap, "wsa:Address", -1, &a->wsa__Address, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct epr * SOAP_FMAC4 soap_get_epr(struct soap *soap, struct epr *p, const char *tag, const char *type)
{
	if ((p = soap_in_epr(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct epr * SOAP_FMAC4 soap_in_epr(struct soap *soap, const char *tag, struct epr *a, const char *type)
{
	short soap_flag_wsa__Address = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct epr *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_epr, sizeof(struct epr), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_epr(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "wsa:Address", &a->wsa__Address, "xsd:string"))
				{	soap_flag_wsa__Address = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct epr *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_epr, 0, sizeof(struct epr), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgsf__createService(struct soap *soap, const struct sgsf__createService *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in0);
	soap_embedded(soap, &a->in1, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgsf__createService(struct soap *soap, struct sgsf__createService *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
	soap_default_xsd__string(soap, &a->in1);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgsf__createService(struct soap *soap, const struct sgsf__createService *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgsf__createService);
	if (soap_out_sgsf__createService(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgsf__createService(struct soap *soap, const char *tag, int id, const struct sgsf__createService *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgsf__createService), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "");
	soap_out_xsd__string(soap, "in1", -1, &a->in1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgsf__createService * SOAP_FMAC4 soap_get_sgsf__createService(struct soap *soap, struct sgsf__createService *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgsf__createService(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgsf__createService * SOAP_FMAC4 soap_in_sgsf__createService(struct soap *soap, const char *tag, struct sgsf__createService *a, const char *type)
{
	short soap_flag_in0 = 1, soap_flag_in1 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgsf__createService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgsf__createService, sizeof(struct sgsf__createService), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgsf__createService(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap_flag_in1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in1", &a->in1, "xsd:string"))
				{	soap_flag_in1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgsf__createService *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgsf__createService, 0, sizeof(struct sgsf__createService), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgsf__destroy(struct soap *soap, const struct sgsf__destroy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgsf__destroy(struct soap *soap, struct sgsf__destroy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgsf__destroy(struct soap *soap, const struct sgsf__destroy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgsf__destroy);
	if (soap_out_sgsf__destroy(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgsf__destroy(struct soap *soap, const char *tag, int id, const struct sgsf__destroy *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgsf__destroy), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgsf__destroy * SOAP_FMAC4 soap_get_sgsf__destroy(struct soap *soap, struct sgsf__destroy *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgsf__destroy(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgsf__destroy * SOAP_FMAC4 soap_in_sgsf__destroy(struct soap *soap, const char *tag, struct sgsf__destroy *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgsf__destroy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgsf__destroy, sizeof(struct sgsf__destroy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgsf__destroy(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgsf__destroy *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgsf__destroy, 0, sizeof(struct sgsf__destroy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgsf__registerSelf(struct soap *soap, const struct sgsf__registerSelf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in0);
	soap_embedded(soap, &a->in1, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgsf__registerSelf(struct soap *soap, struct sgsf__registerSelf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
	soap_default_xsd__string(soap, &a->in1);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgsf__registerSelf(struct soap *soap, const struct sgsf__registerSelf *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgsf__registerSelf);
	if (soap_out_sgsf__registerSelf(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgsf__registerSelf(struct soap *soap, const char *tag, int id, const struct sgsf__registerSelf *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgsf__registerSelf), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "");
	soap_out_xsd__string(soap, "in1", -1, &a->in1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgsf__registerSelf * SOAP_FMAC4 soap_get_sgsf__registerSelf(struct soap *soap, struct sgsf__registerSelf *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgsf__registerSelf(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgsf__registerSelf * SOAP_FMAC4 soap_in_sgsf__registerSelf(struct soap *soap, const char *tag, struct sgsf__registerSelf *a, const char *type)
{
	short soap_flag_in0 = 1, soap_flag_in1 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgsf__registerSelf *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgsf__registerSelf, sizeof(struct sgsf__registerSelf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgsf__registerSelf(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap_flag_in1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in1", &a->in1, "xsd:string"))
				{	soap_flag_in1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgsf__registerSelf *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgsf__registerSelf, 0, sizeof(struct sgsf__registerSelf), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgsf__registerSelfResponse(struct soap *soap, const struct sgsf__registerSelfResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_registerSelfReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_registerSelfReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgsf__registerSelfResponse(struct soap *soap, struct sgsf__registerSelfResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_registerSelfReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgsf__registerSelfResponse(struct soap *soap, const struct sgsf__registerSelfResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgsf__registerSelfResponse);
	if (soap_out_sgsf__registerSelfResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgsf__registerSelfResponse(struct soap *soap, const char *tag, int id, const struct sgsf__registerSelfResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgsf__registerSelfResponse), type);
	if (a->_registerSelfReturn)
		soap_element_result(soap, "registerSelfReturn");
	soap_out_xsd__string(soap, "registerSelfReturn", -1, &a->_registerSelfReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgsf__registerSelfResponse * SOAP_FMAC4 soap_get_sgsf__registerSelfResponse(struct soap *soap, struct sgsf__registerSelfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgsf__registerSelfResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgsf__registerSelfResponse * SOAP_FMAC4 soap_in_sgsf__registerSelfResponse(struct soap *soap, const char *tag, struct sgsf__registerSelfResponse *a, const char *type)
{
	short soap_flag__registerSelfReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgsf__registerSelfResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgsf__registerSelfResponse, sizeof(struct sgsf__registerSelfResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgsf__registerSelfResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__registerSelfReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_registerSelfReturn, "xsd:string"))
				{	soap_flag__registerSelfReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgsf__registerSelfResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgsf__registerSelfResponse, 0, sizeof(struct sgsf__registerSelfResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgsf__destroyResponse(struct soap *soap, const struct sgsf__destroyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgsf__destroyResponse(struct soap *soap, struct sgsf__destroyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgsf__destroyResponse(struct soap *soap, const struct sgsf__destroyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgsf__destroyResponse);
	if (soap_out_sgsf__destroyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgsf__destroyResponse(struct soap *soap, const char *tag, int id, const struct sgsf__destroyResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgsf__destroyResponse), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgsf__destroyResponse * SOAP_FMAC4 soap_get_sgsf__destroyResponse(struct soap *soap, struct sgsf__destroyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgsf__destroyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgsf__destroyResponse * SOAP_FMAC4 soap_in_sgsf__destroyResponse(struct soap *soap, const char *tag, struct sgsf__destroyResponse *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgsf__destroyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgsf__destroyResponse, sizeof(struct sgsf__destroyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgsf__destroyResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgsf__destroyResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgsf__destroyResponse, 0, sizeof(struct sgsf__destroyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgsf__createServiceResponse(struct soap *soap, const struct sgsf__createServiceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_createServiceReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_createServiceReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgsf__createServiceResponse(struct soap *soap, struct sgsf__createServiceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_createServiceReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgsf__createServiceResponse(struct soap *soap, const struct sgsf__createServiceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgsf__createServiceResponse);
	if (soap_out_sgsf__createServiceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgsf__createServiceResponse(struct soap *soap, const char *tag, int id, const struct sgsf__createServiceResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgsf__createServiceResponse), type);
	if (a->_createServiceReturn)
		soap_element_result(soap, "createServiceReturn");
	soap_out_xsd__string(soap, "createServiceReturn", -1, &a->_createServiceReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgsf__createServiceResponse * SOAP_FMAC4 soap_get_sgsf__createServiceResponse(struct soap *soap, struct sgsf__createServiceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgsf__createServiceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgsf__createServiceResponse * SOAP_FMAC4 soap_in_sgsf__createServiceResponse(struct soap *soap, const char *tag, struct sgsf__createServiceResponse *a, const char *type)
{
	short soap_flag__createServiceReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgsf__createServiceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgsf__createServiceResponse, sizeof(struct sgsf__createServiceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgsf__createServiceResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__createServiceReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_createServiceReturn, "xsd:string"))
				{	soap_flag__createServiceReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgsf__createServiceResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgsf__createServiceResponse, 0, sizeof(struct sgsf__createServiceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__AppStop(struct soap *soap, const struct sgs__AppStop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__AppStop(struct soap *soap, struct sgs__AppStop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__AppStop(struct soap *soap, const struct sgs__AppStop *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__AppStop);
	if (soap_out_sgs__AppStop(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__AppStop(struct soap *soap, const char *tag, int id, const struct sgs__AppStop *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__AppStop), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__AppStop * SOAP_FMAC4 soap_get_sgs__AppStop(struct soap *soap, struct sgs__AppStop *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__AppStop(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__AppStop * SOAP_FMAC4 soap_in_sgs__AppStop(struct soap *soap, const char *tag, struct sgs__AppStop *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__AppStop *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppStop, sizeof(struct sgs__AppStop), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__AppStop(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__AppStop *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__AppStop, 0, sizeof(struct sgs__AppStop), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__GetNotifications(struct soap *soap, const struct sgs__GetNotifications *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__GetNotifications(struct soap *soap, struct sgs__GetNotifications *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__GetNotifications(struct soap *soap, const struct sgs__GetNotifications *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__GetNotifications);
	if (soap_out_sgs__GetNotifications(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__GetNotifications(struct soap *soap, const char *tag, int id, const struct sgs__GetNotifications *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__GetNotifications), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__GetNotifications * SOAP_FMAC4 soap_get_sgs__GetNotifications(struct soap *soap, struct sgs__GetNotifications *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__GetNotifications(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__GetNotifications * SOAP_FMAC4 soap_in_sgs__GetNotifications(struct soap *soap, const char *tag, struct sgs__GetNotifications *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__GetNotifications *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetNotifications, sizeof(struct sgs__GetNotifications), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__GetNotifications(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__GetNotifications *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__GetNotifications, 0, sizeof(struct sgs__GetNotifications), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__GetControl(struct soap *soap, const struct sgs__GetControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__GetControl(struct soap *soap, struct sgs__GetControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__GetControl(struct soap *soap, const struct sgs__GetControl *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__GetControl);
	if (soap_out_sgs__GetControl(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__GetControl(struct soap *soap, const char *tag, int id, const struct sgs__GetControl *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__GetControl), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__GetControl * SOAP_FMAC4 soap_get_sgs__GetControl(struct soap *soap, struct sgs__GetControl *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__GetControl(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__GetControl * SOAP_FMAC4 soap_in_sgs__GetControl(struct soap *soap, const char *tag, struct sgs__GetControl *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__GetControl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetControl, sizeof(struct sgs__GetControl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__GetControl(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__GetControl *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__GetControl, 0, sizeof(struct sgs__GetControl), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__destroy(struct soap *soap, const struct sgs__destroy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__destroy(struct soap *soap, struct sgs__destroy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__destroy(struct soap *soap, const struct sgs__destroy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__destroy);
	if (soap_out_sgs__destroy(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__destroy(struct soap *soap, const char *tag, int id, const struct sgs__destroy *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__destroy), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__destroy * SOAP_FMAC4 soap_get_sgs__destroy(struct soap *soap, struct sgs__destroy *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__destroy(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__destroy * SOAP_FMAC4 soap_in_sgs__destroy(struct soap *soap, const char *tag, struct sgs__destroy *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__destroy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__destroy, sizeof(struct sgs__destroy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__destroy(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__destroy *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__destroy, 0, sizeof(struct sgs__destroy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__findServiceData(struct soap *soap, const struct sgs__findServiceData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__findServiceData(struct soap *soap, struct sgs__findServiceData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__findServiceData(struct soap *soap, const struct sgs__findServiceData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__findServiceData);
	if (soap_out_sgs__findServiceData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__findServiceData(struct soap *soap, const char *tag, int id, const struct sgs__findServiceData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__findServiceData), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__findServiceData * SOAP_FMAC4 soap_get_sgs__findServiceData(struct soap *soap, struct sgs__findServiceData *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__findServiceData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__findServiceData * SOAP_FMAC4 soap_in_sgs__findServiceData(struct soap *soap, const char *tag, struct sgs__findServiceData *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__findServiceData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__findServiceData, sizeof(struct sgs__findServiceData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__findServiceData(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__findServiceData *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__findServiceData, 0, sizeof(struct sgs__findServiceData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__GetNthDataSource(struct soap *soap, const struct sgs__GetNthDataSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__GetNthDataSource(struct soap *soap, struct sgs__GetNthDataSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__int(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__GetNthDataSource(struct soap *soap, const struct sgs__GetNthDataSource *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__GetNthDataSource);
	if (soap_out_sgs__GetNthDataSource(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__GetNthDataSource(struct soap *soap, const char *tag, int id, const struct sgs__GetNthDataSource *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__GetNthDataSource), type);
	soap_out_xsd__int(soap, "in0", -1, &a->in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__GetNthDataSource * SOAP_FMAC4 soap_get_sgs__GetNthDataSource(struct soap *soap, struct sgs__GetNthDataSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__GetNthDataSource(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__GetNthDataSource * SOAP_FMAC4 soap_in_sgs__GetNthDataSource(struct soap *soap, const char *tag, struct sgs__GetNthDataSource *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__GetNthDataSource *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetNthDataSource, sizeof(struct sgs__GetNthDataSource), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__GetNthDataSource(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "in0", &a->in0, "xsd:int"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__GetNthDataSource *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__GetNthDataSource, 0, sizeof(struct sgs__GetNthDataSource), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__Restart(struct soap *soap, const struct sgs__Restart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__Restart(struct soap *soap, struct sgs__Restart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__Restart(struct soap *soap, const struct sgs__Restart *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__Restart);
	if (soap_out_sgs__Restart(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__Restart(struct soap *soap, const char *tag, int id, const struct sgs__Restart *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__Restart), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__Restart * SOAP_FMAC4 soap_get_sgs__Restart(struct soap *soap, struct sgs__Restart *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__Restart(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__Restart * SOAP_FMAC4 soap_in_sgs__Restart(struct soap *soap, const char *tag, struct sgs__Restart *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__Restart *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__Restart, sizeof(struct sgs__Restart), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__Restart(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__Restart *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__Restart, 0, sizeof(struct sgs__Restart), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__PutControl(struct soap *soap, const struct sgs__PutControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__PutControl(struct soap *soap, struct sgs__PutControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__PutControl(struct soap *soap, const struct sgs__PutControl *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__PutControl);
	if (soap_out_sgs__PutControl(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__PutControl(struct soap *soap, const char *tag, int id, const struct sgs__PutControl *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__PutControl), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__PutControl * SOAP_FMAC4 soap_get_sgs__PutControl(struct soap *soap, struct sgs__PutControl *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__PutControl(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__PutControl * SOAP_FMAC4 soap_in_sgs__PutControl(struct soap *soap, const char *tag, struct sgs__PutControl *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__PutControl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__PutControl, sizeof(struct sgs__PutControl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__PutControl(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__PutControl *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__PutControl, 0, sizeof(struct sgs__PutControl), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__Pause(struct soap *soap, const struct sgs__Pause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__Pause(struct soap *soap, struct sgs__Pause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__Pause(struct soap *soap, const struct sgs__Pause *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__Pause);
	if (soap_out_sgs__Pause(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__Pause(struct soap *soap, const char *tag, int id, const struct sgs__Pause *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__Pause), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__Pause * SOAP_FMAC4 soap_get_sgs__Pause(struct soap *soap, struct sgs__Pause *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__Pause(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__Pause * SOAP_FMAC4 soap_in_sgs__Pause(struct soap *soap, const char *tag, struct sgs__Pause *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__Pause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__Pause, sizeof(struct sgs__Pause), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__Pause(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__Pause *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__Pause, 0, sizeof(struct sgs__Pause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__AppDetach(struct soap *soap, const struct sgs__AppDetach *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__AppDetach(struct soap *soap, struct sgs__AppDetach *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__AppDetach(struct soap *soap, const struct sgs__AppDetach *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__AppDetach);
	if (soap_out_sgs__AppDetach(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__AppDetach(struct soap *soap, const char *tag, int id, const struct sgs__AppDetach *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__AppDetach), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__AppDetach * SOAP_FMAC4 soap_get_sgs__AppDetach(struct soap *soap, struct sgs__AppDetach *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__AppDetach(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__AppDetach * SOAP_FMAC4 soap_in_sgs__AppDetach(struct soap *soap, const char *tag, struct sgs__AppDetach *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__AppDetach *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppDetach, sizeof(struct sgs__AppDetach), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__AppDetach(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__AppDetach *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__AppDetach, 0, sizeof(struct sgs__AppDetach), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__AppPutLog(struct soap *soap, const struct sgs__AppPutLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__AppPutLog(struct soap *soap, struct sgs__AppPutLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__AppPutLog(struct soap *soap, const struct sgs__AppPutLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__AppPutLog);
	if (soap_out_sgs__AppPutLog(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__AppPutLog(struct soap *soap, const char *tag, int id, const struct sgs__AppPutLog *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__AppPutLog), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__AppPutLog * SOAP_FMAC4 soap_get_sgs__AppPutLog(struct soap *soap, struct sgs__AppPutLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__AppPutLog(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__AppPutLog * SOAP_FMAC4 soap_in_sgs__AppPutLog(struct soap *soap, const char *tag, struct sgs__AppPutLog *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__AppPutLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppPutLog, sizeof(struct sgs__AppPutLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__AppPutLog(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__AppPutLog *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__AppPutLog, 0, sizeof(struct sgs__AppPutLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__setServiceData(struct soap *soap, const struct sgs__setServiceData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__setServiceData(struct soap *soap, struct sgs__setServiceData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__setServiceData(struct soap *soap, const struct sgs__setServiceData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__setServiceData);
	if (soap_out_sgs__setServiceData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__setServiceData(struct soap *soap, const char *tag, int id, const struct sgs__setServiceData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__setServiceData), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__setServiceData * SOAP_FMAC4 soap_get_sgs__setServiceData(struct soap *soap, struct sgs__setServiceData *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__setServiceData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__setServiceData * SOAP_FMAC4 soap_in_sgs__setServiceData(struct soap *soap, const char *tag, struct sgs__setServiceData *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__setServiceData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__setServiceData, sizeof(struct sgs__setServiceData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__setServiceData(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__setServiceData *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__setServiceData, 0, sizeof(struct sgs__setServiceData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__GetParamLog(struct soap *soap, const struct sgs__GetParamLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__GetParamLog(struct soap *soap, struct sgs__GetParamLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__int(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__GetParamLog(struct soap *soap, const struct sgs__GetParamLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__GetParamLog);
	if (soap_out_sgs__GetParamLog(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__GetParamLog(struct soap *soap, const char *tag, int id, const struct sgs__GetParamLog *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__GetParamLog), type);
	soap_out_xsd__int(soap, "in0", -1, &a->in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__GetParamLog * SOAP_FMAC4 soap_get_sgs__GetParamLog(struct soap *soap, struct sgs__GetParamLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__GetParamLog(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__GetParamLog * SOAP_FMAC4 soap_in_sgs__GetParamLog(struct soap *soap, const char *tag, struct sgs__GetParamLog *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__GetParamLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetParamLog, sizeof(struct sgs__GetParamLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__GetParamLog(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "in0", &a->in0, "xsd:int"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__GetParamLog *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__GetParamLog, 0, sizeof(struct sgs__GetParamLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__AppStart(struct soap *soap, const struct sgs__AppStart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__AppStart(struct soap *soap, struct sgs__AppStart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__AppStart(struct soap *soap, const struct sgs__AppStart *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__AppStart);
	if (soap_out_sgs__AppStart(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__AppStart(struct soap *soap, const char *tag, int id, const struct sgs__AppStart *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__AppStart), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__AppStart * SOAP_FMAC4 soap_get_sgs__AppStart(struct soap *soap, struct sgs__AppStart *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__AppStart(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__AppStart * SOAP_FMAC4 soap_in_sgs__AppStart(struct soap *soap, const char *tag, struct sgs__AppStart *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__AppStart *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppStart, sizeof(struct sgs__AppStart), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__AppStart(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__AppStart *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__AppStart, 0, sizeof(struct sgs__AppStart), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__PutStatus(struct soap *soap, const struct sgs__PutStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__PutStatus(struct soap *soap, struct sgs__PutStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__PutStatus(struct soap *soap, const struct sgs__PutStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__PutStatus);
	if (soap_out_sgs__PutStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__PutStatus(struct soap *soap, const char *tag, int id, const struct sgs__PutStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__PutStatus), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__PutStatus * SOAP_FMAC4 soap_get_sgs__PutStatus(struct soap *soap, struct sgs__PutStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__PutStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__PutStatus * SOAP_FMAC4 soap_in_sgs__PutStatus(struct soap *soap, const char *tag, struct sgs__PutStatus *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__PutStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__PutStatus, sizeof(struct sgs__PutStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__PutStatus(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__PutStatus *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__PutStatus, 0, sizeof(struct sgs__PutStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__AppRecordChkpoint(struct soap *soap, const struct sgs__AppRecordChkpoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in0);
	soap_embedded(soap, &a->in1, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__AppRecordChkpoint(struct soap *soap, struct sgs__AppRecordChkpoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
	soap_default_xsd__string(soap, &a->in1);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__AppRecordChkpoint(struct soap *soap, const struct sgs__AppRecordChkpoint *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__AppRecordChkpoint);
	if (soap_out_sgs__AppRecordChkpoint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__AppRecordChkpoint(struct soap *soap, const char *tag, int id, const struct sgs__AppRecordChkpoint *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__AppRecordChkpoint), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "");
	soap_out_xsd__string(soap, "in1", -1, &a->in1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__AppRecordChkpoint * SOAP_FMAC4 soap_get_sgs__AppRecordChkpoint(struct soap *soap, struct sgs__AppRecordChkpoint *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__AppRecordChkpoint(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__AppRecordChkpoint * SOAP_FMAC4 soap_in_sgs__AppRecordChkpoint(struct soap *soap, const char *tag, struct sgs__AppRecordChkpoint *a, const char *type)
{
	short soap_flag_in0 = 1, soap_flag_in1 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__AppRecordChkpoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppRecordChkpoint, sizeof(struct sgs__AppRecordChkpoint), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__AppRecordChkpoint(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap_flag_in1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in1", &a->in1, "xsd:string"))
				{	soap_flag_in1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__AppRecordChkpoint *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__AppRecordChkpoint, 0, sizeof(struct sgs__AppRecordChkpoint), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__Resume(struct soap *soap, const struct sgs__Resume *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__Resume(struct soap *soap, struct sgs__Resume *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__Resume(struct soap *soap, const struct sgs__Resume *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__Resume);
	if (soap_out_sgs__Resume(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__Resume(struct soap *soap, const char *tag, int id, const struct sgs__Resume *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__Resume), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__Resume * SOAP_FMAC4 soap_get_sgs__Resume(struct soap *soap, struct sgs__Resume *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__Resume(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__Resume * SOAP_FMAC4 soap_in_sgs__Resume(struct soap *soap, const char *tag, struct sgs__Resume *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__Resume *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__Resume, sizeof(struct sgs__Resume), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__Resume(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__Resume *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__Resume, 0, sizeof(struct sgs__Resume), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__Detach(struct soap *soap, const struct sgs__Detach *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__Detach(struct soap *soap, struct sgs__Detach *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__Detach(struct soap *soap, const struct sgs__Detach *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__Detach);
	if (soap_out_sgs__Detach(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__Detach(struct soap *soap, const char *tag, int id, const struct sgs__Detach *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__Detach), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__Detach * SOAP_FMAC4 soap_get_sgs__Detach(struct soap *soap, struct sgs__Detach *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__Detach(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__Detach * SOAP_FMAC4 soap_in_sgs__Detach(struct soap *soap, const char *tag, struct sgs__Detach *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__Detach *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__Detach, sizeof(struct sgs__Detach), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__Detach(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__Detach *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__Detach, 0, sizeof(struct sgs__Detach), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__ClearStatusMsgQueue(struct soap *soap, const struct sgs__ClearStatusMsgQueue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__ClearStatusMsgQueue(struct soap *soap, struct sgs__ClearStatusMsgQueue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__ClearStatusMsgQueue(struct soap *soap, const struct sgs__ClearStatusMsgQueue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__ClearStatusMsgQueue);
	if (soap_out_sgs__ClearStatusMsgQueue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__ClearStatusMsgQueue(struct soap *soap, const char *tag, int id, const struct sgs__ClearStatusMsgQueue *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__ClearStatusMsgQueue), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__ClearStatusMsgQueue * SOAP_FMAC4 soap_get_sgs__ClearStatusMsgQueue(struct soap *soap, struct sgs__ClearStatusMsgQueue *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__ClearStatusMsgQueue(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__ClearStatusMsgQueue * SOAP_FMAC4 soap_in_sgs__ClearStatusMsgQueue(struct soap *soap, const char *tag, struct sgs__ClearStatusMsgQueue *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__ClearStatusMsgQueue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__ClearStatusMsgQueue, sizeof(struct sgs__ClearStatusMsgQueue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__ClearStatusMsgQueue(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__ClearStatusMsgQueue *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__ClearStatusMsgQueue, 0, sizeof(struct sgs__ClearStatusMsgQueue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__Stop(struct soap *soap, const struct sgs__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__Stop(struct soap *soap, struct sgs__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__Stop(struct soap *soap, const struct sgs__Stop *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__Stop);
	if (soap_out_sgs__Stop(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__Stop(struct soap *soap, const char *tag, int id, const struct sgs__Stop *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__Stop), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__Stop * SOAP_FMAC4 soap_get_sgs__Stop(struct soap *soap, struct sgs__Stop *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__Stop(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__Stop * SOAP_FMAC4 soap_in_sgs__Stop(struct soap *soap, const char *tag, struct sgs__Stop *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__Stop *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__Stop, sizeof(struct sgs__Stop), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__Stop(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__Stop *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__Stop, 0, sizeof(struct sgs__Stop), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__GetStatus(struct soap *soap, const struct sgs__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__GetStatus(struct soap *soap, struct sgs__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__GetStatus(struct soap *soap, const struct sgs__GetStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__GetStatus);
	if (soap_out_sgs__GetStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__GetStatus(struct soap *soap, const char *tag, int id, const struct sgs__GetStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__GetStatus), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__GetStatus * SOAP_FMAC4 soap_get_sgs__GetStatus(struct soap *soap, struct sgs__GetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__GetStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__GetStatus * SOAP_FMAC4 soap_in_sgs__GetStatus(struct soap *soap, const char *tag, struct sgs__GetStatus *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__GetStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetStatus, sizeof(struct sgs__GetStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__GetStatus(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__GetStatus *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__GetStatus, 0, sizeof(struct sgs__GetStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__Attach(struct soap *soap, const struct sgs__Attach *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__Attach(struct soap *soap, struct sgs__Attach *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__Attach(struct soap *soap, const struct sgs__Attach *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__Attach);
	if (soap_out_sgs__Attach(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__Attach(struct soap *soap, const char *tag, int id, const struct sgs__Attach *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__Attach), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__Attach * SOAP_FMAC4 soap_get_sgs__Attach(struct soap *soap, struct sgs__Attach *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__Attach(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__Attach * SOAP_FMAC4 soap_in_sgs__Attach(struct soap *soap, const char *tag, struct sgs__Attach *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__Attach *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__Attach, sizeof(struct sgs__Attach), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__Attach(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__Attach *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__Attach, 0, sizeof(struct sgs__Attach), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__AppDetachResponse(struct soap *soap, const struct sgs__AppDetachResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_AppDetachReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_AppDetachReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__AppDetachResponse(struct soap *soap, struct sgs__AppDetachResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_AppDetachReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__AppDetachResponse(struct soap *soap, const struct sgs__AppDetachResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__AppDetachResponse);
	if (soap_out_sgs__AppDetachResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__AppDetachResponse(struct soap *soap, const char *tag, int id, const struct sgs__AppDetachResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__AppDetachResponse), type);
	if (a->_AppDetachReturn)
		soap_element_result(soap, "AppDetachReturn");
	soap_out_xsd__string(soap, "AppDetachReturn", -1, &a->_AppDetachReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__AppDetachResponse * SOAP_FMAC4 soap_get_sgs__AppDetachResponse(struct soap *soap, struct sgs__AppDetachResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__AppDetachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__AppDetachResponse * SOAP_FMAC4 soap_in_sgs__AppDetachResponse(struct soap *soap, const char *tag, struct sgs__AppDetachResponse *a, const char *type)
{
	short soap_flag__AppDetachReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__AppDetachResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppDetachResponse, sizeof(struct sgs__AppDetachResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__AppDetachResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__AppDetachReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_AppDetachReturn, "xsd:string"))
				{	soap_flag__AppDetachReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__AppDetachResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__AppDetachResponse, 0, sizeof(struct sgs__AppDetachResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__AppStartResponse(struct soap *soap, const struct sgs__AppStartResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_AppStartReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_AppStartReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__AppStartResponse(struct soap *soap, struct sgs__AppStartResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_AppStartReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__AppStartResponse(struct soap *soap, const struct sgs__AppStartResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__AppStartResponse);
	if (soap_out_sgs__AppStartResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__AppStartResponse(struct soap *soap, const char *tag, int id, const struct sgs__AppStartResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__AppStartResponse), type);
	if (a->_AppStartReturn)
		soap_element_result(soap, "AppStartReturn");
	soap_out_xsd__string(soap, "AppStartReturn", -1, &a->_AppStartReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__AppStartResponse * SOAP_FMAC4 soap_get_sgs__AppStartResponse(struct soap *soap, struct sgs__AppStartResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__AppStartResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__AppStartResponse * SOAP_FMAC4 soap_in_sgs__AppStartResponse(struct soap *soap, const char *tag, struct sgs__AppStartResponse *a, const char *type)
{
	short soap_flag__AppStartReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__AppStartResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppStartResponse, sizeof(struct sgs__AppStartResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__AppStartResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__AppStartReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_AppStartReturn, "xsd:string"))
				{	soap_flag__AppStartReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__AppStartResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__AppStartResponse, 0, sizeof(struct sgs__AppStartResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__GetNthDataSourceResponse(struct soap *soap, const struct sgs__GetNthDataSourceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_GetNthDataSourceReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_GetNthDataSourceReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__GetNthDataSourceResponse(struct soap *soap, struct sgs__GetNthDataSourceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_GetNthDataSourceReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__GetNthDataSourceResponse(struct soap *soap, const struct sgs__GetNthDataSourceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__GetNthDataSourceResponse);
	if (soap_out_sgs__GetNthDataSourceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__GetNthDataSourceResponse(struct soap *soap, const char *tag, int id, const struct sgs__GetNthDataSourceResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__GetNthDataSourceResponse), type);
	if (a->_GetNthDataSourceReturn)
		soap_element_result(soap, "GetNthDataSourceReturn");
	soap_out_xsd__string(soap, "GetNthDataSourceReturn", -1, &a->_GetNthDataSourceReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__GetNthDataSourceResponse * SOAP_FMAC4 soap_get_sgs__GetNthDataSourceResponse(struct soap *soap, struct sgs__GetNthDataSourceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__GetNthDataSourceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__GetNthDataSourceResponse * SOAP_FMAC4 soap_in_sgs__GetNthDataSourceResponse(struct soap *soap, const char *tag, struct sgs__GetNthDataSourceResponse *a, const char *type)
{
	short soap_flag__GetNthDataSourceReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__GetNthDataSourceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetNthDataSourceResponse, sizeof(struct sgs__GetNthDataSourceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__GetNthDataSourceResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetNthDataSourceReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_GetNthDataSourceReturn, "xsd:string"))
				{	soap_flag__GetNthDataSourceReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__GetNthDataSourceResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__GetNthDataSourceResponse, 0, sizeof(struct sgs__GetNthDataSourceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__AppPutLogResponse(struct soap *soap, const struct sgs__AppPutLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_AppPutLogReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_AppPutLogReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__AppPutLogResponse(struct soap *soap, struct sgs__AppPutLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_AppPutLogReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__AppPutLogResponse(struct soap *soap, const struct sgs__AppPutLogResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__AppPutLogResponse);
	if (soap_out_sgs__AppPutLogResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__AppPutLogResponse(struct soap *soap, const char *tag, int id, const struct sgs__AppPutLogResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__AppPutLogResponse), type);
	if (a->_AppPutLogReturn)
		soap_element_result(soap, "AppPutLogReturn");
	soap_out_xsd__string(soap, "AppPutLogReturn", -1, &a->_AppPutLogReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__AppPutLogResponse * SOAP_FMAC4 soap_get_sgs__AppPutLogResponse(struct soap *soap, struct sgs__AppPutLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__AppPutLogResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__AppPutLogResponse * SOAP_FMAC4 soap_in_sgs__AppPutLogResponse(struct soap *soap, const char *tag, struct sgs__AppPutLogResponse *a, const char *type)
{
	short soap_flag__AppPutLogReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__AppPutLogResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppPutLogResponse, sizeof(struct sgs__AppPutLogResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__AppPutLogResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__AppPutLogReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_AppPutLogReturn, "xsd:string"))
				{	soap_flag__AppPutLogReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__AppPutLogResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__AppPutLogResponse, 0, sizeof(struct sgs__AppPutLogResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__ClearStatusMsgQueueResponse(struct soap *soap, const struct sgs__ClearStatusMsgQueueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_ClearStatusMsgQueueReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_ClearStatusMsgQueueReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__ClearStatusMsgQueueResponse(struct soap *soap, struct sgs__ClearStatusMsgQueueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_ClearStatusMsgQueueReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__ClearStatusMsgQueueResponse(struct soap *soap, const struct sgs__ClearStatusMsgQueueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__ClearStatusMsgQueueResponse);
	if (soap_out_sgs__ClearStatusMsgQueueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__ClearStatusMsgQueueResponse(struct soap *soap, const char *tag, int id, const struct sgs__ClearStatusMsgQueueResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__ClearStatusMsgQueueResponse), type);
	if (a->_ClearStatusMsgQueueReturn)
		soap_element_result(soap, "ClearStatusMsgQueueReturn");
	soap_out_xsd__string(soap, "ClearStatusMsgQueueReturn", -1, &a->_ClearStatusMsgQueueReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__ClearStatusMsgQueueResponse * SOAP_FMAC4 soap_get_sgs__ClearStatusMsgQueueResponse(struct soap *soap, struct sgs__ClearStatusMsgQueueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__ClearStatusMsgQueueResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__ClearStatusMsgQueueResponse * SOAP_FMAC4 soap_in_sgs__ClearStatusMsgQueueResponse(struct soap *soap, const char *tag, struct sgs__ClearStatusMsgQueueResponse *a, const char *type)
{
	short soap_flag__ClearStatusMsgQueueReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__ClearStatusMsgQueueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__ClearStatusMsgQueueResponse, sizeof(struct sgs__ClearStatusMsgQueueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__ClearStatusMsgQueueResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__ClearStatusMsgQueueReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_ClearStatusMsgQueueReturn, "xsd:string"))
				{	soap_flag__ClearStatusMsgQueueReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__ClearStatusMsgQueueResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__ClearStatusMsgQueueResponse, 0, sizeof(struct sgs__ClearStatusMsgQueueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__destroyResponse(struct soap *soap, const struct sgs__destroyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__destroyResponse(struct soap *soap, struct sgs__destroyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__destroyResponse(struct soap *soap, const struct sgs__destroyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__destroyResponse);
	if (soap_out_sgs__destroyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__destroyResponse(struct soap *soap, const char *tag, int id, const struct sgs__destroyResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__destroyResponse), type);
	if (a->_)
		soap_element_result(soap, "");
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__destroyResponse * SOAP_FMAC4 soap_get_sgs__destroyResponse(struct soap *soap, struct sgs__destroyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__destroyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__destroyResponse * SOAP_FMAC4 soap_in_sgs__destroyResponse(struct soap *soap, const char *tag, struct sgs__destroyResponse *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__destroyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__destroyResponse, sizeof(struct sgs__destroyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__destroyResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__destroyResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__destroyResponse, 0, sizeof(struct sgs__destroyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__AppStopResponse(struct soap *soap, const struct sgs__AppStopResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_AppStopReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_AppStopReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__AppStopResponse(struct soap *soap, struct sgs__AppStopResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_AppStopReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__AppStopResponse(struct soap *soap, const struct sgs__AppStopResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__AppStopResponse);
	if (soap_out_sgs__AppStopResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__AppStopResponse(struct soap *soap, const char *tag, int id, const struct sgs__AppStopResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__AppStopResponse), type);
	if (a->_AppStopReturn)
		soap_element_result(soap, "AppStopReturn");
	soap_out_xsd__string(soap, "AppStopReturn", -1, &a->_AppStopReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__AppStopResponse * SOAP_FMAC4 soap_get_sgs__AppStopResponse(struct soap *soap, struct sgs__AppStopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__AppStopResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__AppStopResponse * SOAP_FMAC4 soap_in_sgs__AppStopResponse(struct soap *soap, const char *tag, struct sgs__AppStopResponse *a, const char *type)
{
	short soap_flag__AppStopReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__AppStopResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppStopResponse, sizeof(struct sgs__AppStopResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__AppStopResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__AppStopReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_AppStopReturn, "xsd:string"))
				{	soap_flag__AppStopReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__AppStopResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__AppStopResponse, 0, sizeof(struct sgs__AppStopResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__GetStatusResponse(struct soap *soap, const struct sgs__GetStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_GetStatusReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_GetStatusReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__GetStatusResponse(struct soap *soap, struct sgs__GetStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_GetStatusReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__GetStatusResponse(struct soap *soap, const struct sgs__GetStatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__GetStatusResponse);
	if (soap_out_sgs__GetStatusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__GetStatusResponse(struct soap *soap, const char *tag, int id, const struct sgs__GetStatusResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__GetStatusResponse), type);
	if (a->_GetStatusReturn)
		soap_element_result(soap, "GetStatusReturn");
	soap_out_xsd__string(soap, "GetStatusReturn", -1, &a->_GetStatusReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__GetStatusResponse * SOAP_FMAC4 soap_get_sgs__GetStatusResponse(struct soap *soap, struct sgs__GetStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__GetStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__GetStatusResponse * SOAP_FMAC4 soap_in_sgs__GetStatusResponse(struct soap *soap, const char *tag, struct sgs__GetStatusResponse *a, const char *type)
{
	short soap_flag__GetStatusReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__GetStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetStatusResponse, sizeof(struct sgs__GetStatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__GetStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetStatusReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_GetStatusReturn, "xsd:string"))
				{	soap_flag__GetStatusReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__GetStatusResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__GetStatusResponse, 0, sizeof(struct sgs__GetStatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__GetControlResponse(struct soap *soap, const struct sgs__GetControlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_GetControlReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_GetControlReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__GetControlResponse(struct soap *soap, struct sgs__GetControlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_GetControlReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__GetControlResponse(struct soap *soap, const struct sgs__GetControlResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__GetControlResponse);
	if (soap_out_sgs__GetControlResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__GetControlResponse(struct soap *soap, const char *tag, int id, const struct sgs__GetControlResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__GetControlResponse), type);
	if (a->_GetControlReturn)
		soap_element_result(soap, "GetControlReturn");
	soap_out_xsd__string(soap, "GetControlReturn", -1, &a->_GetControlReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__GetControlResponse * SOAP_FMAC4 soap_get_sgs__GetControlResponse(struct soap *soap, struct sgs__GetControlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__GetControlResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__GetControlResponse * SOAP_FMAC4 soap_in_sgs__GetControlResponse(struct soap *soap, const char *tag, struct sgs__GetControlResponse *a, const char *type)
{
	short soap_flag__GetControlReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__GetControlResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetControlResponse, sizeof(struct sgs__GetControlResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__GetControlResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetControlReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_GetControlReturn, "xsd:string"))
				{	soap_flag__GetControlReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__GetControlResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__GetControlResponse, 0, sizeof(struct sgs__GetControlResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__StopResponse(struct soap *soap, const struct sgs__StopResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_StopReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_StopReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__StopResponse(struct soap *soap, struct sgs__StopResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_StopReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__StopResponse(struct soap *soap, const struct sgs__StopResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__StopResponse);
	if (soap_out_sgs__StopResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__StopResponse(struct soap *soap, const char *tag, int id, const struct sgs__StopResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__StopResponse), type);
	if (a->_StopReturn)
		soap_element_result(soap, "StopReturn");
	soap_out_xsd__string(soap, "StopReturn", -1, &a->_StopReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__StopResponse * SOAP_FMAC4 soap_get_sgs__StopResponse(struct soap *soap, struct sgs__StopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__StopResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__StopResponse * SOAP_FMAC4 soap_in_sgs__StopResponse(struct soap *soap, const char *tag, struct sgs__StopResponse *a, const char *type)
{
	short soap_flag__StopReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__StopResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__StopResponse, sizeof(struct sgs__StopResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__StopResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__StopReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_StopReturn, "xsd:string"))
				{	soap_flag__StopReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__StopResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__StopResponse, 0, sizeof(struct sgs__StopResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__GetNotificationsResponse(struct soap *soap, const struct sgs__GetNotificationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_GetNotificationsReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_GetNotificationsReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__GetNotificationsResponse(struct soap *soap, struct sgs__GetNotificationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_GetNotificationsReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__GetNotificationsResponse(struct soap *soap, const struct sgs__GetNotificationsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__GetNotificationsResponse);
	if (soap_out_sgs__GetNotificationsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__GetNotificationsResponse(struct soap *soap, const char *tag, int id, const struct sgs__GetNotificationsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__GetNotificationsResponse), type);
	if (a->_GetNotificationsReturn)
		soap_element_result(soap, "GetNotificationsReturn");
	soap_out_xsd__string(soap, "GetNotificationsReturn", -1, &a->_GetNotificationsReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__GetNotificationsResponse * SOAP_FMAC4 soap_get_sgs__GetNotificationsResponse(struct soap *soap, struct sgs__GetNotificationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__GetNotificationsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__GetNotificationsResponse * SOAP_FMAC4 soap_in_sgs__GetNotificationsResponse(struct soap *soap, const char *tag, struct sgs__GetNotificationsResponse *a, const char *type)
{
	short soap_flag__GetNotificationsReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__GetNotificationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetNotificationsResponse, sizeof(struct sgs__GetNotificationsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__GetNotificationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetNotificationsReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_GetNotificationsReturn, "xsd:string"))
				{	soap_flag__GetNotificationsReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__GetNotificationsResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__GetNotificationsResponse, 0, sizeof(struct sgs__GetNotificationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__AttachResponse(struct soap *soap, const struct sgs__AttachResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_AttachReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_AttachReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__AttachResponse(struct soap *soap, struct sgs__AttachResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_AttachReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__AttachResponse(struct soap *soap, const struct sgs__AttachResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__AttachResponse);
	if (soap_out_sgs__AttachResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__AttachResponse(struct soap *soap, const char *tag, int id, const struct sgs__AttachResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__AttachResponse), type);
	if (a->_AttachReturn)
		soap_element_result(soap, "AttachReturn");
	soap_out_xsd__string(soap, "AttachReturn", -1, &a->_AttachReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__AttachResponse * SOAP_FMAC4 soap_get_sgs__AttachResponse(struct soap *soap, struct sgs__AttachResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__AttachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__AttachResponse * SOAP_FMAC4 soap_in_sgs__AttachResponse(struct soap *soap, const char *tag, struct sgs__AttachResponse *a, const char *type)
{
	short soap_flag__AttachReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__AttachResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AttachResponse, sizeof(struct sgs__AttachResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__AttachResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__AttachReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_AttachReturn, "xsd:string"))
				{	soap_flag__AttachReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__AttachResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__AttachResponse, 0, sizeof(struct sgs__AttachResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__ResumeResponse(struct soap *soap, const struct sgs__ResumeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_ResumeReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_ResumeReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__ResumeResponse(struct soap *soap, struct sgs__ResumeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_ResumeReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__ResumeResponse(struct soap *soap, const struct sgs__ResumeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__ResumeResponse);
	if (soap_out_sgs__ResumeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__ResumeResponse(struct soap *soap, const char *tag, int id, const struct sgs__ResumeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__ResumeResponse), type);
	if (a->_ResumeReturn)
		soap_element_result(soap, "ResumeReturn");
	soap_out_xsd__string(soap, "ResumeReturn", -1, &a->_ResumeReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__ResumeResponse * SOAP_FMAC4 soap_get_sgs__ResumeResponse(struct soap *soap, struct sgs__ResumeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__ResumeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__ResumeResponse * SOAP_FMAC4 soap_in_sgs__ResumeResponse(struct soap *soap, const char *tag, struct sgs__ResumeResponse *a, const char *type)
{
	short soap_flag__ResumeReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__ResumeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__ResumeResponse, sizeof(struct sgs__ResumeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__ResumeResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__ResumeReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_ResumeReturn, "xsd:string"))
				{	soap_flag__ResumeReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__ResumeResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__ResumeResponse, 0, sizeof(struct sgs__ResumeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__PutControlResponse(struct soap *soap, const struct sgs__PutControlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_PutControlReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_PutControlReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__PutControlResponse(struct soap *soap, struct sgs__PutControlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_PutControlReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__PutControlResponse(struct soap *soap, const struct sgs__PutControlResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__PutControlResponse);
	if (soap_out_sgs__PutControlResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__PutControlResponse(struct soap *soap, const char *tag, int id, const struct sgs__PutControlResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__PutControlResponse), type);
	if (a->_PutControlReturn)
		soap_element_result(soap, "PutControlReturn");
	soap_out_xsd__string(soap, "PutControlReturn", -1, &a->_PutControlReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__PutControlResponse * SOAP_FMAC4 soap_get_sgs__PutControlResponse(struct soap *soap, struct sgs__PutControlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__PutControlResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__PutControlResponse * SOAP_FMAC4 soap_in_sgs__PutControlResponse(struct soap *soap, const char *tag, struct sgs__PutControlResponse *a, const char *type)
{
	short soap_flag__PutControlReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__PutControlResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__PutControlResponse, sizeof(struct sgs__PutControlResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__PutControlResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__PutControlReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_PutControlReturn, "xsd:string"))
				{	soap_flag__PutControlReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__PutControlResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__PutControlResponse, 0, sizeof(struct sgs__PutControlResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__RestartResponse(struct soap *soap, const struct sgs__RestartResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_RestartReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_RestartReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__RestartResponse(struct soap *soap, struct sgs__RestartResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_RestartReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__RestartResponse(struct soap *soap, const struct sgs__RestartResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__RestartResponse);
	if (soap_out_sgs__RestartResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__RestartResponse(struct soap *soap, const char *tag, int id, const struct sgs__RestartResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__RestartResponse), type);
	if (a->_RestartReturn)
		soap_element_result(soap, "RestartReturn");
	soap_out_xsd__string(soap, "RestartReturn", -1, &a->_RestartReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__RestartResponse * SOAP_FMAC4 soap_get_sgs__RestartResponse(struct soap *soap, struct sgs__RestartResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__RestartResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__RestartResponse * SOAP_FMAC4 soap_in_sgs__RestartResponse(struct soap *soap, const char *tag, struct sgs__RestartResponse *a, const char *type)
{
	short soap_flag__RestartReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__RestartResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__RestartResponse, sizeof(struct sgs__RestartResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__RestartResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__RestartReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_RestartReturn, "xsd:string"))
				{	soap_flag__RestartReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__RestartResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__RestartResponse, 0, sizeof(struct sgs__RestartResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__findServiceDataResponse(struct soap *soap, const struct sgs__findServiceDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_findServiceDataReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_findServiceDataReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__findServiceDataResponse(struct soap *soap, struct sgs__findServiceDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_findServiceDataReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__findServiceDataResponse(struct soap *soap, const struct sgs__findServiceDataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__findServiceDataResponse);
	if (soap_out_sgs__findServiceDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__findServiceDataResponse(struct soap *soap, const char *tag, int id, const struct sgs__findServiceDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__findServiceDataResponse), type);
	if (a->_findServiceDataReturn)
		soap_element_result(soap, "findServiceDataReturn");
	soap_out_xsd__string(soap, "findServiceDataReturn", -1, &a->_findServiceDataReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__findServiceDataResponse * SOAP_FMAC4 soap_get_sgs__findServiceDataResponse(struct soap *soap, struct sgs__findServiceDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__findServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__findServiceDataResponse * SOAP_FMAC4 soap_in_sgs__findServiceDataResponse(struct soap *soap, const char *tag, struct sgs__findServiceDataResponse *a, const char *type)
{
	short soap_flag__findServiceDataReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__findServiceDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__findServiceDataResponse, sizeof(struct sgs__findServiceDataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__findServiceDataResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__findServiceDataReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_findServiceDataReturn, "xsd:string"))
				{	soap_flag__findServiceDataReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__findServiceDataResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__findServiceDataResponse, 0, sizeof(struct sgs__findServiceDataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__PauseResponse(struct soap *soap, const struct sgs__PauseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_PauseReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_PauseReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__PauseResponse(struct soap *soap, struct sgs__PauseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_PauseReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__PauseResponse(struct soap *soap, const struct sgs__PauseResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__PauseResponse);
	if (soap_out_sgs__PauseResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__PauseResponse(struct soap *soap, const char *tag, int id, const struct sgs__PauseResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__PauseResponse), type);
	if (a->_PauseReturn)
		soap_element_result(soap, "PauseReturn");
	soap_out_xsd__string(soap, "PauseReturn", -1, &a->_PauseReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__PauseResponse * SOAP_FMAC4 soap_get_sgs__PauseResponse(struct soap *soap, struct sgs__PauseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__PauseResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__PauseResponse * SOAP_FMAC4 soap_in_sgs__PauseResponse(struct soap *soap, const char *tag, struct sgs__PauseResponse *a, const char *type)
{
	short soap_flag__PauseReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__PauseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__PauseResponse, sizeof(struct sgs__PauseResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__PauseResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__PauseReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_PauseReturn, "xsd:string"))
				{	soap_flag__PauseReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__PauseResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__PauseResponse, 0, sizeof(struct sgs__PauseResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__setServiceDataResponse(struct soap *soap, const struct sgs__setServiceDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_setServiceDataReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_setServiceDataReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__setServiceDataResponse(struct soap *soap, struct sgs__setServiceDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_setServiceDataReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__setServiceDataResponse(struct soap *soap, const struct sgs__setServiceDataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__setServiceDataResponse);
	if (soap_out_sgs__setServiceDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__setServiceDataResponse(struct soap *soap, const char *tag, int id, const struct sgs__setServiceDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__setServiceDataResponse), type);
	if (a->_setServiceDataReturn)
		soap_element_result(soap, "setServiceDataReturn");
	soap_out_xsd__string(soap, "setServiceDataReturn", -1, &a->_setServiceDataReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__setServiceDataResponse * SOAP_FMAC4 soap_get_sgs__setServiceDataResponse(struct soap *soap, struct sgs__setServiceDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__setServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__setServiceDataResponse * SOAP_FMAC4 soap_in_sgs__setServiceDataResponse(struct soap *soap, const char *tag, struct sgs__setServiceDataResponse *a, const char *type)
{
	short soap_flag__setServiceDataReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__setServiceDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__setServiceDataResponse, sizeof(struct sgs__setServiceDataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__setServiceDataResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__setServiceDataReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_setServiceDataReturn, "xsd:string"))
				{	soap_flag__setServiceDataReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__setServiceDataResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__setServiceDataResponse, 0, sizeof(struct sgs__setServiceDataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__PutStatusResponse(struct soap *soap, const struct sgs__PutStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_PutStatusReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_PutStatusReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__PutStatusResponse(struct soap *soap, struct sgs__PutStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_PutStatusReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__PutStatusResponse(struct soap *soap, const struct sgs__PutStatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__PutStatusResponse);
	if (soap_out_sgs__PutStatusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__PutStatusResponse(struct soap *soap, const char *tag, int id, const struct sgs__PutStatusResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__PutStatusResponse), type);
	if (a->_PutStatusReturn)
		soap_element_result(soap, "PutStatusReturn");
	soap_out_xsd__string(soap, "PutStatusReturn", -1, &a->_PutStatusReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__PutStatusResponse * SOAP_FMAC4 soap_get_sgs__PutStatusResponse(struct soap *soap, struct sgs__PutStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__PutStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__PutStatusResponse * SOAP_FMAC4 soap_in_sgs__PutStatusResponse(struct soap *soap, const char *tag, struct sgs__PutStatusResponse *a, const char *type)
{
	short soap_flag__PutStatusReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__PutStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__PutStatusResponse, sizeof(struct sgs__PutStatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__PutStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__PutStatusReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_PutStatusReturn, "xsd:string"))
				{	soap_flag__PutStatusReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__PutStatusResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__PutStatusResponse, 0, sizeof(struct sgs__PutStatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__AppRecordChkpointResponse(struct soap *soap, const struct sgs__AppRecordChkpointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_AppRecordChkpointReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_AppRecordChkpointReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__AppRecordChkpointResponse(struct soap *soap, struct sgs__AppRecordChkpointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_AppRecordChkpointReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__AppRecordChkpointResponse(struct soap *soap, const struct sgs__AppRecordChkpointResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__AppRecordChkpointResponse);
	if (soap_out_sgs__AppRecordChkpointResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__AppRecordChkpointResponse(struct soap *soap, const char *tag, int id, const struct sgs__AppRecordChkpointResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__AppRecordChkpointResponse), type);
	if (a->_AppRecordChkpointReturn)
		soap_element_result(soap, "AppRecordChkpointReturn");
	soap_out_xsd__string(soap, "AppRecordChkpointReturn", -1, &a->_AppRecordChkpointReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__AppRecordChkpointResponse * SOAP_FMAC4 soap_get_sgs__AppRecordChkpointResponse(struct soap *soap, struct sgs__AppRecordChkpointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__AppRecordChkpointResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__AppRecordChkpointResponse * SOAP_FMAC4 soap_in_sgs__AppRecordChkpointResponse(struct soap *soap, const char *tag, struct sgs__AppRecordChkpointResponse *a, const char *type)
{
	short soap_flag__AppRecordChkpointReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__AppRecordChkpointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppRecordChkpointResponse, sizeof(struct sgs__AppRecordChkpointResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__AppRecordChkpointResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__AppRecordChkpointReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_AppRecordChkpointReturn, "xsd:string"))
				{	soap_flag__AppRecordChkpointReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__AppRecordChkpointResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__AppRecordChkpointResponse, 0, sizeof(struct sgs__AppRecordChkpointResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__DetachResponse(struct soap *soap, const struct sgs__DetachResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_DetachReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_DetachReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__DetachResponse(struct soap *soap, struct sgs__DetachResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_DetachReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__DetachResponse(struct soap *soap, const struct sgs__DetachResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__DetachResponse);
	if (soap_out_sgs__DetachResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__DetachResponse(struct soap *soap, const char *tag, int id, const struct sgs__DetachResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__DetachResponse), type);
	if (a->_DetachReturn)
		soap_element_result(soap, "DetachReturn");
	soap_out_xsd__string(soap, "DetachReturn", -1, &a->_DetachReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__DetachResponse * SOAP_FMAC4 soap_get_sgs__DetachResponse(struct soap *soap, struct sgs__DetachResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__DetachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__DetachResponse * SOAP_FMAC4 soap_in_sgs__DetachResponse(struct soap *soap, const char *tag, struct sgs__DetachResponse *a, const char *type)
{
	short soap_flag__DetachReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__DetachResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__DetachResponse, sizeof(struct sgs__DetachResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__DetachResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__DetachReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_DetachReturn, "xsd:string"))
				{	soap_flag__DetachReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__DetachResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__DetachResponse, 0, sizeof(struct sgs__DetachResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sgs__GetParamLogResponse(struct soap *soap, const struct sgs__GetParamLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_GetParamLogReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_GetParamLogReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sgs__GetParamLogResponse(struct soap *soap, struct sgs__GetParamLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_GetParamLogReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sgs__GetParamLogResponse(struct soap *soap, const struct sgs__GetParamLogResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sgs__GetParamLogResponse);
	if (soap_out_sgs__GetParamLogResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sgs__GetParamLogResponse(struct soap *soap, const char *tag, int id, const struct sgs__GetParamLogResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__GetParamLogResponse), type);
	if (a->_GetParamLogReturn)
		soap_element_result(soap, "GetParamLogReturn");
	soap_out_xsd__string(soap, "GetParamLogReturn", -1, &a->_GetParamLogReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sgs__GetParamLogResponse * SOAP_FMAC4 soap_get_sgs__GetParamLogResponse(struct soap *soap, struct sgs__GetParamLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__GetParamLogResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__GetParamLogResponse * SOAP_FMAC4 soap_in_sgs__GetParamLogResponse(struct soap *soap, const char *tag, struct sgs__GetParamLogResponse *a, const char *type)
{
	short soap_flag__GetParamLogReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sgs__GetParamLogResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetParamLogResponse, sizeof(struct sgs__GetParamLogResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sgs__GetParamLogResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetParamLogReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_GetParamLogReturn, "xsd:string"))
				{	soap_flag__GetParamLogReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sgs__GetParamLogResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sgs__GetParamLogResponse, 0, sizeof(struct sgs__GetParamLogResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrp__Destroy(struct soap *soap, const struct wsrp__Destroy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrp__Destroy(struct soap *soap, struct wsrp__Destroy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrp__Destroy(struct soap *soap, const struct wsrp__Destroy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrp__Destroy);
	if (soap_out_wsrp__Destroy(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrp__Destroy(struct soap *soap, const char *tag, int id, const struct wsrp__Destroy *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrp__Destroy), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wsrp__Destroy * SOAP_FMAC4 soap_get_wsrp__Destroy(struct soap *soap, struct wsrp__Destroy *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrp__Destroy(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wsrp__Destroy * SOAP_FMAC4 soap_in_wsrp__Destroy(struct soap *soap, const char *tag, struct wsrp__Destroy *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct wsrp__Destroy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrp__Destroy, sizeof(struct wsrp__Destroy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_wsrp__Destroy(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrp__Destroy *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_wsrp__Destroy, 0, sizeof(struct wsrp__Destroy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__PutParamLog(struct soap *soap, const struct sws__PutParamLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__PutParamLog(struct soap *soap, struct sws__PutParamLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__PutParamLog(struct soap *soap, const struct sws__PutParamLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__PutParamLog);
	if (soap_out_sws__PutParamLog(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__PutParamLog(struct soap *soap, const char *tag, int id, const struct sws__PutParamLog *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__PutParamLog), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sws__PutParamLog * SOAP_FMAC4 soap_get_sws__PutParamLog(struct soap *soap, struct sws__PutParamLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__PutParamLog(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sws__PutParamLog * SOAP_FMAC4 soap_in_sws__PutParamLog(struct soap *soap, const char *tag, struct sws__PutParamLog *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sws__PutParamLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__PutParamLog, sizeof(struct sws__PutParamLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sws__PutParamLog(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__PutParamLog *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sws__PutParamLog, 0, sizeof(struct sws__PutParamLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__GetParamLog(struct soap *soap, const struct sws__GetParamLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__GetParamLog(struct soap *soap, struct sws__GetParamLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__int(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__GetParamLog(struct soap *soap, const struct sws__GetParamLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__GetParamLog);
	if (soap_out_sws__GetParamLog(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__GetParamLog(struct soap *soap, const char *tag, int id, const struct sws__GetParamLog *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__GetParamLog), type);
	soap_out_xsd__int(soap, "in0", -1, &a->in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sws__GetParamLog * SOAP_FMAC4 soap_get_sws__GetParamLog(struct soap *soap, struct sws__GetParamLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__GetParamLog(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sws__GetParamLog * SOAP_FMAC4 soap_in_sws__GetParamLog(struct soap *soap, const char *tag, struct sws__GetParamLog *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sws__GetParamLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__GetParamLog, sizeof(struct sws__GetParamLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sws__GetParamLog(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "in0", &a->in0, "xsd:int"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__GetParamLog *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sws__GetParamLog, 0, sizeof(struct sws__GetParamLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__RecordCheckpoint(struct soap *soap, const struct sws__RecordCheckpoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in0);
	soap_embedded(soap, &a->in1, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__RecordCheckpoint(struct soap *soap, struct sws__RecordCheckpoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in0);
	soap_default_xsd__string(soap, &a->in1);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__RecordCheckpoint(struct soap *soap, const struct sws__RecordCheckpoint *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__RecordCheckpoint);
	if (soap_out_sws__RecordCheckpoint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__RecordCheckpoint(struct soap *soap, const char *tag, int id, const struct sws__RecordCheckpoint *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__RecordCheckpoint), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "");
	soap_out_xsd__string(soap, "in1", -1, &a->in1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sws__RecordCheckpoint * SOAP_FMAC4 soap_get_sws__RecordCheckpoint(struct soap *soap, struct sws__RecordCheckpoint *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__RecordCheckpoint(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sws__RecordCheckpoint * SOAP_FMAC4 soap_in_sws__RecordCheckpoint(struct soap *soap, const char *tag, struct sws__RecordCheckpoint *a, const char *type)
{
	short soap_flag_in0 = 1, soap_flag_in1 = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sws__RecordCheckpoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__RecordCheckpoint, sizeof(struct sws__RecordCheckpoint), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sws__RecordCheckpoint(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap_flag_in1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in1", &a->in1, "xsd:string"))
				{	soap_flag_in1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__RecordCheckpoint *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sws__RecordCheckpoint, 0, sizeof(struct sws__RecordCheckpoint), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__Detach(struct soap *soap, const struct sws__Detach *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient param_1 skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__Detach(struct soap *soap, struct sws__Detach *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient param_1 skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__Detach(struct soap *soap, const struct sws__Detach *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__Detach);
	if (soap_out_sws__Detach(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__Detach(struct soap *soap, const char *tag, int id, const struct sws__Detach *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__Detach), type);
	/* transient param_1 skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sws__Detach * SOAP_FMAC4 soap_get_sws__Detach(struct soap *soap, struct sws__Detach *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__Detach(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sws__Detach * SOAP_FMAC4 soap_in_sws__Detach(struct soap *soap, const char *tag, struct sws__Detach *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sws__Detach *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__Detach, sizeof(struct sws__Detach), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sws__Detach(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient param_1 skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__Detach *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sws__Detach, 0, sizeof(struct sws__Detach), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__Attach(struct soap *soap, const struct sws__Attach *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__Attach(struct soap *soap, struct sws__Attach *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__Attach(struct soap *soap, const struct sws__Attach *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__Attach);
	if (soap_out_sws__Attach(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__Attach(struct soap *soap, const char *tag, int id, const struct sws__Attach *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__Attach), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sws__Attach * SOAP_FMAC4 soap_get_sws__Attach(struct soap *soap, struct sws__Attach *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__Attach(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sws__Attach * SOAP_FMAC4 soap_in_sws__Attach(struct soap *soap, const char *tag, struct sws__Attach *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sws__Attach *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__Attach, sizeof(struct sws__Attach), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sws__Attach(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__Attach *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sws__Attach, 0, sizeof(struct sws__Attach), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__AddChild(struct soap *soap, const struct sws__AddChild *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->__in, SOAP_TYPE_sws__AddChildRequest);
	soap_serialize_sws__AddChildRequest(soap, &a->__in);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__AddChild(struct soap *soap, struct sws__AddChild *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_sws__AddChildRequest(soap, &a->__in);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__AddChild(struct soap *soap, const struct sws__AddChild *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__AddChild);
	if (soap_out_sws__AddChild(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__AddChild(struct soap *soap, const char *tag, int id, const struct sws__AddChild *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__AddChild), type);
	soap_out_sws__AddChildRequest(soap, "-in", -1, &a->__in, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sws__AddChild * SOAP_FMAC4 soap_get_sws__AddChild(struct soap *soap, struct sws__AddChild *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__AddChild(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sws__AddChild * SOAP_FMAC4 soap_in_sws__AddChild(struct soap *soap, const char *tag, struct sws__AddChild *a, const char *type)
{
	short soap_flag___in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sws__AddChild *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__AddChild, sizeof(struct sws__AddChild), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sws__AddChild(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___in && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_sws__AddChildRequest(soap, "-in", &a->__in, "sws:AddChildRequest"))
				{	soap_flag___in = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag___in))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__AddChild *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sws__AddChild, 0, sizeof(struct sws__AddChild), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrp__GetResourcePropertyDocument(struct soap *soap, const struct wsrp__GetResourcePropertyDocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrp__GetResourcePropertyDocument(struct soap *soap, struct wsrp__GetResourcePropertyDocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrp__GetResourcePropertyDocument(struct soap *soap, const struct wsrp__GetResourcePropertyDocument *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrp__GetResourcePropertyDocument);
	if (soap_out_wsrp__GetResourcePropertyDocument(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrp__GetResourcePropertyDocument(struct soap *soap, const char *tag, int id, const struct wsrp__GetResourcePropertyDocument *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrp__GetResourcePropertyDocument), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wsrp__GetResourcePropertyDocument * SOAP_FMAC4 soap_get_wsrp__GetResourcePropertyDocument(struct soap *soap, struct wsrp__GetResourcePropertyDocument *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrp__GetResourcePropertyDocument(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wsrp__GetResourcePropertyDocument * SOAP_FMAC4 soap_in_wsrp__GetResourcePropertyDocument(struct soap *soap, const char *tag, struct wsrp__GetResourcePropertyDocument *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct wsrp__GetResourcePropertyDocument *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrp__GetResourcePropertyDocument, sizeof(struct wsrp__GetResourcePropertyDocument), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_wsrp__GetResourcePropertyDocument(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrp__GetResourcePropertyDocument *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_wsrp__GetResourcePropertyDocument, 0, sizeof(struct wsrp__GetResourcePropertyDocument), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrp__SetResourceProperties(struct soap *soap, const struct wsrp__SetResourceProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrp__SetResourceProperties(struct soap *soap, struct wsrp__SetResourceProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsrp__Insert = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrp__SetResourceProperties(struct soap *soap, const struct wsrp__SetResourceProperties *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrp__SetResourceProperties);
	if (soap_out_wsrp__SetResourceProperties(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrp__SetResourceProperties(struct soap *soap, const char *tag, int id, const struct wsrp__SetResourceProperties *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrp__SetResourceProperties), type);
	soap_outliteral(soap, "wsrp:Insert", &a->wsrp__Insert);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wsrp__SetResourceProperties * SOAP_FMAC4 soap_get_wsrp__SetResourceProperties(struct soap *soap, struct wsrp__SetResourceProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrp__SetResourceProperties(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wsrp__SetResourceProperties * SOAP_FMAC4 soap_in_wsrp__SetResourceProperties(struct soap *soap, const char *tag, struct wsrp__SetResourceProperties *a, const char *type)
{
	short soap_flag_wsrp__Insert = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct wsrp__SetResourceProperties *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrp__SetResourceProperties, sizeof(struct wsrp__SetResourceProperties), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_wsrp__SetResourceProperties(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrp__Insert && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "wsrp:Insert", &a->wsrp__Insert))
				{	soap_flag_wsrp__Insert = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrp__SetResourceProperties *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_wsrp__SetResourceProperties, 0, sizeof(struct wsrp__SetResourceProperties), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrp__GetMultipleResourceProperties(struct soap *soap, const struct wsrp__GetMultipleResourceProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in, SOAP_TYPE_wsrp__GetMultipleResourcePropertiesRequest);
	soap_serialize_wsrp__GetMultipleResourcePropertiesRequest(soap, &a->in);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrp__GetMultipleResourceProperties(struct soap *soap, struct wsrp__GetMultipleResourceProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsrp__GetMultipleResourcePropertiesRequest(soap, &a->in);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrp__GetMultipleResourceProperties(struct soap *soap, const struct wsrp__GetMultipleResourceProperties *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrp__GetMultipleResourceProperties);
	if (soap_out_wsrp__GetMultipleResourceProperties(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrp__GetMultipleResourceProperties(struct soap *soap, const char *tag, int id, const struct wsrp__GetMultipleResourceProperties *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrp__GetMultipleResourceProperties), type);
	soap_out_wsrp__GetMultipleResourcePropertiesRequest(soap, "in", -1, &a->in, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wsrp__GetMultipleResourceProperties * SOAP_FMAC4 soap_get_wsrp__GetMultipleResourceProperties(struct soap *soap, struct wsrp__GetMultipleResourceProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrp__GetMultipleResourceProperties(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wsrp__GetMultipleResourceProperties * SOAP_FMAC4 soap_in_wsrp__GetMultipleResourceProperties(struct soap *soap, const char *tag, struct wsrp__GetMultipleResourceProperties *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct wsrp__GetMultipleResourceProperties *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrp__GetMultipleResourceProperties, sizeof(struct wsrp__GetMultipleResourceProperties), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_wsrp__GetMultipleResourceProperties(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsrp__GetMultipleResourcePropertiesRequest(soap, "in", &a->in, "wsrp:GetMultipleResourcePropertiesRequest"))
				{	soap_flag_in = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrp__GetMultipleResourceProperties *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_wsrp__GetMultipleResourceProperties, 0, sizeof(struct wsrp__GetMultipleResourceProperties), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrp__GetResourceProperty(struct soap *soap, const struct wsrp__GetResourceProperty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in_, SOAP_TYPE_PointerToGetResourcePropertyRequest);
	soap_serialize_PointerToGetResourcePropertyRequest(soap, &a->in_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrp__GetResourceProperty(struct soap *soap, struct wsrp__GetResourceProperty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrp__GetResourceProperty(struct soap *soap, const struct wsrp__GetResourceProperty *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrp__GetResourceProperty);
	if (soap_out_wsrp__GetResourceProperty(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrp__GetResourceProperty(struct soap *soap, const char *tag, int id, const struct wsrp__GetResourceProperty *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrp__GetResourceProperty), type);
	soap_out_PointerToGetResourcePropertyRequest(soap, "in", -1, &a->in_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wsrp__GetResourceProperty * SOAP_FMAC4 soap_get_wsrp__GetResourceProperty(struct soap *soap, struct wsrp__GetResourceProperty *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrp__GetResourceProperty(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wsrp__GetResourceProperty * SOAP_FMAC4 soap_in_wsrp__GetResourceProperty(struct soap *soap, const char *tag, struct wsrp__GetResourceProperty *a, const char *type)
{
	short soap_flag_in_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct wsrp__GetResourceProperty *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrp__GetResourceProperty, sizeof(struct wsrp__GetResourceProperty), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_wsrp__GetResourceProperty(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToGetResourcePropertyRequest(soap, "in", &a->in_, "GetResourcePropertyRequest"))
				{	soap_flag_in_ = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrp__GetResourceProperty *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_wsrp__GetResourceProperty, 0, sizeof(struct wsrp__GetResourceProperty), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__DetachResponse(struct soap *soap, const struct sws__DetachResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient rubbish skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__DetachResponse(struct soap *soap, struct sws__DetachResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient rubbish skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__DetachResponse(struct soap *soap, const struct sws__DetachResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__DetachResponse);
	if (soap_out_sws__DetachResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__DetachResponse(struct soap *soap, const char *tag, int id, const struct sws__DetachResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__DetachResponse), type);
	if (a->rubbish)
		soap_element_result(soap, "rubbish");
	/* transient rubbish skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sws__DetachResponse * SOAP_FMAC4 soap_get_sws__DetachResponse(struct soap *soap, struct sws__DetachResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__DetachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sws__DetachResponse * SOAP_FMAC4 soap_in_sws__DetachResponse(struct soap *soap, const char *tag, struct sws__DetachResponse *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sws__DetachResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__DetachResponse, sizeof(struct sws__DetachResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sws__DetachResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient rubbish skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__DetachResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sws__DetachResponse, 0, sizeof(struct sws__DetachResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__AddChildResponse(struct soap *soap, const struct sws__AddChildResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient rubbish skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__AddChildResponse(struct soap *soap, struct sws__AddChildResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient rubbish skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__AddChildResponse(struct soap *soap, const struct sws__AddChildResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__AddChildResponse);
	if (soap_out_sws__AddChildResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__AddChildResponse(struct soap *soap, const char *tag, int id, const struct sws__AddChildResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__AddChildResponse), type);
	if (a->rubbish)
		soap_element_result(soap, "rubbish");
	/* transient rubbish skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sws__AddChildResponse * SOAP_FMAC4 soap_get_sws__AddChildResponse(struct soap *soap, struct sws__AddChildResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__AddChildResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sws__AddChildResponse * SOAP_FMAC4 soap_in_sws__AddChildResponse(struct soap *soap, const char *tag, struct sws__AddChildResponse *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sws__AddChildResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__AddChildResponse, sizeof(struct sws__AddChildResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sws__AddChildResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient rubbish skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__AddChildResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sws__AddChildResponse, 0, sizeof(struct sws__AddChildResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__AddChildRequest(struct soap *soap, const struct sws__AddChildRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->epr, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->epr);
	soap_embedded(soap, &a->name, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__AddChildRequest(struct soap *soap, struct sws__AddChildRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->epr);
	soap_default_xsd__string(soap, &a->name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__AddChildRequest(struct soap *soap, const struct sws__AddChildRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__AddChildRequest);
	if (soap_out_sws__AddChildRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__AddChildRequest(struct soap *soap, const char *tag, int id, const struct sws__AddChildRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__AddChildRequest), type);
	soap_out_xsd__string(soap, "epr", -1, &a->epr, "");
	soap_out_xsd__string(soap, "name", -1, &a->name, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sws__AddChildRequest * SOAP_FMAC4 soap_get_sws__AddChildRequest(struct soap *soap, struct sws__AddChildRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__AddChildRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sws__AddChildRequest * SOAP_FMAC4 soap_in_sws__AddChildRequest(struct soap *soap, const char *tag, struct sws__AddChildRequest *a, const char *type)
{
	short soap_flag_epr = 1, soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sws__AddChildRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__AddChildRequest, sizeof(struct sws__AddChildRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sws__AddChildRequest(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_epr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "epr", &a->epr, "xsd:string"))
				{	soap_flag_epr = 0;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__AddChildRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sws__AddChildRequest, 0, sizeof(struct sws__AddChildRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrp__SetResourcePropertiesResponse(struct soap *soap, const struct wsrp__SetResourcePropertiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient rubbish skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrp__SetResourcePropertiesResponse(struct soap *soap, struct wsrp__SetResourcePropertiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient rubbish skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrp__SetResourcePropertiesResponse(struct soap *soap, const struct wsrp__SetResourcePropertiesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrp__SetResourcePropertiesResponse);
	if (soap_out_wsrp__SetResourcePropertiesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrp__SetResourcePropertiesResponse(struct soap *soap, const char *tag, int id, const struct wsrp__SetResourcePropertiesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrp__SetResourcePropertiesResponse), type);
	if (a->rubbish)
		soap_element_result(soap, "rubbish");
	/* transient rubbish skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wsrp__SetResourcePropertiesResponse * SOAP_FMAC4 soap_get_wsrp__SetResourcePropertiesResponse(struct soap *soap, struct wsrp__SetResourcePropertiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrp__SetResourcePropertiesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wsrp__SetResourcePropertiesResponse * SOAP_FMAC4 soap_in_wsrp__SetResourcePropertiesResponse(struct soap *soap, const char *tag, struct wsrp__SetResourcePropertiesResponse *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct wsrp__SetResourcePropertiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrp__SetResourcePropertiesResponse, sizeof(struct wsrp__SetResourcePropertiesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_wsrp__SetResourcePropertiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient rubbish skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrp__SetResourcePropertiesResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_wsrp__SetResourcePropertiesResponse, 0, sizeof(struct wsrp__SetResourcePropertiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrp__GetMultipleResourcePropertiesRequest(struct soap *soap, struct wsrp__GetMultipleResourcePropertiesRequest const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_wsrp__GetMultipleResourcePropertiesRequest))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_wsrp__ResourcePropertyStruct);
			soap_serialize_wsrp__ResourcePropertyStruct(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrp__GetMultipleResourcePropertiesRequest(struct soap *soap, struct wsrp__GetMultipleResourcePropertiesRequest *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrp__GetMultipleResourcePropertiesRequest(struct soap *soap, const struct wsrp__GetMultipleResourcePropertiesRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_wsrp__GetMultipleResourcePropertiesRequest);
	if (soap_out_wsrp__GetMultipleResourcePropertiesRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrp__GetMultipleResourcePropertiesRequest(struct soap *soap, const char *tag, int id, const struct wsrp__GetMultipleResourcePropertiesRequest *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_wsrp__GetMultipleResourcePropertiesRequest);
	if (id < 0)
		return soap->error;
	soap_element_begin_out(soap, tag, id, type);
	for (i = 0; i < n; i++)
	{
		soap_out_wsrp__ResourcePropertyStruct(soap, "item", -1, &a->__ptr[i], "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wsrp__GetMultipleResourcePropertiesRequest * SOAP_FMAC4 soap_get_wsrp__GetMultipleResourcePropertiesRequest(struct soap *soap, struct wsrp__GetMultipleResourcePropertiesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrp__GetMultipleResourcePropertiesRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wsrp__GetMultipleResourcePropertiesRequest * SOAP_FMAC4 soap_in_wsrp__GetMultipleResourcePropertiesRequest(struct soap *soap, const char *tag, struct wsrp__GetMultipleResourcePropertiesRequest *a, const char *type)
{	int i, j;
	struct wsrp__ResourcePropertyStruct *p;
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct wsrp__GetMultipleResourcePropertiesRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrp__GetMultipleResourcePropertiesRequest, sizeof(struct wsrp__GetMultipleResourcePropertiesRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_wsrp__GetMultipleResourcePropertiesRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct wsrp__ResourcePropertyStruct *)soap_malloc(soap, sizeof(struct wsrp__ResourcePropertyStruct) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_wsrp__ResourcePropertyStruct(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_wsrp__ResourcePropertyStruct(soap, NULL, a->__ptr + i, "wsrp:ResourcePropertyStruct"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (struct wsrp__ResourcePropertyStruct *)soap_push_block(soap, sizeof(struct wsrp__ResourcePropertyStruct));
				if (!p)
					return NULL;
				soap_default_wsrp__ResourcePropertyStruct(soap, p);
				if (!soap_in_wsrp__ResourcePropertyStruct(soap, NULL, p, "wsrp:ResourcePropertyStruct"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (struct wsrp__ResourcePropertyStruct *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrp__GetMultipleResourcePropertiesRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_wsrp__GetMultipleResourcePropertiesRequest, 0, sizeof(struct wsrp__GetMultipleResourcePropertiesRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrp__ResourcePropertyStruct(struct soap *soap, const struct wsrp__ResourcePropertyStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ResourceProperty, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->ResourceProperty);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrp__ResourcePropertyStruct(struct soap *soap, struct wsrp__ResourcePropertyStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->ResourceProperty);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrp__ResourcePropertyStruct(struct soap *soap, const struct wsrp__ResourcePropertyStruct *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrp__ResourcePropertyStruct);
	if (soap_out_wsrp__ResourcePropertyStruct(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrp__ResourcePropertyStruct(struct soap *soap, const char *tag, int id, const struct wsrp__ResourcePropertyStruct *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrp__ResourcePropertyStruct), type);
	soap_out_xsd__string(soap, "ResourceProperty", -1, &a->ResourceProperty, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wsrp__ResourcePropertyStruct * SOAP_FMAC4 soap_get_wsrp__ResourcePropertyStruct(struct soap *soap, struct wsrp__ResourcePropertyStruct *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrp__ResourcePropertyStruct(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wsrp__ResourcePropertyStruct * SOAP_FMAC4 soap_in_wsrp__ResourcePropertyStruct(struct soap *soap, const char *tag, struct wsrp__ResourcePropertyStruct *a, const char *type)
{
	short soap_flag_ResourceProperty = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct wsrp__ResourcePropertyStruct *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrp__ResourcePropertyStruct, sizeof(struct wsrp__ResourcePropertyStruct), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_wsrp__ResourcePropertyStruct(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceProperty && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "ResourceProperty", &a->ResourceProperty, "xsd:string"))
				{	soap_flag_ResourceProperty = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrp__ResourcePropertyStruct *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_wsrp__ResourcePropertyStruct, 0, sizeof(struct wsrp__ResourcePropertyStruct), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrp__GetResourcePropertyResponse(struct soap *soap, const struct wsrp__GetResourcePropertyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ResourceProperty, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->ResourceProperty);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrp__GetResourcePropertyResponse(struct soap *soap, struct wsrp__GetResourcePropertyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->ResourceProperty);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrp__GetResourcePropertyResponse(struct soap *soap, const struct wsrp__GetResourcePropertyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrp__GetResourcePropertyResponse);
	if (soap_out_wsrp__GetResourcePropertyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrp__GetResourcePropertyResponse(struct soap *soap, const char *tag, int id, const struct wsrp__GetResourcePropertyResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrp__GetResourcePropertyResponse), type);
	soap_out_xsd__string(soap, "ResourceProperty", -1, &a->ResourceProperty, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wsrp__GetResourcePropertyResponse * SOAP_FMAC4 soap_get_wsrp__GetResourcePropertyResponse(struct soap *soap, struct wsrp__GetResourcePropertyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrp__GetResourcePropertyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wsrp__GetResourcePropertyResponse * SOAP_FMAC4 soap_in_wsrp__GetResourcePropertyResponse(struct soap *soap, const char *tag, struct wsrp__GetResourcePropertyResponse *a, const char *type)
{
	short soap_flag_ResourceProperty = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct wsrp__GetResourcePropertyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrp__GetResourcePropertyResponse, sizeof(struct wsrp__GetResourcePropertyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_wsrp__GetResourcePropertyResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceProperty && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "ResourceProperty", &a->ResourceProperty, "xsd:string"))
				{	soap_flag_ResourceProperty = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrp__GetResourcePropertyResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_wsrp__GetResourcePropertyResponse, 0, sizeof(struct wsrp__GetResourcePropertyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_GetResourcePropertyRequest(struct soap *soap, const struct GetResourcePropertyRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->in_, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->in_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_GetResourcePropertyRequest(struct soap *soap, struct GetResourcePropertyRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->in_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_GetResourcePropertyRequest(struct soap *soap, const struct GetResourcePropertyRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_GetResourcePropertyRequest);
	if (soap_out_GetResourcePropertyRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_GetResourcePropertyRequest(struct soap *soap, const char *tag, int id, const struct GetResourcePropertyRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_GetResourcePropertyRequest), type);
	soap_out_xsd__string(soap, "in", -1, &a->in_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct GetResourcePropertyRequest * SOAP_FMAC4 soap_get_GetResourcePropertyRequest(struct soap *soap, struct GetResourcePropertyRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_GetResourcePropertyRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct GetResourcePropertyRequest * SOAP_FMAC4 soap_in_GetResourcePropertyRequest(struct soap *soap, const char *tag, struct GetResourcePropertyRequest *a, const char *type)
{
	short soap_flag_in_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct GetResourcePropertyRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_GetResourcePropertyRequest, sizeof(struct GetResourcePropertyRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_GetResourcePropertyRequest(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "in", &a->in_, "xsd:string"))
				{	soap_flag_in_ = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct GetResourcePropertyRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_GetResourcePropertyRequest, 0, sizeof(struct GetResourcePropertyRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__PutParamLogResponse(struct soap *soap, const struct sws__PutParamLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _rubbish skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__PutParamLogResponse(struct soap *soap, struct sws__PutParamLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _rubbish skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__PutParamLogResponse(struct soap *soap, const struct sws__PutParamLogResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__PutParamLogResponse);
	if (soap_out_sws__PutParamLogResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__PutParamLogResponse(struct soap *soap, const char *tag, int id, const struct sws__PutParamLogResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__PutParamLogResponse), type);
	if (a->_rubbish)
		soap_element_result(soap, "rubbish");
	/* transient _rubbish skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sws__PutParamLogResponse * SOAP_FMAC4 soap_get_sws__PutParamLogResponse(struct soap *soap, struct sws__PutParamLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__PutParamLogResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sws__PutParamLogResponse * SOAP_FMAC4 soap_in_sws__PutParamLogResponse(struct soap *soap, const char *tag, struct sws__PutParamLogResponse *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sws__PutParamLogResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__PutParamLogResponse, sizeof(struct sws__PutParamLogResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sws__PutParamLogResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _rubbish skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__PutParamLogResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sws__PutParamLogResponse, 0, sizeof(struct sws__PutParamLogResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrp__DestroyResponse(struct soap *soap, const struct wsrp__DestroyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _rubbish skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrp__DestroyResponse(struct soap *soap, struct wsrp__DestroyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _rubbish skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrp__DestroyResponse(struct soap *soap, const struct wsrp__DestroyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrp__DestroyResponse);
	if (soap_out_wsrp__DestroyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrp__DestroyResponse(struct soap *soap, const char *tag, int id, const struct wsrp__DestroyResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrp__DestroyResponse), type);
	if (a->_rubbish)
		soap_element_result(soap, "rubbish");
	/* transient _rubbish skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct wsrp__DestroyResponse * SOAP_FMAC4 soap_get_wsrp__DestroyResponse(struct soap *soap, struct wsrp__DestroyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrp__DestroyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wsrp__DestroyResponse * SOAP_FMAC4 soap_in_wsrp__DestroyResponse(struct soap *soap, const char *tag, struct wsrp__DestroyResponse *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct wsrp__DestroyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrp__DestroyResponse, sizeof(struct wsrp__DestroyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_wsrp__DestroyResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _rubbish skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrp__DestroyResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_wsrp__DestroyResponse, 0, sizeof(struct wsrp__DestroyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__AttachResponse(struct soap *soap, const struct sws__AttachResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ReG_USCOREsteer_USCOREmessage, SOAP_TYPE_steerMessage);
	soap_serialize_steerMessage(soap, &a->ReG_USCOREsteer_USCOREmessage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__AttachResponse(struct soap *soap, struct sws__AttachResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_steerMessage(soap, &a->ReG_USCOREsteer_USCOREmessage);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__AttachResponse(struct soap *soap, const struct sws__AttachResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__AttachResponse);
	if (soap_out_sws__AttachResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__AttachResponse(struct soap *soap, const char *tag, int id, const struct sws__AttachResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__AttachResponse), type);
	soap_element_result(soap, "ReG_steer_message");
	soap_out_steerMessage(soap, "ReG_steer_message", -1, &a->ReG_USCOREsteer_USCOREmessage, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sws__AttachResponse * SOAP_FMAC4 soap_get_sws__AttachResponse(struct soap *soap, struct sws__AttachResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__AttachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sws__AttachResponse * SOAP_FMAC4 soap_in_sws__AttachResponse(struct soap *soap, const char *tag, struct sws__AttachResponse *a, const char *type)
{
	short soap_flag_ReG_USCOREsteer_USCOREmessage = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sws__AttachResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__AttachResponse, sizeof(struct sws__AttachResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sws__AttachResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReG_USCOREsteer_USCOREmessage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_steerMessage(soap, "ReG_steer_message", &a->ReG_USCOREsteer_USCOREmessage, "steerMessage"))
				{	soap_flag_ReG_USCOREsteer_USCOREmessage = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ReG_USCOREsteer_USCOREmessage))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__AttachResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sws__AttachResponse, 0, sizeof(struct sws__AttachResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_steerMessage(struct soap *soap, const struct steerMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Supported_USCOREcommands, SOAP_TYPE_supp_cmds);
	soap_serialize_supp_cmds(soap, &a->Supported_USCOREcommands);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_steerMessage(struct soap *soap, struct steerMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_supp_cmds(soap, &a->Supported_USCOREcommands);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_steerMessage(struct soap *soap, const struct steerMessage *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_steerMessage);
	if (soap_out_steerMessage(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_steerMessage(struct soap *soap, const char *tag, int id, const struct steerMessage *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_steerMessage), type);
	soap_out_supp_cmds(soap, "Supported_commands", -1, &a->Supported_USCOREcommands, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct steerMessage * SOAP_FMAC4 soap_get_steerMessage(struct soap *soap, struct steerMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in_steerMessage(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct steerMessage * SOAP_FMAC4 soap_in_steerMessage(struct soap *soap, const char *tag, struct steerMessage *a, const char *type)
{
	short soap_flag_Supported_USCOREcommands = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct steerMessage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_steerMessage, sizeof(struct steerMessage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_steerMessage(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Supported_USCOREcommands && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_supp_cmds(soap, "Supported_commands", &a->Supported_USCOREcommands, "Command"))
				{	soap_flag_Supported_USCOREcommands = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Supported_USCOREcommands))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct steerMessage *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_steerMessage, 0, sizeof(struct steerMessage), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_supp_cmds(struct soap *soap, struct supp_cmds const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_supp_cmds))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_Command);
			soap_serialize_Command(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_supp_cmds(struct soap *soap, struct supp_cmds *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_supp_cmds(struct soap *soap, const struct supp_cmds *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_supp_cmds);
	if (soap_out_supp_cmds(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_supp_cmds(struct soap *soap, const char *tag, int id, const struct supp_cmds *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "Command", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_supp_cmds);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_Command(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct supp_cmds * SOAP_FMAC4 soap_get_supp_cmds(struct soap *soap, struct supp_cmds *p, const char *tag, const char *type)
{
	if ((p = soap_in_supp_cmds(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct supp_cmds * SOAP_FMAC4 soap_in_supp_cmds(struct soap *soap, const char *tag, struct supp_cmds *a, const char *type)
{	int i, j;
	struct Command *p;
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct supp_cmds *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_supp_cmds, sizeof(struct supp_cmds), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_supp_cmds(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct Command *)soap_malloc(soap, sizeof(struct Command) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_Command(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_Command(soap, NULL, a->__ptr + i, "Command"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (struct Command *)soap_push_block(soap, sizeof(struct Command));
				if (!p)
					return NULL;
				soap_default_Command(soap, p);
				if (!soap_in_Command(soap, NULL, p, "Command"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (struct Command *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct supp_cmds *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_supp_cmds, 0, sizeof(struct supp_cmds), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_Command(struct soap *soap, const struct Command *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Cmd_USCOREid, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &a->Cmd_USCOREname, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->Cmd_USCOREname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_Command(struct soap *soap, struct Command *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__int(soap, &a->Cmd_USCOREid);
	soap_default_xsd__string(soap, &a->Cmd_USCOREname);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_Command(struct soap *soap, const struct Command *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Command);
	if (soap_out_Command(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Command(struct soap *soap, const char *tag, int id, const struct Command *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Command), type);
	soap_out_xsd__int(soap, "Cmd_id", -1, &a->Cmd_USCOREid, "");
	soap_out_xsd__string(soap, "Cmd_name", -1, &a->Cmd_USCOREname, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct Command * SOAP_FMAC4 soap_get_Command(struct soap *soap, struct Command *p, const char *tag, const char *type)
{
	if ((p = soap_in_Command(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct Command * SOAP_FMAC4 soap_in_Command(struct soap *soap, const char *tag, struct Command *a, const char *type)
{
	short soap_flag_Cmd_USCOREid = 1, soap_flag_Cmd_USCOREname = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct Command *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Command, sizeof(struct Command), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_Command(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Cmd_USCOREid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "Cmd_id", &a->Cmd_USCOREid, "xsd:int"))
				{	soap_flag_Cmd_USCOREid = 0;
					continue;
				}
			if (soap_flag_Cmd_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "Cmd_name", &a->Cmd_USCOREname, "xsd:string"))
				{	soap_flag_Cmd_USCOREname = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Cmd_USCOREid))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct Command *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_Command, 0, sizeof(struct Command), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__RecordCheckpointResponse(struct soap *soap, const struct sws__RecordCheckpointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_RecordCheckpointReturn, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->_RecordCheckpointReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__RecordCheckpointResponse(struct soap *soap, struct sws__RecordCheckpointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->_RecordCheckpointReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__RecordCheckpointResponse(struct soap *soap, const struct sws__RecordCheckpointResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__RecordCheckpointResponse);
	if (soap_out_sws__RecordCheckpointResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__RecordCheckpointResponse(struct soap *soap, const char *tag, int id, const struct sws__RecordCheckpointResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__RecordCheckpointResponse), type);
	if (a->_RecordCheckpointReturn)
		soap_element_result(soap, "RecordCheckpointReturn");
	soap_out_xsd__string(soap, "RecordCheckpointReturn", -1, &a->_RecordCheckpointReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sws__RecordCheckpointResponse * SOAP_FMAC4 soap_get_sws__RecordCheckpointResponse(struct soap *soap, struct sws__RecordCheckpointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__RecordCheckpointResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sws__RecordCheckpointResponse * SOAP_FMAC4 soap_in_sws__RecordCheckpointResponse(struct soap *soap, const char *tag, struct sws__RecordCheckpointResponse *a, const char *type)
{
	short soap_flag__RecordCheckpointReturn = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sws__RecordCheckpointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__RecordCheckpointResponse, sizeof(struct sws__RecordCheckpointResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sws__RecordCheckpointResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__RecordCheckpointReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, NULL, &a->_RecordCheckpointReturn, "xsd:string"))
				{	soap_flag__RecordCheckpointReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__RecordCheckpointResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sws__RecordCheckpointResponse, 0, sizeof(struct sws__RecordCheckpointResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sws__GetParamLogResponse(struct soap *soap, const struct sws__GetParamLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->LogValues, SOAP_TYPE_xsd__string);
	soap_serialize_xsd__string(soap, &a->LogValues);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sws__GetParamLogResponse(struct soap *soap, struct sws__GetParamLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->LogValues);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sws__GetParamLogResponse(struct soap *soap, const struct sws__GetParamLogResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sws__GetParamLogResponse);
	if (soap_out_sws__GetParamLogResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sws__GetParamLogResponse(struct soap *soap, const char *tag, int id, const struct sws__GetParamLogResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sws__GetParamLogResponse), type);
	if (a->LogValues)
		soap_element_result(soap, "LogValues");
	soap_out_xsd__string(soap, "LogValues", -1, &a->LogValues, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct sws__GetParamLogResponse * SOAP_FMAC4 soap_get_sws__GetParamLogResponse(struct soap *soap, struct sws__GetParamLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sws__GetParamLogResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sws__GetParamLogResponse * SOAP_FMAC4 soap_in_sws__GetParamLogResponse(struct soap *soap, const char *tag, struct sws__GetParamLogResponse *a, const char *type)
{
	short soap_flag_LogValues = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct sws__GetParamLogResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sws__GetParamLogResponse, sizeof(struct sws__GetParamLogResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->alloced)
		soap_default_sws__GetParamLogResponse(soap, a);
	if (soap->body && !*soap->href)
	{	for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LogValues && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "LogValues", &a->LogValues, "xsd:string"))
				{	soap_flag_LogValues = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sws__GetParamLogResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_sws__GetParamLogResponse, 0, sizeof(struct sws__GetParamLogResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorgt__addNodeResponse(struct soap *soap, struct rgt__addNodeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgt__addNodeResponse))
		soap_serialize_rgt__addNodeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorgt__addNodeResponse(struct soap *soap, struct rgt__addNodeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorgt__addNodeResponse);
	if (soap_out_PointerTorgt__addNodeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorgt__addNodeResponse(struct soap *soap, const char *tag, int id, struct rgt__addNodeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rgt__addNodeResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rgt__addNodeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rgt__addNodeResponse ** SOAP_FMAC4 soap_get_PointerTorgt__addNodeResponse(struct soap *soap, struct rgt__addNodeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgt__addNodeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__addNodeResponse ** SOAP_FMAC4 soap_in_PointerTorgt__addNodeResponse(struct soap *soap, const char *tag, struct rgt__addNodeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct rgt__addNodeResponse **)soap_malloc(soap, sizeof(struct rgt__addNodeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rgt__addNodeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rgt__addNodeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rgt__addNodeResponse, sizeof(struct rgt__addNodeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorgt__getParentNodeResponse(struct soap *soap, struct rgt__getParentNodeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgt__getParentNodeResponse))
		soap_serialize_rgt__getParentNodeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorgt__getParentNodeResponse(struct soap *soap, struct rgt__getParentNodeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorgt__getParentNodeResponse);
	if (soap_out_PointerTorgt__getParentNodeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorgt__getParentNodeResponse(struct soap *soap, const char *tag, int id, struct rgt__getParentNodeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rgt__getParentNodeResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rgt__getParentNodeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rgt__getParentNodeResponse ** SOAP_FMAC4 soap_get_PointerTorgt__getParentNodeResponse(struct soap *soap, struct rgt__getParentNodeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgt__getParentNodeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__getParentNodeResponse ** SOAP_FMAC4 soap_in_PointerTorgt__getParentNodeResponse(struct soap *soap, const char *tag, struct rgt__getParentNodeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct rgt__getParentNodeResponse **)soap_malloc(soap, sizeof(struct rgt__getParentNodeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rgt__getParentNodeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rgt__getParentNodeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rgt__getParentNodeResponse, sizeof(struct rgt__getParentNodeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorgt__getCheckPointDataResponse(struct soap *soap, struct rgt__getCheckPointDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgt__getCheckPointDataResponse))
		soap_serialize_rgt__getCheckPointDataResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorgt__getCheckPointDataResponse(struct soap *soap, struct rgt__getCheckPointDataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorgt__getCheckPointDataResponse);
	if (soap_out_PointerTorgt__getCheckPointDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorgt__getCheckPointDataResponse(struct soap *soap, const char *tag, int id, struct rgt__getCheckPointDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rgt__getCheckPointDataResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rgt__getCheckPointDataResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rgt__getCheckPointDataResponse ** SOAP_FMAC4 soap_get_PointerTorgt__getCheckPointDataResponse(struct soap *soap, struct rgt__getCheckPointDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgt__getCheckPointDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__getCheckPointDataResponse ** SOAP_FMAC4 soap_in_PointerTorgt__getCheckPointDataResponse(struct soap *soap, const char *tag, struct rgt__getCheckPointDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct rgt__getCheckPointDataResponse **)soap_malloc(soap, sizeof(struct rgt__getCheckPointDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rgt__getCheckPointDataResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rgt__getCheckPointDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rgt__getCheckPointDataResponse, sizeof(struct rgt__getCheckPointDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorgt__requestTerminationBeforeResponse(struct soap *soap, struct rgt__requestTerminationBeforeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgt__requestTerminationBeforeResponse))
		soap_serialize_rgt__requestTerminationBeforeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorgt__requestTerminationBeforeResponse(struct soap *soap, struct rgt__requestTerminationBeforeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorgt__requestTerminationBeforeResponse);
	if (soap_out_PointerTorgt__requestTerminationBeforeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorgt__requestTerminationBeforeResponse(struct soap *soap, const char *tag, int id, struct rgt__requestTerminationBeforeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rgt__requestTerminationBeforeResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rgt__requestTerminationBeforeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rgt__requestTerminationBeforeResponse ** SOAP_FMAC4 soap_get_PointerTorgt__requestTerminationBeforeResponse(struct soap *soap, struct rgt__requestTerminationBeforeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgt__requestTerminationBeforeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__requestTerminationBeforeResponse ** SOAP_FMAC4 soap_in_PointerTorgt__requestTerminationBeforeResponse(struct soap *soap, const char *tag, struct rgt__requestTerminationBeforeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct rgt__requestTerminationBeforeResponse **)soap_malloc(soap, sizeof(struct rgt__requestTerminationBeforeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rgt__requestTerminationBeforeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rgt__requestTerminationBeforeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rgt__requestTerminationBeforeResponse, sizeof(struct rgt__requestTerminationBeforeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorgt__getSteeringCommandsResponse(struct soap *soap, struct rgt__getSteeringCommandsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgt__getSteeringCommandsResponse))
		soap_serialize_rgt__getSteeringCommandsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorgt__getSteeringCommandsResponse(struct soap *soap, struct rgt__getSteeringCommandsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorgt__getSteeringCommandsResponse);
	if (soap_out_PointerTorgt__getSteeringCommandsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorgt__getSteeringCommandsResponse(struct soap *soap, const char *tag, int id, struct rgt__getSteeringCommandsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rgt__getSteeringCommandsResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rgt__getSteeringCommandsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rgt__getSteeringCommandsResponse ** SOAP_FMAC4 soap_get_PointerTorgt__getSteeringCommandsResponse(struct soap *soap, struct rgt__getSteeringCommandsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgt__getSteeringCommandsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__getSteeringCommandsResponse ** SOAP_FMAC4 soap_in_PointerTorgt__getSteeringCommandsResponse(struct soap *soap, const char *tag, struct rgt__getSteeringCommandsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct rgt__getSteeringCommandsResponse **)soap_malloc(soap, sizeof(struct rgt__getSteeringCommandsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rgt__getSteeringCommandsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rgt__getSteeringCommandsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rgt__getSteeringCommandsResponse, sizeof(struct rgt__getSteeringCommandsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorgt__destroyResponse(struct soap *soap, struct rgt__destroyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgt__destroyResponse))
		soap_serialize_rgt__destroyResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorgt__destroyResponse(struct soap *soap, struct rgt__destroyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorgt__destroyResponse);
	if (soap_out_PointerTorgt__destroyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorgt__destroyResponse(struct soap *soap, const char *tag, int id, struct rgt__destroyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rgt__destroyResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rgt__destroyResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rgt__destroyResponse ** SOAP_FMAC4 soap_get_PointerTorgt__destroyResponse(struct soap *soap, struct rgt__destroyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgt__destroyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__destroyResponse ** SOAP_FMAC4 soap_in_PointerTorgt__destroyResponse(struct soap *soap, const char *tag, struct rgt__destroyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct rgt__destroyResponse **)soap_malloc(soap, sizeof(struct rgt__destroyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rgt__destroyResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rgt__destroyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rgt__destroyResponse, sizeof(struct rgt__destroyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorgt__setCheckPointDataResponse(struct soap *soap, struct rgt__setCheckPointDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgt__setCheckPointDataResponse))
		soap_serialize_rgt__setCheckPointDataResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorgt__setCheckPointDataResponse(struct soap *soap, struct rgt__setCheckPointDataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorgt__setCheckPointDataResponse);
	if (soap_out_PointerTorgt__setCheckPointDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorgt__setCheckPointDataResponse(struct soap *soap, const char *tag, int id, struct rgt__setCheckPointDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rgt__setCheckPointDataResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rgt__setCheckPointDataResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rgt__setCheckPointDataResponse ** SOAP_FMAC4 soap_get_PointerTorgt__setCheckPointDataResponse(struct soap *soap, struct rgt__setCheckPointDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgt__setCheckPointDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__setCheckPointDataResponse ** SOAP_FMAC4 soap_in_PointerTorgt__setCheckPointDataResponse(struct soap *soap, const char *tag, struct rgt__setCheckPointDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct rgt__setCheckPointDataResponse **)soap_malloc(soap, sizeof(struct rgt__setCheckPointDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rgt__setCheckPointDataResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rgt__setCheckPointDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rgt__setCheckPointDataResponse, sizeof(struct rgt__setCheckPointDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorgt__findServiceDataResponse(struct soap *soap, struct rgt__findServiceDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgt__findServiceDataResponse))
		soap_serialize_rgt__findServiceDataResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorgt__findServiceDataResponse(struct soap *soap, struct rgt__findServiceDataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorgt__findServiceDataResponse);
	if (soap_out_PointerTorgt__findServiceDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorgt__findServiceDataResponse(struct soap *soap, const char *tag, int id, struct rgt__findServiceDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rgt__findServiceDataResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rgt__findServiceDataResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rgt__findServiceDataResponse ** SOAP_FMAC4 soap_get_PointerTorgt__findServiceDataResponse(struct soap *soap, struct rgt__findServiceDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgt__findServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__findServiceDataResponse ** SOAP_FMAC4 soap_in_PointerTorgt__findServiceDataResponse(struct soap *soap, const char *tag, struct rgt__findServiceDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct rgt__findServiceDataResponse **)soap_malloc(soap, sizeof(struct rgt__findServiceDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rgt__findServiceDataResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rgt__findServiceDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rgt__findServiceDataResponse, sizeof(struct rgt__findServiceDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorgt__getInputFileResponse(struct soap *soap, struct rgt__getInputFileResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgt__getInputFileResponse))
		soap_serialize_rgt__getInputFileResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorgt__getInputFileResponse(struct soap *soap, struct rgt__getInputFileResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorgt__getInputFileResponse);
	if (soap_out_PointerTorgt__getInputFileResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorgt__getInputFileResponse(struct soap *soap, const char *tag, int id, struct rgt__getInputFileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rgt__getInputFileResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rgt__getInputFileResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rgt__getInputFileResponse ** SOAP_FMAC4 soap_get_PointerTorgt__getInputFileResponse(struct soap *soap, struct rgt__getInputFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgt__getInputFileResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__getInputFileResponse ** SOAP_FMAC4 soap_in_PointerTorgt__getInputFileResponse(struct soap *soap, const char *tag, struct rgt__getInputFileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct rgt__getInputFileResponse **)soap_malloc(soap, sizeof(struct rgt__getInputFileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rgt__getInputFileResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rgt__getInputFileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rgt__getInputFileResponse, sizeof(struct rgt__getInputFileResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorgt__getChildNodesResponse(struct soap *soap, struct rgt__getChildNodesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgt__getChildNodesResponse))
		soap_serialize_rgt__getChildNodesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorgt__getChildNodesResponse(struct soap *soap, struct rgt__getChildNodesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorgt__getChildNodesResponse);
	if (soap_out_PointerTorgt__getChildNodesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorgt__getChildNodesResponse(struct soap *soap, const char *tag, int id, struct rgt__getChildNodesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rgt__getChildNodesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rgt__getChildNodesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rgt__getChildNodesResponse ** SOAP_FMAC4 soap_get_PointerTorgt__getChildNodesResponse(struct soap *soap, struct rgt__getChildNodesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgt__getChildNodesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__getChildNodesResponse ** SOAP_FMAC4 soap_in_PointerTorgt__getChildNodesResponse(struct soap *soap, const char *tag, struct rgt__getChildNodesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct rgt__getChildNodesResponse **)soap_malloc(soap, sizeof(struct rgt__getChildNodesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rgt__getChildNodesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rgt__getChildNodesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rgt__getChildNodesResponse, sizeof(struct rgt__getChildNodesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorgt__requestTerminationAfterResponse(struct soap *soap, struct rgt__requestTerminationAfterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgt__requestTerminationAfterResponse))
		soap_serialize_rgt__requestTerminationAfterResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorgt__requestTerminationAfterResponse(struct soap *soap, struct rgt__requestTerminationAfterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorgt__requestTerminationAfterResponse);
	if (soap_out_PointerTorgt__requestTerminationAfterResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorgt__requestTerminationAfterResponse(struct soap *soap, const char *tag, int id, struct rgt__requestTerminationAfterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rgt__requestTerminationAfterResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rgt__requestTerminationAfterResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rgt__requestTerminationAfterResponse ** SOAP_FMAC4 soap_get_PointerTorgt__requestTerminationAfterResponse(struct soap *soap, struct rgt__requestTerminationAfterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgt__requestTerminationAfterResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgt__requestTerminationAfterResponse ** SOAP_FMAC4 soap_in_PointerTorgt__requestTerminationAfterResponse(struct soap *soap, const char *tag, struct rgt__requestTerminationAfterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct rgt__requestTerminationAfterResponse **)soap_malloc(soap, sizeof(struct rgt__requestTerminationAfterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rgt__requestTerminationAfterResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rgt__requestTerminationAfterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rgt__requestTerminationAfterResponse, sizeof(struct rgt__requestTerminationAfterResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorgtf__requestTerminationAfterResponse(struct soap *soap, struct rgtf__requestTerminationAfterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgtf__requestTerminationAfterResponse))
		soap_serialize_rgtf__requestTerminationAfterResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorgtf__requestTerminationAfterResponse(struct soap *soap, struct rgtf__requestTerminationAfterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorgtf__requestTerminationAfterResponse);
	if (soap_out_PointerTorgtf__requestTerminationAfterResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorgtf__requestTerminationAfterResponse(struct soap *soap, const char *tag, int id, struct rgtf__requestTerminationAfterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rgtf__requestTerminationAfterResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rgtf__requestTerminationAfterResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rgtf__requestTerminationAfterResponse ** SOAP_FMAC4 soap_get_PointerTorgtf__requestTerminationAfterResponse(struct soap *soap, struct rgtf__requestTerminationAfterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgtf__requestTerminationAfterResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgtf__requestTerminationAfterResponse ** SOAP_FMAC4 soap_in_PointerTorgtf__requestTerminationAfterResponse(struct soap *soap, const char *tag, struct rgtf__requestTerminationAfterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct rgtf__requestTerminationAfterResponse **)soap_malloc(soap, sizeof(struct rgtf__requestTerminationAfterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rgtf__requestTerminationAfterResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rgtf__requestTerminationAfterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rgtf__requestTerminationAfterResponse, sizeof(struct rgtf__requestTerminationAfterResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorgtf__requestTerminationBeforeResponse(struct soap *soap, struct rgtf__requestTerminationBeforeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgtf__requestTerminationBeforeResponse))
		soap_serialize_rgtf__requestTerminationBeforeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorgtf__requestTerminationBeforeResponse(struct soap *soap, struct rgtf__requestTerminationBeforeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorgtf__requestTerminationBeforeResponse);
	if (soap_out_PointerTorgtf__requestTerminationBeforeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorgtf__requestTerminationBeforeResponse(struct soap *soap, const char *tag, int id, struct rgtf__requestTerminationBeforeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rgtf__requestTerminationBeforeResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rgtf__requestTerminationBeforeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rgtf__requestTerminationBeforeResponse ** SOAP_FMAC4 soap_get_PointerTorgtf__requestTerminationBeforeResponse(struct soap *soap, struct rgtf__requestTerminationBeforeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgtf__requestTerminationBeforeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgtf__requestTerminationBeforeResponse ** SOAP_FMAC4 soap_in_PointerTorgtf__requestTerminationBeforeResponse(struct soap *soap, const char *tag, struct rgtf__requestTerminationBeforeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct rgtf__requestTerminationBeforeResponse **)soap_malloc(soap, sizeof(struct rgtf__requestTerminationBeforeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rgtf__requestTerminationBeforeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rgtf__requestTerminationBeforeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rgtf__requestTerminationBeforeResponse, sizeof(struct rgtf__requestTerminationBeforeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorgtf__getActiveTreesResponse(struct soap *soap, struct rgtf__getActiveTreesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgtf__getActiveTreesResponse))
		soap_serialize_rgtf__getActiveTreesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorgtf__getActiveTreesResponse(struct soap *soap, struct rgtf__getActiveTreesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorgtf__getActiveTreesResponse);
	if (soap_out_PointerTorgtf__getActiveTreesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorgtf__getActiveTreesResponse(struct soap *soap, const char *tag, int id, struct rgtf__getActiveTreesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rgtf__getActiveTreesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rgtf__getActiveTreesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rgtf__getActiveTreesResponse ** SOAP_FMAC4 soap_get_PointerTorgtf__getActiveTreesResponse(struct soap *soap, struct rgtf__getActiveTreesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgtf__getActiveTreesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgtf__getActiveTreesResponse ** SOAP_FMAC4 soap_in_PointerTorgtf__getActiveTreesResponse(struct soap *soap, const char *tag, struct rgtf__getActiveTreesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct rgtf__getActiveTreesResponse **)soap_malloc(soap, sizeof(struct rgtf__getActiveTreesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rgtf__getActiveTreesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rgtf__getActiveTreesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rgtf__getActiveTreesResponse, sizeof(struct rgtf__getActiveTreesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorgtf__findServiceDataResponse(struct soap *soap, struct rgtf__findServiceDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgtf__findServiceDataResponse))
		soap_serialize_rgtf__findServiceDataResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorgtf__findServiceDataResponse(struct soap *soap, struct rgtf__findServiceDataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorgtf__findServiceDataResponse);
	if (soap_out_PointerTorgtf__findServiceDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorgtf__findServiceDataResponse(struct soap *soap, const char *tag, int id, struct rgtf__findServiceDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rgtf__findServiceDataResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rgtf__findServiceDataResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rgtf__findServiceDataResponse ** SOAP_FMAC4 soap_get_PointerTorgtf__findServiceDataResponse(struct soap *soap, struct rgtf__findServiceDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgtf__findServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgtf__findServiceDataResponse ** SOAP_FMAC4 soap_in_PointerTorgtf__findServiceDataResponse(struct soap *soap, const char *tag, struct rgtf__findServiceDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct rgtf__findServiceDataResponse **)soap_malloc(soap, sizeof(struct rgtf__findServiceDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rgtf__findServiceDataResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rgtf__findServiceDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rgtf__findServiceDataResponse, sizeof(struct rgtf__findServiceDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorgtf__destroyResponse(struct soap *soap, struct rgtf__destroyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgtf__destroyResponse))
		soap_serialize_rgtf__destroyResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorgtf__destroyResponse(struct soap *soap, struct rgtf__destroyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorgtf__destroyResponse);
	if (soap_out_PointerTorgtf__destroyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorgtf__destroyResponse(struct soap *soap, const char *tag, int id, struct rgtf__destroyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rgtf__destroyResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rgtf__destroyResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rgtf__destroyResponse ** SOAP_FMAC4 soap_get_PointerTorgtf__destroyResponse(struct soap *soap, struct rgtf__destroyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgtf__destroyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgtf__destroyResponse ** SOAP_FMAC4 soap_in_PointerTorgtf__destroyResponse(struct soap *soap, const char *tag, struct rgtf__destroyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct rgtf__destroyResponse **)soap_malloc(soap, sizeof(struct rgtf__destroyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rgtf__destroyResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rgtf__destroyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rgtf__destroyResponse, sizeof(struct rgtf__destroyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorgtf__findByHandleResponse(struct soap *soap, struct rgtf__findByHandleResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgtf__findByHandleResponse))
		soap_serialize_rgtf__findByHandleResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorgtf__findByHandleResponse(struct soap *soap, struct rgtf__findByHandleResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorgtf__findByHandleResponse);
	if (soap_out_PointerTorgtf__findByHandleResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorgtf__findByHandleResponse(struct soap *soap, const char *tag, int id, struct rgtf__findByHandleResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rgtf__findByHandleResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rgtf__findByHandleResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rgtf__findByHandleResponse ** SOAP_FMAC4 soap_get_PointerTorgtf__findByHandleResponse(struct soap *soap, struct rgtf__findByHandleResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgtf__findByHandleResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgtf__findByHandleResponse ** SOAP_FMAC4 soap_in_PointerTorgtf__findByHandleResponse(struct soap *soap, const char *tag, struct rgtf__findByHandleResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct rgtf__findByHandleResponse **)soap_malloc(soap, sizeof(struct rgtf__findByHandleResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rgtf__findByHandleResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rgtf__findByHandleResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rgtf__findByHandleResponse, sizeof(struct rgtf__findByHandleResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorgtf__createNewTreeResponse(struct soap *soap, struct rgtf__createNewTreeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgtf__createNewTreeResponse))
		soap_serialize_rgtf__createNewTreeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorgtf__createNewTreeResponse(struct soap *soap, struct rgtf__createNewTreeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorgtf__createNewTreeResponse);
	if (soap_out_PointerTorgtf__createNewTreeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorgtf__createNewTreeResponse(struct soap *soap, const char *tag, int id, struct rgtf__createNewTreeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rgtf__createNewTreeResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rgtf__createNewTreeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rgtf__createNewTreeResponse ** SOAP_FMAC4 soap_get_PointerTorgtf__createNewTreeResponse(struct soap *soap, struct rgtf__createNewTreeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgtf__createNewTreeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct rgtf__createNewTreeResponse ** SOAP_FMAC4 soap_in_PointerTorgtf__createNewTreeResponse(struct soap *soap, const char *tag, struct rgtf__createNewTreeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct rgtf__createNewTreeResponse **)soap_malloc(soap, sizeof(struct rgtf__createNewTreeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rgtf__createNewTreeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rgtf__createNewTreeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rgtf__createNewTreeResponse, sizeof(struct rgtf__createNewTreeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgr__findServiceDataResponse(struct soap *soap, struct sgr__findServiceDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgr__findServiceDataResponse))
		soap_serialize_sgr__findServiceDataResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgr__findServiceDataResponse(struct soap *soap, struct sgr__findServiceDataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgr__findServiceDataResponse);
	if (soap_out_PointerTosgr__findServiceDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgr__findServiceDataResponse(struct soap *soap, const char *tag, int id, struct sgr__findServiceDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgr__findServiceDataResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgr__findServiceDataResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgr__findServiceDataResponse ** SOAP_FMAC4 soap_get_PointerTosgr__findServiceDataResponse(struct soap *soap, struct sgr__findServiceDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgr__findServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgr__findServiceDataResponse ** SOAP_FMAC4 soap_in_PointerTosgr__findServiceDataResponse(struct soap *soap, const char *tag, struct sgr__findServiceDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgr__findServiceDataResponse **)soap_malloc(soap, sizeof(struct sgr__findServiceDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgr__findServiceDataResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgr__findServiceDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgr__findServiceDataResponse, sizeof(struct sgr__findServiceDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgr__addResponse(struct soap *soap, struct sgr__addResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgr__addResponse))
		soap_serialize_sgr__addResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgr__addResponse(struct soap *soap, struct sgr__addResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgr__addResponse);
	if (soap_out_PointerTosgr__addResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgr__addResponse(struct soap *soap, const char *tag, int id, struct sgr__addResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgr__addResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgr__addResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgr__addResponse ** SOAP_FMAC4 soap_get_PointerTosgr__addResponse(struct soap *soap, struct sgr__addResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgr__addResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgr__addResponse ** SOAP_FMAC4 soap_in_PointerTosgr__addResponse(struct soap *soap, const char *tag, struct sgr__addResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgr__addResponse **)soap_malloc(soap, sizeof(struct sgr__addResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgr__addResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgr__addResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgr__addResponse, sizeof(struct sgr__addResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgr__removeResponse(struct soap *soap, struct sgr__removeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgr__removeResponse))
		soap_serialize_sgr__removeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgr__removeResponse(struct soap *soap, struct sgr__removeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgr__removeResponse);
	if (soap_out_PointerTosgr__removeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgr__removeResponse(struct soap *soap, const char *tag, int id, struct sgr__removeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgr__removeResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgr__removeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgr__removeResponse ** SOAP_FMAC4 soap_get_PointerTosgr__removeResponse(struct soap *soap, struct sgr__removeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgr__removeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgr__removeResponse ** SOAP_FMAC4 soap_in_PointerTosgr__removeResponse(struct soap *soap, const char *tag, struct sgr__removeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgr__removeResponse **)soap_malloc(soap, sizeof(struct sgr__removeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgr__removeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgr__removeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgr__removeResponse, sizeof(struct sgr__removeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__string(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__string))
		soap_serialize_xsd__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__string(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__string);
	if (soap_out_PointerToxsd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__string(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__string);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerToxsd__string(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerToxsd__string(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOf_USCORE_xsd_USCORE_string(struct soap *soap, struct ArrayOf_USCORE_xsd_USCORE_string *const*a)
{
	if (*a)
		soap_serialize_ArrayOf_USCORE_xsd_USCORE_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOf_USCORE_xsd_USCORE_string(struct soap *soap, struct ArrayOf_USCORE_xsd_USCORE_string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOf_USCORE_xsd_USCORE_string);
	if (soap_out_PointerToArrayOf_USCORE_xsd_USCORE_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOf_USCORE_xsd_USCORE_string(struct soap *soap, const char *tag, int id, struct ArrayOf_USCORE_xsd_USCORE_string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCORE_xsd_USCORE_string);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOf_USCORE_xsd_USCORE_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOf_USCORE_xsd_USCORE_string ** SOAP_FMAC4 soap_get_PointerToArrayOf_USCORE_xsd_USCORE_string(struct soap *soap, struct ArrayOf_USCORE_xsd_USCORE_string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOf_USCORE_xsd_USCORE_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ArrayOf_USCORE_xsd_USCORE_string ** SOAP_FMAC4 soap_in_PointerToArrayOf_USCORE_xsd_USCORE_string(struct soap *soap, const char *tag, struct ArrayOf_USCORE_xsd_USCORE_string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOf_USCORE_xsd_USCORE_string **)soap_malloc(soap, sizeof(struct ArrayOf_USCORE_xsd_USCORE_string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOf_USCORE_xsd_USCORE_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOf_USCORE_xsd_USCORE_string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCORE_xsd_USCORE_string, sizeof(struct ArrayOf_USCORE_xsd_USCORE_string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswsf__createSWSResourceResponse(struct soap *soap, struct swsf__createSWSResourceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_swsf__createSWSResourceResponse))
		soap_serialize_swsf__createSWSResourceResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswsf__createSWSResourceResponse(struct soap *soap, struct swsf__createSWSResourceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswsf__createSWSResourceResponse);
	if (soap_out_PointerToswsf__createSWSResourceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswsf__createSWSResourceResponse(struct soap *soap, const char *tag, int id, struct swsf__createSWSResourceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swsf__createSWSResourceResponse);
	if (id < 0)
		return soap->error;
	return soap_out_swsf__createSWSResourceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swsf__createSWSResourceResponse ** SOAP_FMAC4 soap_get_PointerToswsf__createSWSResourceResponse(struct soap *soap, struct swsf__createSWSResourceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswsf__createSWSResourceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct swsf__createSWSResourceResponse ** SOAP_FMAC4 soap_in_PointerToswsf__createSWSResourceResponse(struct soap *soap, const char *tag, struct swsf__createSWSResourceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct swsf__createSWSResourceResponse **)soap_malloc(soap, sizeof(struct swsf__createSWSResourceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swsf__createSWSResourceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swsf__createSWSResourceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swsf__createSWSResourceResponse, sizeof(struct swsf__createSWSResourceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgsf__createServiceResponse(struct soap *soap, struct sgsf__createServiceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgsf__createServiceResponse))
		soap_serialize_sgsf__createServiceResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgsf__createServiceResponse(struct soap *soap, struct sgsf__createServiceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgsf__createServiceResponse);
	if (soap_out_PointerTosgsf__createServiceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgsf__createServiceResponse(struct soap *soap, const char *tag, int id, struct sgsf__createServiceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgsf__createServiceResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgsf__createServiceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgsf__createServiceResponse ** SOAP_FMAC4 soap_get_PointerTosgsf__createServiceResponse(struct soap *soap, struct sgsf__createServiceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgsf__createServiceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgsf__createServiceResponse ** SOAP_FMAC4 soap_in_PointerTosgsf__createServiceResponse(struct soap *soap, const char *tag, struct sgsf__createServiceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgsf__createServiceResponse **)soap_malloc(soap, sizeof(struct sgsf__createServiceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgsf__createServiceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgsf__createServiceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgsf__createServiceResponse, sizeof(struct sgsf__createServiceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgsf__destroyResponse(struct soap *soap, struct sgsf__destroyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgsf__destroyResponse))
		soap_serialize_sgsf__destroyResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgsf__destroyResponse(struct soap *soap, struct sgsf__destroyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgsf__destroyResponse);
	if (soap_out_PointerTosgsf__destroyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgsf__destroyResponse(struct soap *soap, const char *tag, int id, struct sgsf__destroyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgsf__destroyResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgsf__destroyResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgsf__destroyResponse ** SOAP_FMAC4 soap_get_PointerTosgsf__destroyResponse(struct soap *soap, struct sgsf__destroyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgsf__destroyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgsf__destroyResponse ** SOAP_FMAC4 soap_in_PointerTosgsf__destroyResponse(struct soap *soap, const char *tag, struct sgsf__destroyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgsf__destroyResponse **)soap_malloc(soap, sizeof(struct sgsf__destroyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgsf__destroyResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgsf__destroyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgsf__destroyResponse, sizeof(struct sgsf__destroyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgsf__registerSelfResponse(struct soap *soap, struct sgsf__registerSelfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgsf__registerSelfResponse))
		soap_serialize_sgsf__registerSelfResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgsf__registerSelfResponse(struct soap *soap, struct sgsf__registerSelfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgsf__registerSelfResponse);
	if (soap_out_PointerTosgsf__registerSelfResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgsf__registerSelfResponse(struct soap *soap, const char *tag, int id, struct sgsf__registerSelfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgsf__registerSelfResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgsf__registerSelfResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgsf__registerSelfResponse ** SOAP_FMAC4 soap_get_PointerTosgsf__registerSelfResponse(struct soap *soap, struct sgsf__registerSelfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgsf__registerSelfResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgsf__registerSelfResponse ** SOAP_FMAC4 soap_in_PointerTosgsf__registerSelfResponse(struct soap *soap, const char *tag, struct sgsf__registerSelfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgsf__registerSelfResponse **)soap_malloc(soap, sizeof(struct sgsf__registerSelfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgsf__registerSelfResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgsf__registerSelfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgsf__registerSelfResponse, sizeof(struct sgsf__registerSelfResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgs__AppStopResponse(struct soap *soap, struct sgs__AppStopResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__AppStopResponse))
		soap_serialize_sgs__AppStopResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgs__AppStopResponse(struct soap *soap, struct sgs__AppStopResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgs__AppStopResponse);
	if (soap_out_PointerTosgs__AppStopResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgs__AppStopResponse(struct soap *soap, const char *tag, int id, struct sgs__AppStopResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgs__AppStopResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgs__AppStopResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgs__AppStopResponse ** SOAP_FMAC4 soap_get_PointerTosgs__AppStopResponse(struct soap *soap, struct sgs__AppStopResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__AppStopResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__AppStopResponse ** SOAP_FMAC4 soap_in_PointerTosgs__AppStopResponse(struct soap *soap, const char *tag, struct sgs__AppStopResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgs__AppStopResponse **)soap_malloc(soap, sizeof(struct sgs__AppStopResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgs__AppStopResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgs__AppStopResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgs__AppStopResponse, sizeof(struct sgs__AppStopResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgs__GetNotificationsResponse(struct soap *soap, struct sgs__GetNotificationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__GetNotificationsResponse))
		soap_serialize_sgs__GetNotificationsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgs__GetNotificationsResponse(struct soap *soap, struct sgs__GetNotificationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgs__GetNotificationsResponse);
	if (soap_out_PointerTosgs__GetNotificationsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgs__GetNotificationsResponse(struct soap *soap, const char *tag, int id, struct sgs__GetNotificationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgs__GetNotificationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgs__GetNotificationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgs__GetNotificationsResponse ** SOAP_FMAC4 soap_get_PointerTosgs__GetNotificationsResponse(struct soap *soap, struct sgs__GetNotificationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__GetNotificationsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__GetNotificationsResponse ** SOAP_FMAC4 soap_in_PointerTosgs__GetNotificationsResponse(struct soap *soap, const char *tag, struct sgs__GetNotificationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgs__GetNotificationsResponse **)soap_malloc(soap, sizeof(struct sgs__GetNotificationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgs__GetNotificationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgs__GetNotificationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgs__GetNotificationsResponse, sizeof(struct sgs__GetNotificationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgs__GetControlResponse(struct soap *soap, struct sgs__GetControlResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__GetControlResponse))
		soap_serialize_sgs__GetControlResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgs__GetControlResponse(struct soap *soap, struct sgs__GetControlResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgs__GetControlResponse);
	if (soap_out_PointerTosgs__GetControlResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgs__GetControlResponse(struct soap *soap, const char *tag, int id, struct sgs__GetControlResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgs__GetControlResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgs__GetControlResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgs__GetControlResponse ** SOAP_FMAC4 soap_get_PointerTosgs__GetControlResponse(struct soap *soap, struct sgs__GetControlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__GetControlResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__GetControlResponse ** SOAP_FMAC4 soap_in_PointerTosgs__GetControlResponse(struct soap *soap, const char *tag, struct sgs__GetControlResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgs__GetControlResponse **)soap_malloc(soap, sizeof(struct sgs__GetControlResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgs__GetControlResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgs__GetControlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgs__GetControlResponse, sizeof(struct sgs__GetControlResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgs__destroyResponse(struct soap *soap, struct sgs__destroyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__destroyResponse))
		soap_serialize_sgs__destroyResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgs__destroyResponse(struct soap *soap, struct sgs__destroyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgs__destroyResponse);
	if (soap_out_PointerTosgs__destroyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgs__destroyResponse(struct soap *soap, const char *tag, int id, struct sgs__destroyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgs__destroyResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgs__destroyResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgs__destroyResponse ** SOAP_FMAC4 soap_get_PointerTosgs__destroyResponse(struct soap *soap, struct sgs__destroyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__destroyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__destroyResponse ** SOAP_FMAC4 soap_in_PointerTosgs__destroyResponse(struct soap *soap, const char *tag, struct sgs__destroyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgs__destroyResponse **)soap_malloc(soap, sizeof(struct sgs__destroyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgs__destroyResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgs__destroyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgs__destroyResponse, sizeof(struct sgs__destroyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgs__findServiceDataResponse(struct soap *soap, struct sgs__findServiceDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__findServiceDataResponse))
		soap_serialize_sgs__findServiceDataResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgs__findServiceDataResponse(struct soap *soap, struct sgs__findServiceDataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgs__findServiceDataResponse);
	if (soap_out_PointerTosgs__findServiceDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgs__findServiceDataResponse(struct soap *soap, const char *tag, int id, struct sgs__findServiceDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgs__findServiceDataResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgs__findServiceDataResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgs__findServiceDataResponse ** SOAP_FMAC4 soap_get_PointerTosgs__findServiceDataResponse(struct soap *soap, struct sgs__findServiceDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__findServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__findServiceDataResponse ** SOAP_FMAC4 soap_in_PointerTosgs__findServiceDataResponse(struct soap *soap, const char *tag, struct sgs__findServiceDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgs__findServiceDataResponse **)soap_malloc(soap, sizeof(struct sgs__findServiceDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgs__findServiceDataResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgs__findServiceDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgs__findServiceDataResponse, sizeof(struct sgs__findServiceDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgs__GetNthDataSourceResponse(struct soap *soap, struct sgs__GetNthDataSourceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__GetNthDataSourceResponse))
		soap_serialize_sgs__GetNthDataSourceResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgs__GetNthDataSourceResponse(struct soap *soap, struct sgs__GetNthDataSourceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgs__GetNthDataSourceResponse);
	if (soap_out_PointerTosgs__GetNthDataSourceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgs__GetNthDataSourceResponse(struct soap *soap, const char *tag, int id, struct sgs__GetNthDataSourceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgs__GetNthDataSourceResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgs__GetNthDataSourceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgs__GetNthDataSourceResponse ** SOAP_FMAC4 soap_get_PointerTosgs__GetNthDataSourceResponse(struct soap *soap, struct sgs__GetNthDataSourceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__GetNthDataSourceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__GetNthDataSourceResponse ** SOAP_FMAC4 soap_in_PointerTosgs__GetNthDataSourceResponse(struct soap *soap, const char *tag, struct sgs__GetNthDataSourceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgs__GetNthDataSourceResponse **)soap_malloc(soap, sizeof(struct sgs__GetNthDataSourceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgs__GetNthDataSourceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgs__GetNthDataSourceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgs__GetNthDataSourceResponse, sizeof(struct sgs__GetNthDataSourceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgs__RestartResponse(struct soap *soap, struct sgs__RestartResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__RestartResponse))
		soap_serialize_sgs__RestartResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgs__RestartResponse(struct soap *soap, struct sgs__RestartResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgs__RestartResponse);
	if (soap_out_PointerTosgs__RestartResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgs__RestartResponse(struct soap *soap, const char *tag, int id, struct sgs__RestartResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgs__RestartResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgs__RestartResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgs__RestartResponse ** SOAP_FMAC4 soap_get_PointerTosgs__RestartResponse(struct soap *soap, struct sgs__RestartResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__RestartResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__RestartResponse ** SOAP_FMAC4 soap_in_PointerTosgs__RestartResponse(struct soap *soap, const char *tag, struct sgs__RestartResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgs__RestartResponse **)soap_malloc(soap, sizeof(struct sgs__RestartResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgs__RestartResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgs__RestartResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgs__RestartResponse, sizeof(struct sgs__RestartResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgs__PutControlResponse(struct soap *soap, struct sgs__PutControlResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__PutControlResponse))
		soap_serialize_sgs__PutControlResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgs__PutControlResponse(struct soap *soap, struct sgs__PutControlResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgs__PutControlResponse);
	if (soap_out_PointerTosgs__PutControlResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgs__PutControlResponse(struct soap *soap, const char *tag, int id, struct sgs__PutControlResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgs__PutControlResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgs__PutControlResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgs__PutControlResponse ** SOAP_FMAC4 soap_get_PointerTosgs__PutControlResponse(struct soap *soap, struct sgs__PutControlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__PutControlResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__PutControlResponse ** SOAP_FMAC4 soap_in_PointerTosgs__PutControlResponse(struct soap *soap, const char *tag, struct sgs__PutControlResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgs__PutControlResponse **)soap_malloc(soap, sizeof(struct sgs__PutControlResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgs__PutControlResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgs__PutControlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgs__PutControlResponse, sizeof(struct sgs__PutControlResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgs__PauseResponse(struct soap *soap, struct sgs__PauseResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__PauseResponse))
		soap_serialize_sgs__PauseResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgs__PauseResponse(struct soap *soap, struct sgs__PauseResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgs__PauseResponse);
	if (soap_out_PointerTosgs__PauseResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgs__PauseResponse(struct soap *soap, const char *tag, int id, struct sgs__PauseResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgs__PauseResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgs__PauseResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgs__PauseResponse ** SOAP_FMAC4 soap_get_PointerTosgs__PauseResponse(struct soap *soap, struct sgs__PauseResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__PauseResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__PauseResponse ** SOAP_FMAC4 soap_in_PointerTosgs__PauseResponse(struct soap *soap, const char *tag, struct sgs__PauseResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgs__PauseResponse **)soap_malloc(soap, sizeof(struct sgs__PauseResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgs__PauseResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgs__PauseResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgs__PauseResponse, sizeof(struct sgs__PauseResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgs__AppDetachResponse(struct soap *soap, struct sgs__AppDetachResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__AppDetachResponse))
		soap_serialize_sgs__AppDetachResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgs__AppDetachResponse(struct soap *soap, struct sgs__AppDetachResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgs__AppDetachResponse);
	if (soap_out_PointerTosgs__AppDetachResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgs__AppDetachResponse(struct soap *soap, const char *tag, int id, struct sgs__AppDetachResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgs__AppDetachResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgs__AppDetachResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgs__AppDetachResponse ** SOAP_FMAC4 soap_get_PointerTosgs__AppDetachResponse(struct soap *soap, struct sgs__AppDetachResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__AppDetachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__AppDetachResponse ** SOAP_FMAC4 soap_in_PointerTosgs__AppDetachResponse(struct soap *soap, const char *tag, struct sgs__AppDetachResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgs__AppDetachResponse **)soap_malloc(soap, sizeof(struct sgs__AppDetachResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgs__AppDetachResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgs__AppDetachResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgs__AppDetachResponse, sizeof(struct sgs__AppDetachResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgs__AppPutLogResponse(struct soap *soap, struct sgs__AppPutLogResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__AppPutLogResponse))
		soap_serialize_sgs__AppPutLogResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgs__AppPutLogResponse(struct soap *soap, struct sgs__AppPutLogResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgs__AppPutLogResponse);
	if (soap_out_PointerTosgs__AppPutLogResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgs__AppPutLogResponse(struct soap *soap, const char *tag, int id, struct sgs__AppPutLogResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgs__AppPutLogResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgs__AppPutLogResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgs__AppPutLogResponse ** SOAP_FMAC4 soap_get_PointerTosgs__AppPutLogResponse(struct soap *soap, struct sgs__AppPutLogResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__AppPutLogResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__AppPutLogResponse ** SOAP_FMAC4 soap_in_PointerTosgs__AppPutLogResponse(struct soap *soap, const char *tag, struct sgs__AppPutLogResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgs__AppPutLogResponse **)soap_malloc(soap, sizeof(struct sgs__AppPutLogResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgs__AppPutLogResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgs__AppPutLogResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgs__AppPutLogResponse, sizeof(struct sgs__AppPutLogResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgs__setServiceDataResponse(struct soap *soap, struct sgs__setServiceDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__setServiceDataResponse))
		soap_serialize_sgs__setServiceDataResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgs__setServiceDataResponse(struct soap *soap, struct sgs__setServiceDataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgs__setServiceDataResponse);
	if (soap_out_PointerTosgs__setServiceDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgs__setServiceDataResponse(struct soap *soap, const char *tag, int id, struct sgs__setServiceDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgs__setServiceDataResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgs__setServiceDataResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgs__setServiceDataResponse ** SOAP_FMAC4 soap_get_PointerTosgs__setServiceDataResponse(struct soap *soap, struct sgs__setServiceDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__setServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__setServiceDataResponse ** SOAP_FMAC4 soap_in_PointerTosgs__setServiceDataResponse(struct soap *soap, const char *tag, struct sgs__setServiceDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgs__setServiceDataResponse **)soap_malloc(soap, sizeof(struct sgs__setServiceDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgs__setServiceDataResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgs__setServiceDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgs__setServiceDataResponse, sizeof(struct sgs__setServiceDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgs__GetParamLogResponse(struct soap *soap, struct sgs__GetParamLogResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__GetParamLogResponse))
		soap_serialize_sgs__GetParamLogResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgs__GetParamLogResponse(struct soap *soap, struct sgs__GetParamLogResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgs__GetParamLogResponse);
	if (soap_out_PointerTosgs__GetParamLogResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgs__GetParamLogResponse(struct soap *soap, const char *tag, int id, struct sgs__GetParamLogResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgs__GetParamLogResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgs__GetParamLogResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgs__GetParamLogResponse ** SOAP_FMAC4 soap_get_PointerTosgs__GetParamLogResponse(struct soap *soap, struct sgs__GetParamLogResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__GetParamLogResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__GetParamLogResponse ** SOAP_FMAC4 soap_in_PointerTosgs__GetParamLogResponse(struct soap *soap, const char *tag, struct sgs__GetParamLogResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgs__GetParamLogResponse **)soap_malloc(soap, sizeof(struct sgs__GetParamLogResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgs__GetParamLogResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgs__GetParamLogResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgs__GetParamLogResponse, sizeof(struct sgs__GetParamLogResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgs__AppStartResponse(struct soap *soap, struct sgs__AppStartResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__AppStartResponse))
		soap_serialize_sgs__AppStartResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgs__AppStartResponse(struct soap *soap, struct sgs__AppStartResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgs__AppStartResponse);
	if (soap_out_PointerTosgs__AppStartResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgs__AppStartResponse(struct soap *soap, const char *tag, int id, struct sgs__AppStartResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgs__AppStartResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgs__AppStartResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgs__AppStartResponse ** SOAP_FMAC4 soap_get_PointerTosgs__AppStartResponse(struct soap *soap, struct sgs__AppStartResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__AppStartResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__AppStartResponse ** SOAP_FMAC4 soap_in_PointerTosgs__AppStartResponse(struct soap *soap, const char *tag, struct sgs__AppStartResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgs__AppStartResponse **)soap_malloc(soap, sizeof(struct sgs__AppStartResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgs__AppStartResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgs__AppStartResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgs__AppStartResponse, sizeof(struct sgs__AppStartResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgs__PutStatusResponse(struct soap *soap, struct sgs__PutStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__PutStatusResponse))
		soap_serialize_sgs__PutStatusResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgs__PutStatusResponse(struct soap *soap, struct sgs__PutStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgs__PutStatusResponse);
	if (soap_out_PointerTosgs__PutStatusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgs__PutStatusResponse(struct soap *soap, const char *tag, int id, struct sgs__PutStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgs__PutStatusResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgs__PutStatusResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgs__PutStatusResponse ** SOAP_FMAC4 soap_get_PointerTosgs__PutStatusResponse(struct soap *soap, struct sgs__PutStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__PutStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__PutStatusResponse ** SOAP_FMAC4 soap_in_PointerTosgs__PutStatusResponse(struct soap *soap, const char *tag, struct sgs__PutStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgs__PutStatusResponse **)soap_malloc(soap, sizeof(struct sgs__PutStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgs__PutStatusResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgs__PutStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgs__PutStatusResponse, sizeof(struct sgs__PutStatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgs__AppRecordChkpointResponse(struct soap *soap, struct sgs__AppRecordChkpointResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__AppRecordChkpointResponse))
		soap_serialize_sgs__AppRecordChkpointResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgs__AppRecordChkpointResponse(struct soap *soap, struct sgs__AppRecordChkpointResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgs__AppRecordChkpointResponse);
	if (soap_out_PointerTosgs__AppRecordChkpointResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgs__AppRecordChkpointResponse(struct soap *soap, const char *tag, int id, struct sgs__AppRecordChkpointResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgs__AppRecordChkpointResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgs__AppRecordChkpointResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgs__AppRecordChkpointResponse ** SOAP_FMAC4 soap_get_PointerTosgs__AppRecordChkpointResponse(struct soap *soap, struct sgs__AppRecordChkpointResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__AppRecordChkpointResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__AppRecordChkpointResponse ** SOAP_FMAC4 soap_in_PointerTosgs__AppRecordChkpointResponse(struct soap *soap, const char *tag, struct sgs__AppRecordChkpointResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgs__AppRecordChkpointResponse **)soap_malloc(soap, sizeof(struct sgs__AppRecordChkpointResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgs__AppRecordChkpointResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgs__AppRecordChkpointResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgs__AppRecordChkpointResponse, sizeof(struct sgs__AppRecordChkpointResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgs__ResumeResponse(struct soap *soap, struct sgs__ResumeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__ResumeResponse))
		soap_serialize_sgs__ResumeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgs__ResumeResponse(struct soap *soap, struct sgs__ResumeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgs__ResumeResponse);
	if (soap_out_PointerTosgs__ResumeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgs__ResumeResponse(struct soap *soap, const char *tag, int id, struct sgs__ResumeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgs__ResumeResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgs__ResumeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgs__ResumeResponse ** SOAP_FMAC4 soap_get_PointerTosgs__ResumeResponse(struct soap *soap, struct sgs__ResumeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__ResumeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__ResumeResponse ** SOAP_FMAC4 soap_in_PointerTosgs__ResumeResponse(struct soap *soap, const char *tag, struct sgs__ResumeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgs__ResumeResponse **)soap_malloc(soap, sizeof(struct sgs__ResumeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgs__ResumeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgs__ResumeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgs__ResumeResponse, sizeof(struct sgs__ResumeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgs__DetachResponse(struct soap *soap, struct sgs__DetachResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__DetachResponse))
		soap_serialize_sgs__DetachResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgs__DetachResponse(struct soap *soap, struct sgs__DetachResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgs__DetachResponse);
	if (soap_out_PointerTosgs__DetachResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgs__DetachResponse(struct soap *soap, const char *tag, int id, struct sgs__DetachResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgs__DetachResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgs__DetachResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgs__DetachResponse ** SOAP_FMAC4 soap_get_PointerTosgs__DetachResponse(struct soap *soap, struct sgs__DetachResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__DetachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__DetachResponse ** SOAP_FMAC4 soap_in_PointerTosgs__DetachResponse(struct soap *soap, const char *tag, struct sgs__DetachResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgs__DetachResponse **)soap_malloc(soap, sizeof(struct sgs__DetachResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgs__DetachResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgs__DetachResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgs__DetachResponse, sizeof(struct sgs__DetachResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgs__ClearStatusMsgQueueResponse(struct soap *soap, struct sgs__ClearStatusMsgQueueResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__ClearStatusMsgQueueResponse))
		soap_serialize_sgs__ClearStatusMsgQueueResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgs__ClearStatusMsgQueueResponse(struct soap *soap, struct sgs__ClearStatusMsgQueueResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgs__ClearStatusMsgQueueResponse);
	if (soap_out_PointerTosgs__ClearStatusMsgQueueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgs__ClearStatusMsgQueueResponse(struct soap *soap, const char *tag, int id, struct sgs__ClearStatusMsgQueueResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgs__ClearStatusMsgQueueResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgs__ClearStatusMsgQueueResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgs__ClearStatusMsgQueueResponse ** SOAP_FMAC4 soap_get_PointerTosgs__ClearStatusMsgQueueResponse(struct soap *soap, struct sgs__ClearStatusMsgQueueResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__ClearStatusMsgQueueResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__ClearStatusMsgQueueResponse ** SOAP_FMAC4 soap_in_PointerTosgs__ClearStatusMsgQueueResponse(struct soap *soap, const char *tag, struct sgs__ClearStatusMsgQueueResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgs__ClearStatusMsgQueueResponse **)soap_malloc(soap, sizeof(struct sgs__ClearStatusMsgQueueResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgs__ClearStatusMsgQueueResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgs__ClearStatusMsgQueueResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgs__ClearStatusMsgQueueResponse, sizeof(struct sgs__ClearStatusMsgQueueResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgs__StopResponse(struct soap *soap, struct sgs__StopResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__StopResponse))
		soap_serialize_sgs__StopResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgs__StopResponse(struct soap *soap, struct sgs__StopResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgs__StopResponse);
	if (soap_out_PointerTosgs__StopResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgs__StopResponse(struct soap *soap, const char *tag, int id, struct sgs__StopResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgs__StopResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgs__StopResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgs__StopResponse ** SOAP_FMAC4 soap_get_PointerTosgs__StopResponse(struct soap *soap, struct sgs__StopResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__StopResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__StopResponse ** SOAP_FMAC4 soap_in_PointerTosgs__StopResponse(struct soap *soap, const char *tag, struct sgs__StopResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgs__StopResponse **)soap_malloc(soap, sizeof(struct sgs__StopResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgs__StopResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgs__StopResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgs__StopResponse, sizeof(struct sgs__StopResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgs__GetStatusResponse(struct soap *soap, struct sgs__GetStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__GetStatusResponse))
		soap_serialize_sgs__GetStatusResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgs__GetStatusResponse(struct soap *soap, struct sgs__GetStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgs__GetStatusResponse);
	if (soap_out_PointerTosgs__GetStatusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgs__GetStatusResponse(struct soap *soap, const char *tag, int id, struct sgs__GetStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgs__GetStatusResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgs__GetStatusResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgs__GetStatusResponse ** SOAP_FMAC4 soap_get_PointerTosgs__GetStatusResponse(struct soap *soap, struct sgs__GetStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__GetStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__GetStatusResponse ** SOAP_FMAC4 soap_in_PointerTosgs__GetStatusResponse(struct soap *soap, const char *tag, struct sgs__GetStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgs__GetStatusResponse **)soap_malloc(soap, sizeof(struct sgs__GetStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgs__GetStatusResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgs__GetStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgs__GetStatusResponse, sizeof(struct sgs__GetStatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosgs__AttachResponse(struct soap *soap, struct sgs__AttachResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__AttachResponse))
		soap_serialize_sgs__AttachResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosgs__AttachResponse(struct soap *soap, struct sgs__AttachResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosgs__AttachResponse);
	if (soap_out_PointerTosgs__AttachResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosgs__AttachResponse(struct soap *soap, const char *tag, int id, struct sgs__AttachResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sgs__AttachResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sgs__AttachResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sgs__AttachResponse ** SOAP_FMAC4 soap_get_PointerTosgs__AttachResponse(struct soap *soap, struct sgs__AttachResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__AttachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sgs__AttachResponse ** SOAP_FMAC4 soap_in_PointerTosgs__AttachResponse(struct soap *soap, const char *tag, struct sgs__AttachResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sgs__AttachResponse **)soap_malloc(soap, sizeof(struct sgs__AttachResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sgs__AttachResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sgs__AttachResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sgs__AttachResponse, sizeof(struct sgs__AttachResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrp__DestroyResponse(struct soap *soap, struct wsrp__DestroyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrp__DestroyResponse))
		soap_serialize_wsrp__DestroyResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrp__DestroyResponse(struct soap *soap, struct wsrp__DestroyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsrp__DestroyResponse);
	if (soap_out_PointerTowsrp__DestroyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrp__DestroyResponse(struct soap *soap, const char *tag, int id, struct wsrp__DestroyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrp__DestroyResponse);
	if (id < 0)
		return soap->error;
	return soap_out_wsrp__DestroyResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrp__DestroyResponse ** SOAP_FMAC4 soap_get_PointerTowsrp__DestroyResponse(struct soap *soap, struct wsrp__DestroyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrp__DestroyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wsrp__DestroyResponse ** SOAP_FMAC4 soap_in_PointerTowsrp__DestroyResponse(struct soap *soap, const char *tag, struct wsrp__DestroyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct wsrp__DestroyResponse **)soap_malloc(soap, sizeof(struct wsrp__DestroyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrp__DestroyResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrp__DestroyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrp__DestroyResponse, sizeof(struct wsrp__DestroyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosws__PutParamLogResponse(struct soap *soap, struct sws__PutParamLogResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sws__PutParamLogResponse))
		soap_serialize_sws__PutParamLogResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosws__PutParamLogResponse(struct soap *soap, struct sws__PutParamLogResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosws__PutParamLogResponse);
	if (soap_out_PointerTosws__PutParamLogResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosws__PutParamLogResponse(struct soap *soap, const char *tag, int id, struct sws__PutParamLogResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sws__PutParamLogResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sws__PutParamLogResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sws__PutParamLogResponse ** SOAP_FMAC4 soap_get_PointerTosws__PutParamLogResponse(struct soap *soap, struct sws__PutParamLogResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosws__PutParamLogResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sws__PutParamLogResponse ** SOAP_FMAC4 soap_in_PointerTosws__PutParamLogResponse(struct soap *soap, const char *tag, struct sws__PutParamLogResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sws__PutParamLogResponse **)soap_malloc(soap, sizeof(struct sws__PutParamLogResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sws__PutParamLogResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sws__PutParamLogResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sws__PutParamLogResponse, sizeof(struct sws__PutParamLogResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosws__GetParamLogResponse(struct soap *soap, struct sws__GetParamLogResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sws__GetParamLogResponse))
		soap_serialize_sws__GetParamLogResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosws__GetParamLogResponse(struct soap *soap, struct sws__GetParamLogResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosws__GetParamLogResponse);
	if (soap_out_PointerTosws__GetParamLogResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosws__GetParamLogResponse(struct soap *soap, const char *tag, int id, struct sws__GetParamLogResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sws__GetParamLogResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sws__GetParamLogResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sws__GetParamLogResponse ** SOAP_FMAC4 soap_get_PointerTosws__GetParamLogResponse(struct soap *soap, struct sws__GetParamLogResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosws__GetParamLogResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sws__GetParamLogResponse ** SOAP_FMAC4 soap_in_PointerTosws__GetParamLogResponse(struct soap *soap, const char *tag, struct sws__GetParamLogResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sws__GetParamLogResponse **)soap_malloc(soap, sizeof(struct sws__GetParamLogResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sws__GetParamLogResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sws__GetParamLogResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sws__GetParamLogResponse, sizeof(struct sws__GetParamLogResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosws__RecordCheckpointResponse(struct soap *soap, struct sws__RecordCheckpointResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sws__RecordCheckpointResponse))
		soap_serialize_sws__RecordCheckpointResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosws__RecordCheckpointResponse(struct soap *soap, struct sws__RecordCheckpointResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosws__RecordCheckpointResponse);
	if (soap_out_PointerTosws__RecordCheckpointResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosws__RecordCheckpointResponse(struct soap *soap, const char *tag, int id, struct sws__RecordCheckpointResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sws__RecordCheckpointResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sws__RecordCheckpointResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sws__RecordCheckpointResponse ** SOAP_FMAC4 soap_get_PointerTosws__RecordCheckpointResponse(struct soap *soap, struct sws__RecordCheckpointResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosws__RecordCheckpointResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sws__RecordCheckpointResponse ** SOAP_FMAC4 soap_in_PointerTosws__RecordCheckpointResponse(struct soap *soap, const char *tag, struct sws__RecordCheckpointResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sws__RecordCheckpointResponse **)soap_malloc(soap, sizeof(struct sws__RecordCheckpointResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sws__RecordCheckpointResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sws__RecordCheckpointResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sws__RecordCheckpointResponse, sizeof(struct sws__RecordCheckpointResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosws__DetachResponse(struct soap *soap, struct sws__DetachResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sws__DetachResponse))
		soap_serialize_sws__DetachResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosws__DetachResponse(struct soap *soap, struct sws__DetachResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosws__DetachResponse);
	if (soap_out_PointerTosws__DetachResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosws__DetachResponse(struct soap *soap, const char *tag, int id, struct sws__DetachResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sws__DetachResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sws__DetachResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sws__DetachResponse ** SOAP_FMAC4 soap_get_PointerTosws__DetachResponse(struct soap *soap, struct sws__DetachResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosws__DetachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sws__DetachResponse ** SOAP_FMAC4 soap_in_PointerTosws__DetachResponse(struct soap *soap, const char *tag, struct sws__DetachResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sws__DetachResponse **)soap_malloc(soap, sizeof(struct sws__DetachResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sws__DetachResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sws__DetachResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sws__DetachResponse, sizeof(struct sws__DetachResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosws__AttachResponse(struct soap *soap, struct sws__AttachResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sws__AttachResponse))
		soap_serialize_sws__AttachResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosws__AttachResponse(struct soap *soap, struct sws__AttachResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosws__AttachResponse);
	if (soap_out_PointerTosws__AttachResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosws__AttachResponse(struct soap *soap, const char *tag, int id, struct sws__AttachResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sws__AttachResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sws__AttachResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sws__AttachResponse ** SOAP_FMAC4 soap_get_PointerTosws__AttachResponse(struct soap *soap, struct sws__AttachResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosws__AttachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sws__AttachResponse ** SOAP_FMAC4 soap_in_PointerTosws__AttachResponse(struct soap *soap, const char *tag, struct sws__AttachResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sws__AttachResponse **)soap_malloc(soap, sizeof(struct sws__AttachResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sws__AttachResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sws__AttachResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sws__AttachResponse, sizeof(struct sws__AttachResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosws__AddChildResponse(struct soap *soap, struct sws__AddChildResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sws__AddChildResponse))
		soap_serialize_sws__AddChildResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosws__AddChildResponse(struct soap *soap, struct sws__AddChildResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTosws__AddChildResponse);
	if (soap_out_PointerTosws__AddChildResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosws__AddChildResponse(struct soap *soap, const char *tag, int id, struct sws__AddChildResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sws__AddChildResponse);
	if (id < 0)
		return soap->error;
	return soap_out_sws__AddChildResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct sws__AddChildResponse ** SOAP_FMAC4 soap_get_PointerTosws__AddChildResponse(struct soap *soap, struct sws__AddChildResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosws__AddChildResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct sws__AddChildResponse ** SOAP_FMAC4 soap_in_PointerTosws__AddChildResponse(struct soap *soap, const char *tag, struct sws__AddChildResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct sws__AddChildResponse **)soap_malloc(soap, sizeof(struct sws__AddChildResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_sws__AddChildResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct sws__AddChildResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sws__AddChildResponse, sizeof(struct sws__AddChildResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrp__SetResourcePropertiesResponse(struct soap *soap, struct wsrp__SetResourcePropertiesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrp__SetResourcePropertiesResponse))
		soap_serialize_wsrp__SetResourcePropertiesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrp__SetResourcePropertiesResponse(struct soap *soap, struct wsrp__SetResourcePropertiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsrp__SetResourcePropertiesResponse);
	if (soap_out_PointerTowsrp__SetResourcePropertiesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrp__SetResourcePropertiesResponse(struct soap *soap, const char *tag, int id, struct wsrp__SetResourcePropertiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrp__SetResourcePropertiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_wsrp__SetResourcePropertiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrp__SetResourcePropertiesResponse ** SOAP_FMAC4 soap_get_PointerTowsrp__SetResourcePropertiesResponse(struct soap *soap, struct wsrp__SetResourcePropertiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrp__SetResourcePropertiesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wsrp__SetResourcePropertiesResponse ** SOAP_FMAC4 soap_in_PointerTowsrp__SetResourcePropertiesResponse(struct soap *soap, const char *tag, struct wsrp__SetResourcePropertiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct wsrp__SetResourcePropertiesResponse **)soap_malloc(soap, sizeof(struct wsrp__SetResourcePropertiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrp__SetResourcePropertiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrp__SetResourcePropertiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrp__SetResourcePropertiesResponse, sizeof(struct wsrp__SetResourcePropertiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToGetResourcePropertyRequest(struct soap *soap, struct GetResourcePropertyRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_GetResourcePropertyRequest))
		soap_serialize_GetResourcePropertyRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToGetResourcePropertyRequest(struct soap *soap, struct GetResourcePropertyRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToGetResourcePropertyRequest);
	if (soap_out_PointerToGetResourcePropertyRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToGetResourcePropertyRequest(struct soap *soap, const char *tag, int id, struct GetResourcePropertyRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_GetResourcePropertyRequest);
	if (id < 0)
		return soap->error;
	return soap_out_GetResourcePropertyRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct GetResourcePropertyRequest ** SOAP_FMAC4 soap_get_PointerToGetResourcePropertyRequest(struct soap *soap, struct GetResourcePropertyRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToGetResourcePropertyRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct GetResourcePropertyRequest ** SOAP_FMAC4 soap_in_PointerToGetResourcePropertyRequest(struct soap *soap, const char *tag, struct GetResourcePropertyRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct GetResourcePropertyRequest **)soap_malloc(soap, sizeof(struct GetResourcePropertyRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_GetResourcePropertyRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct GetResourcePropertyRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_GetResourcePropertyRequest, sizeof(struct GetResourcePropertyRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrp__ResourcePropertyStruct(struct soap *soap, struct wsrp__ResourcePropertyStruct *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrp__ResourcePropertyStruct))
		soap_serialize_wsrp__ResourcePropertyStruct(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrp__ResourcePropertyStruct(struct soap *soap, struct wsrp__ResourcePropertyStruct *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsrp__ResourcePropertyStruct);
	if (soap_out_PointerTowsrp__ResourcePropertyStruct(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrp__ResourcePropertyStruct(struct soap *soap, const char *tag, int id, struct wsrp__ResourcePropertyStruct *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrp__ResourcePropertyStruct);
	if (id < 0)
		return soap->error;
	return soap_out_wsrp__ResourcePropertyStruct(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrp__ResourcePropertyStruct ** SOAP_FMAC4 soap_get_PointerTowsrp__ResourcePropertyStruct(struct soap *soap, struct wsrp__ResourcePropertyStruct **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrp__ResourcePropertyStruct(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct wsrp__ResourcePropertyStruct ** SOAP_FMAC4 soap_in_PointerTowsrp__ResourcePropertyStruct(struct soap *soap, const char *tag, struct wsrp__ResourcePropertyStruct **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct wsrp__ResourcePropertyStruct **)soap_malloc(soap, sizeof(struct wsrp__ResourcePropertyStruct *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrp__ResourcePropertyStruct(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrp__ResourcePropertyStruct **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrp__ResourcePropertyStruct, sizeof(struct wsrp__ResourcePropertyStruct), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToCommand(struct soap *soap, struct Command *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Command))
		soap_serialize_Command(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToCommand(struct soap *soap, struct Command *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToCommand);
	if (soap_out_PointerToCommand(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToCommand(struct soap *soap, const char *tag, int id, struct Command *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Command);
	if (id < 0)
		return soap->error;
	return soap_out_Command(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct Command ** SOAP_FMAC4 soap_get_PointerToCommand(struct soap *soap, struct Command **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToCommand(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct Command ** SOAP_FMAC4 soap_in_PointerToCommand(struct soap *soap, const char *tag, struct Command **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct Command **)soap_malloc(soap, sizeof(struct Command *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_Command(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct Command **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Command, sizeof(struct Command), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__string(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__string(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__string);
	if (soap_out_xsd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__string, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
}

SOAP_END_NAMESPACE(soap)

#ifdef __cplusplus
}
#endif

/* End of soapC.c */
