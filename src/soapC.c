/* soapC.c
   Generated by gSOAP 2.2.3b from new.h
   Copyright (C) 2001-2003 Genivia inc.
   All Rights Reserved.
*/
#include "soapH.h"
#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.2.3b 2004-05-25 16:24:17 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC1 void SOAP_FMAC2 soap_serializeheader(struct soap *soap)
{
	soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->is_in_header = 1;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->is_in_header = 0;
	}
	return SOAP_OK;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_getheader(struct soap *soap)
{
	soap->is_in_header = 1;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->is_in_header = 0;
	return soap->header == NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serializefault(struct soap *soap)
{
	soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_putfault(struct soap *soap)
{
	return soap_out_SOAP_ENV__Fault(soap, "SOAP-ENV:Fault", 0, soap->fault, NULL);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_in_SOAP_ENV__Fault(soap, "SOAP-ENV:Fault", NULL, NULL)) == NULL;
}

SOAP_FMAC1 const char ** SOAP_FMAC2 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC1 const char ** SOAP_FMAC2 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC1 const char ** SOAP_FMAC2 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Detail;
	return (const char**)&soap->fault->detail;
}

#endif

SOAP_FMAC1 int SOAP_FMAC2 soap_getindependent(struct soap *soap)
{
	for (;;)
	{	if (soap_peek_element(soap))
			break;
		switch (soap_lookup_type(soap, soap->id))
		{
		case SOAP_TYPE_byte:
			soap_in_byte(soap, NULL, NULL, "");
			break;
		case SOAP_TYPE_xsd__int:
			soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
			break;
		case SOAP_TYPE_int:
			soap_in_int(soap, NULL, NULL, "");
			break;
		case SOAP_TYPE_rgt__addNode:
			soap_in_rgt__addNode(soap, NULL, NULL, "rgt:addNode");
			break;
		case SOAP_TYPE_rgt__getParentNode:
			soap_in_rgt__getParentNode(soap, NULL, NULL, "rgt:getParentNode");
			break;
		case SOAP_TYPE_rgt__getCheckPointData:
			soap_in_rgt__getCheckPointData(soap, NULL, NULL, "rgt:getCheckPointData");
			break;
		case SOAP_TYPE_rgt__requestTerminationBefore:
			soap_in_rgt__requestTerminationBefore(soap, NULL, NULL, "rgt:requestTerminationBefore");
			break;
		case SOAP_TYPE_rgt__getSteeringCommands:
			soap_in_rgt__getSteeringCommands(soap, NULL, NULL, "rgt:getSteeringCommands");
			break;
		case SOAP_TYPE_rgt__destroy:
			soap_in_rgt__destroy(soap, NULL, NULL, "rgt:destroy");
			break;
		case SOAP_TYPE_rgt__setCheckPointData:
			soap_in_rgt__setCheckPointData(soap, NULL, NULL, "rgt:setCheckPointData");
			break;
		case SOAP_TYPE_rgt__findServiceData:
			soap_in_rgt__findServiceData(soap, NULL, NULL, "rgt:findServiceData");
			break;
		case SOAP_TYPE_rgt__getInputFile:
			soap_in_rgt__getInputFile(soap, NULL, NULL, "rgt:getInputFile");
			break;
		case SOAP_TYPE_rgt__getChildNodes:
			soap_in_rgt__getChildNodes(soap, NULL, NULL, "rgt:getChildNodes");
			break;
		case SOAP_TYPE_rgt__requestTerminationAfter:
			soap_in_rgt__requestTerminationAfter(soap, NULL, NULL, "rgt:requestTerminationAfter");
			break;
		case SOAP_TYPE_rgt__destroyResponse:
			soap_in_rgt__destroyResponse(soap, NULL, NULL, "rgt:destroyResponse");
			break;
		case SOAP_TYPE_rgt__getInputFileResponse:
			soap_in_rgt__getInputFileResponse(soap, NULL, NULL, "rgt:getInputFileResponse");
			break;
		case SOAP_TYPE_rgt__getSteeringCommandsResponse:
			soap_in_rgt__getSteeringCommandsResponse(soap, NULL, NULL, "rgt:getSteeringCommandsResponse");
			break;
		case SOAP_TYPE_rgt__requestTerminationBeforeResponse:
			soap_in_rgt__requestTerminationBeforeResponse(soap, NULL, NULL, "rgt:requestTerminationBeforeResponse");
			break;
		case SOAP_TYPE_rgt__getChildNodesResponse:
			soap_in_rgt__getChildNodesResponse(soap, NULL, NULL, "rgt:getChildNodesResponse");
			break;
		case SOAP_TYPE_rgt__setCheckPointDataResponse:
			soap_in_rgt__setCheckPointDataResponse(soap, NULL, NULL, "rgt:setCheckPointDataResponse");
			break;
		case SOAP_TYPE_rgt__findServiceDataResponse:
			soap_in_rgt__findServiceDataResponse(soap, NULL, NULL, "rgt:findServiceDataResponse");
			break;
		case SOAP_TYPE_rgt__getCheckPointDataResponse:
			soap_in_rgt__getCheckPointDataResponse(soap, NULL, NULL, "rgt:getCheckPointDataResponse");
			break;
		case SOAP_TYPE_rgt__addNodeResponse:
			soap_in_rgt__addNodeResponse(soap, NULL, NULL, "rgt:addNodeResponse");
			break;
		case SOAP_TYPE_rgt__requestTerminationAfterResponse:
			soap_in_rgt__requestTerminationAfterResponse(soap, NULL, NULL, "rgt:requestTerminationAfterResponse");
			break;
		case SOAP_TYPE_rgt__getParentNodeResponse:
			soap_in_rgt__getParentNodeResponse(soap, NULL, NULL, "rgt:getParentNodeResponse");
			break;
		case SOAP_TYPE_rgtf__requestTerminationAfter:
			soap_in_rgtf__requestTerminationAfter(soap, NULL, NULL, "rgtf:requestTerminationAfter");
			break;
		case SOAP_TYPE_rgtf__requestTerminationBefore:
			soap_in_rgtf__requestTerminationBefore(soap, NULL, NULL, "rgtf:requestTerminationBefore");
			break;
		case SOAP_TYPE_rgtf__getActiveTrees:
			soap_in_rgtf__getActiveTrees(soap, NULL, NULL, "rgtf:getActiveTrees");
			break;
		case SOAP_TYPE_rgtf__findServiceData:
			soap_in_rgtf__findServiceData(soap, NULL, NULL, "rgtf:findServiceData");
			break;
		case SOAP_TYPE_rgtf__destroy:
			soap_in_rgtf__destroy(soap, NULL, NULL, "rgtf:destroy");
			break;
		case SOAP_TYPE_rgtf__findByHandle:
			soap_in_rgtf__findByHandle(soap, NULL, NULL, "rgtf:findByHandle");
			break;
		case SOAP_TYPE_rgtf__createNewTree:
			soap_in_rgtf__createNewTree(soap, NULL, NULL, "rgtf:createNewTree");
			break;
		case SOAP_TYPE_rgtf__destroyResponse:
			soap_in_rgtf__destroyResponse(soap, NULL, NULL, "rgtf:destroyResponse");
			break;
		case SOAP_TYPE_rgtf__requestTerminationAfterResponse:
			soap_in_rgtf__requestTerminationAfterResponse(soap, NULL, NULL, "rgtf:requestTerminationAfterResponse");
			break;
		case SOAP_TYPE_rgtf__createNewTreeResponse:
			soap_in_rgtf__createNewTreeResponse(soap, NULL, NULL, "rgtf:createNewTreeResponse");
			break;
		case SOAP_TYPE_rgtf__getActiveTreesResponse:
			soap_in_rgtf__getActiveTreesResponse(soap, NULL, NULL, "rgtf:getActiveTreesResponse");
			break;
		case SOAP_TYPE_rgtf__findByHandleResponse:
			soap_in_rgtf__findByHandleResponse(soap, NULL, NULL, "rgtf:findByHandleResponse");
			break;
		case SOAP_TYPE_rgtf__findServiceDataResponse:
			soap_in_rgtf__findServiceDataResponse(soap, NULL, NULL, "rgtf:findServiceDataResponse");
			break;
		case SOAP_TYPE_rgtf__requestTerminationBeforeResponse:
			soap_in_rgtf__requestTerminationBeforeResponse(soap, NULL, NULL, "rgtf:requestTerminationBeforeResponse");
			break;
		case SOAP_TYPE_sgr__findServiceData:
			soap_in_sgr__findServiceData(soap, NULL, NULL, "sgr:findServiceData");
			break;
		case SOAP_TYPE_sgr__add:
			soap_in_sgr__add(soap, NULL, NULL, "sgr:add");
			break;
		case SOAP_TYPE_sgr__remove:
			soap_in_sgr__remove(soap, NULL, NULL, "sgr:remove");
			break;
		case SOAP_TYPE_sgr__removeResponse:
			soap_in_sgr__removeResponse(soap, NULL, NULL, "sgr:removeResponse");
			break;
		case SOAP_TYPE_sgr__addResponse:
			soap_in_sgr__addResponse(soap, NULL, NULL, "sgr:addResponse");
			break;
		case SOAP_TYPE_ArrayOf_USCORE_xsd_USCORE_string:
			soap_in_ArrayOf_USCORE_xsd_USCORE_string(soap, NULL, NULL, "xsd:string");
			break;
		case SOAP_TYPE_sgr__findServiceDataResponse:
			soap_in_sgr__findServiceDataResponse(soap, NULL, NULL, "sgr:findServiceDataResponse");
			break;
		case SOAP_TYPE_sgs__ClearStatusMsgQueue:
			soap_in_sgs__ClearStatusMsgQueue(soap, NULL, NULL, "sgs:ClearStatusMsgQueue");
			break;
		case SOAP_TYPE_sgs__Resume:
			soap_in_sgs__Resume(soap, NULL, NULL, "sgs:Resume");
			break;
		case SOAP_TYPE_sgs__AppStart:
			soap_in_sgs__AppStart(soap, NULL, NULL, "sgs:AppStart");
			break;
		case SOAP_TYPE_sgs__GetNotifications:
			soap_in_sgs__GetNotifications(soap, NULL, NULL, "sgs:GetNotifications");
			break;
		case SOAP_TYPE_sgs__Pause:
			soap_in_sgs__Pause(soap, NULL, NULL, "sgs:Pause");
			break;
		case SOAP_TYPE_sgs__AppRecordChkpoint:
			soap_in_sgs__AppRecordChkpoint(soap, NULL, NULL, "sgs:AppRecordChkpoint");
			break;
		case SOAP_TYPE_sgs__findServiceData:
			soap_in_sgs__findServiceData(soap, NULL, NULL, "sgs:findServiceData");
			break;
		case SOAP_TYPE_sgs__PutControl:
			soap_in_sgs__PutControl(soap, NULL, NULL, "sgs:PutControl");
			break;
		case SOAP_TYPE_sgs__Detach:
			soap_in_sgs__Detach(soap, NULL, NULL, "sgs:Detach");
			break;
		case SOAP_TYPE_sgs__Stop:
			soap_in_sgs__Stop(soap, NULL, NULL, "sgs:Stop");
			break;
		case SOAP_TYPE_sgs__GetNthDataSource:
			soap_in_sgs__GetNthDataSource(soap, NULL, NULL, "sgs:GetNthDataSource");
			break;
		case SOAP_TYPE_sgs__Attach:
			soap_in_sgs__Attach(soap, NULL, NULL, "sgs:Attach");
			break;
		case SOAP_TYPE_sgs__Restart:
			soap_in_sgs__Restart(soap, NULL, NULL, "sgs:Restart");
			break;
		case SOAP_TYPE_sgs__GetStatus:
			soap_in_sgs__GetStatus(soap, NULL, NULL, "sgs:GetStatus");
			break;
		case SOAP_TYPE_sgs__GetControl:
			soap_in_sgs__GetControl(soap, NULL, NULL, "sgs:GetControl");
			break;
		case SOAP_TYPE_sgs__AppStop:
			soap_in_sgs__AppStop(soap, NULL, NULL, "sgs:AppStop");
			break;
		case SOAP_TYPE_sgs__PutStatus:
			soap_in_sgs__PutStatus(soap, NULL, NULL, "sgs:PutStatus");
			break;
		case SOAP_TYPE_sgs__AppDetach:
			soap_in_sgs__AppDetach(soap, NULL, NULL, "sgs:AppDetach");
			break;
		case SOAP_TYPE_sgs__destroy:
			soap_in_sgs__destroy(soap, NULL, NULL, "sgs:destroy");
			break;
		case SOAP_TYPE_sgs__setServiceData:
			soap_in_sgs__setServiceData(soap, NULL, NULL, "sgs:setServiceData");
			break;
		case SOAP_TYPE_sgs__findServiceDataResponse:
			soap_in_sgs__findServiceDataResponse(soap, NULL, NULL, "sgs:findServiceDataResponse");
			break;
		case SOAP_TYPE_sgs__setServiceDataResponse:
			soap_in_sgs__setServiceDataResponse(soap, NULL, NULL, "sgs:setServiceDataResponse");
			break;
		case SOAP_TYPE_sgs__ResumeResponse:
			soap_in_sgs__ResumeResponse(soap, NULL, NULL, "sgs:ResumeResponse");
			break;
		case SOAP_TYPE_sgs__AttachResponse:
			soap_in_sgs__AttachResponse(soap, NULL, NULL, "sgs:AttachResponse");
			break;
		case SOAP_TYPE_sgs__GetControlResponse:
			soap_in_sgs__GetControlResponse(soap, NULL, NULL, "sgs:GetControlResponse");
			break;
		case SOAP_TYPE_sgs__GetNotificationsResponse:
			soap_in_sgs__GetNotificationsResponse(soap, NULL, NULL, "sgs:GetNotificationsResponse");
			break;
		case SOAP_TYPE_sgs__ClearStatusMsgQueueResponse:
			soap_in_sgs__ClearStatusMsgQueueResponse(soap, NULL, NULL, "sgs:ClearStatusMsgQueueResponse");
			break;
		case SOAP_TYPE_sgs__DetachResponse:
			soap_in_sgs__DetachResponse(soap, NULL, NULL, "sgs:DetachResponse");
			break;
		case SOAP_TYPE_sgs__PutStatusResponse:
			soap_in_sgs__PutStatusResponse(soap, NULL, NULL, "sgs:PutStatusResponse");
			break;
		case SOAP_TYPE_sgs__destroyResponse:
			soap_in_sgs__destroyResponse(soap, NULL, NULL, "sgs:destroyResponse");
			break;
		case SOAP_TYPE_sgs__AppStopResponse:
			soap_in_sgs__AppStopResponse(soap, NULL, NULL, "sgs:AppStopResponse");
			break;
		case SOAP_TYPE_sgs__StopResponse:
			soap_in_sgs__StopResponse(soap, NULL, NULL, "sgs:StopResponse");
			break;
		case SOAP_TYPE_sgs__PutControlResponse:
			soap_in_sgs__PutControlResponse(soap, NULL, NULL, "sgs:PutControlResponse");
			break;
		case SOAP_TYPE_sgs__GetNthDataSourceResponse:
			soap_in_sgs__GetNthDataSourceResponse(soap, NULL, NULL, "sgs:GetNthDataSourceResponse");
			break;
		case SOAP_TYPE_sgs__AppDetachResponse:
			soap_in_sgs__AppDetachResponse(soap, NULL, NULL, "sgs:AppDetachResponse");
			break;
		case SOAP_TYPE_sgs__AppRecordChkpointResponse:
			soap_in_sgs__AppRecordChkpointResponse(soap, NULL, NULL, "sgs:AppRecordChkpointResponse");
			break;
		case SOAP_TYPE_sgs__RestartResponse:
			soap_in_sgs__RestartResponse(soap, NULL, NULL, "sgs:RestartResponse");
			break;
		case SOAP_TYPE_sgs__AppStartResponse:
			soap_in_sgs__AppStartResponse(soap, NULL, NULL, "sgs:AppStartResponse");
			break;
		case SOAP_TYPE_sgs__PauseResponse:
			soap_in_sgs__PauseResponse(soap, NULL, NULL, "sgs:PauseResponse");
			break;
		case SOAP_TYPE_sgs__GetStatusResponse:
			soap_in_sgs__GetStatusResponse(soap, NULL, NULL, "sgs:GetStatusResponse");
			break;
		case SOAP_TYPE_PointerTorgt__addNodeResponse:
			soap_in_PointerTorgt__addNodeResponse(soap, NULL, NULL, "rgt:addNodeResponse");
			break;
		case SOAP_TYPE_PointerTorgt__getParentNodeResponse:
			soap_in_PointerTorgt__getParentNodeResponse(soap, NULL, NULL, "rgt:getParentNodeResponse");
			break;
		case SOAP_TYPE_PointerTorgt__getCheckPointDataResponse:
			soap_in_PointerTorgt__getCheckPointDataResponse(soap, NULL, NULL, "rgt:getCheckPointDataResponse");
			break;
		case SOAP_TYPE_PointerTorgt__requestTerminationBeforeResponse:
			soap_in_PointerTorgt__requestTerminationBeforeResponse(soap, NULL, NULL, "rgt:requestTerminationBeforeResponse");
			break;
		case SOAP_TYPE_PointerTorgt__getSteeringCommandsResponse:
			soap_in_PointerTorgt__getSteeringCommandsResponse(soap, NULL, NULL, "rgt:getSteeringCommandsResponse");
			break;
		case SOAP_TYPE_PointerTorgt__destroyResponse:
			soap_in_PointerTorgt__destroyResponse(soap, NULL, NULL, "rgt:destroyResponse");
			break;
		case SOAP_TYPE_PointerTorgt__setCheckPointDataResponse:
			soap_in_PointerTorgt__setCheckPointDataResponse(soap, NULL, NULL, "rgt:setCheckPointDataResponse");
			break;
		case SOAP_TYPE_PointerTorgt__findServiceDataResponse:
			soap_in_PointerTorgt__findServiceDataResponse(soap, NULL, NULL, "rgt:findServiceDataResponse");
			break;
		case SOAP_TYPE_PointerTorgt__getInputFileResponse:
			soap_in_PointerTorgt__getInputFileResponse(soap, NULL, NULL, "rgt:getInputFileResponse");
			break;
		case SOAP_TYPE_PointerTorgt__getChildNodesResponse:
			soap_in_PointerTorgt__getChildNodesResponse(soap, NULL, NULL, "rgt:getChildNodesResponse");
			break;
		case SOAP_TYPE_PointerTorgt__requestTerminationAfterResponse:
			soap_in_PointerTorgt__requestTerminationAfterResponse(soap, NULL, NULL, "rgt:requestTerminationAfterResponse");
			break;
		case SOAP_TYPE_PointerTorgtf__requestTerminationAfterResponse:
			soap_in_PointerTorgtf__requestTerminationAfterResponse(soap, NULL, NULL, "rgtf:requestTerminationAfterResponse");
			break;
		case SOAP_TYPE_PointerTorgtf__requestTerminationBeforeResponse:
			soap_in_PointerTorgtf__requestTerminationBeforeResponse(soap, NULL, NULL, "rgtf:requestTerminationBeforeResponse");
			break;
		case SOAP_TYPE_PointerTorgtf__getActiveTreesResponse:
			soap_in_PointerTorgtf__getActiveTreesResponse(soap, NULL, NULL, "rgtf:getActiveTreesResponse");
			break;
		case SOAP_TYPE_PointerTorgtf__findServiceDataResponse:
			soap_in_PointerTorgtf__findServiceDataResponse(soap, NULL, NULL, "rgtf:findServiceDataResponse");
			break;
		case SOAP_TYPE_PointerTorgtf__destroyResponse:
			soap_in_PointerTorgtf__destroyResponse(soap, NULL, NULL, "rgtf:destroyResponse");
			break;
		case SOAP_TYPE_PointerTorgtf__findByHandleResponse:
			soap_in_PointerTorgtf__findByHandleResponse(soap, NULL, NULL, "rgtf:findByHandleResponse");
			break;
		case SOAP_TYPE_PointerTorgtf__createNewTreeResponse:
			soap_in_PointerTorgtf__createNewTreeResponse(soap, NULL, NULL, "rgtf:createNewTreeResponse");
			break;
		case SOAP_TYPE_PointerTosgr__findServiceDataResponse:
			soap_in_PointerTosgr__findServiceDataResponse(soap, NULL, NULL, "sgr:findServiceDataResponse");
			break;
		case SOAP_TYPE_PointerTosgr__addResponse:
			soap_in_PointerTosgr__addResponse(soap, NULL, NULL, "sgr:addResponse");
			break;
		case SOAP_TYPE_PointerTosgr__removeResponse:
			soap_in_PointerTosgr__removeResponse(soap, NULL, NULL, "sgr:removeResponse");
			break;
		case SOAP_TYPE_PointerToxsd__string:
			soap_in_PointerToxsd__string(soap, NULL, NULL, "xsd:string");
			break;
		case SOAP_TYPE_PointerToArrayOf_USCORE_xsd_USCORE_string:
			soap_in_PointerToArrayOf_USCORE_xsd_USCORE_string(soap, NULL, NULL, "xsd:string");
			break;
		case SOAP_TYPE_PointerTosgs__ClearStatusMsgQueueResponse:
			soap_in_PointerTosgs__ClearStatusMsgQueueResponse(soap, NULL, NULL, "sgs:ClearStatusMsgQueueResponse");
			break;
		case SOAP_TYPE_PointerTosgs__ResumeResponse:
			soap_in_PointerTosgs__ResumeResponse(soap, NULL, NULL, "sgs:ResumeResponse");
			break;
		case SOAP_TYPE_PointerTosgs__AppStartResponse:
			soap_in_PointerTosgs__AppStartResponse(soap, NULL, NULL, "sgs:AppStartResponse");
			break;
		case SOAP_TYPE_PointerTosgs__GetNotificationsResponse:
			soap_in_PointerTosgs__GetNotificationsResponse(soap, NULL, NULL, "sgs:GetNotificationsResponse");
			break;
		case SOAP_TYPE_PointerTosgs__PauseResponse:
			soap_in_PointerTosgs__PauseResponse(soap, NULL, NULL, "sgs:PauseResponse");
			break;
		case SOAP_TYPE_PointerTosgs__AppRecordChkpointResponse:
			soap_in_PointerTosgs__AppRecordChkpointResponse(soap, NULL, NULL, "sgs:AppRecordChkpointResponse");
			break;
		case SOAP_TYPE_PointerTosgs__findServiceDataResponse:
			soap_in_PointerTosgs__findServiceDataResponse(soap, NULL, NULL, "sgs:findServiceDataResponse");
			break;
		case SOAP_TYPE_PointerTosgs__PutControlResponse:
			soap_in_PointerTosgs__PutControlResponse(soap, NULL, NULL, "sgs:PutControlResponse");
			break;
		case SOAP_TYPE_PointerTosgs__DetachResponse:
			soap_in_PointerTosgs__DetachResponse(soap, NULL, NULL, "sgs:DetachResponse");
			break;
		case SOAP_TYPE_PointerTosgs__StopResponse:
			soap_in_PointerTosgs__StopResponse(soap, NULL, NULL, "sgs:StopResponse");
			break;
		case SOAP_TYPE_PointerTosgs__GetNthDataSourceResponse:
			soap_in_PointerTosgs__GetNthDataSourceResponse(soap, NULL, NULL, "sgs:GetNthDataSourceResponse");
			break;
		case SOAP_TYPE_PointerTosgs__AttachResponse:
			soap_in_PointerTosgs__AttachResponse(soap, NULL, NULL, "sgs:AttachResponse");
			break;
		case SOAP_TYPE_PointerTosgs__RestartResponse:
			soap_in_PointerTosgs__RestartResponse(soap, NULL, NULL, "sgs:RestartResponse");
			break;
		case SOAP_TYPE_PointerTosgs__GetStatusResponse:
			soap_in_PointerTosgs__GetStatusResponse(soap, NULL, NULL, "sgs:GetStatusResponse");
			break;
		case SOAP_TYPE_PointerTosgs__GetControlResponse:
			soap_in_PointerTosgs__GetControlResponse(soap, NULL, NULL, "sgs:GetControlResponse");
			break;
		case SOAP_TYPE_PointerTosgs__AppStopResponse:
			soap_in_PointerTosgs__AppStopResponse(soap, NULL, NULL, "sgs:AppStopResponse");
			break;
		case SOAP_TYPE_PointerTosgs__PutStatusResponse:
			soap_in_PointerTosgs__PutStatusResponse(soap, NULL, NULL, "sgs:PutStatusResponse");
			break;
		case SOAP_TYPE_PointerTosgs__AppDetachResponse:
			soap_in_PointerTosgs__AppDetachResponse(soap, NULL, NULL, "sgs:AppDetachResponse");
			break;
		case SOAP_TYPE_PointerTosgs__destroyResponse:
			soap_in_PointerTosgs__destroyResponse(soap, NULL, NULL, "sgs:destroyResponse");
			break;
		case SOAP_TYPE_PointerTosgs__setServiceDataResponse:
			soap_in_PointerTosgs__setServiceDataResponse(soap, NULL, NULL, "sgs:setServiceDataResponse");
			break;
		case SOAP_TYPE_xsd__string:
			soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
			break;
		case SOAP_TYPE_string:
			soap_in_string(soap, NULL, NULL, "");
			break;
		default:
			if (!*soap->id)
			{	if (soap_ignore_element(soap))
					break;
				else
					continue;
			}
			soap_in_byte(soap, NULL, NULL, "xsd:byte");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_int(soap, NULL, NULL, "xsd:int");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgt__addNode(soap, NULL, NULL, "rgt:addNode");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgt__getParentNode(soap, NULL, NULL, "rgt:getParentNode");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgt__getCheckPointData(soap, NULL, NULL, "rgt:getCheckPointData");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgt__requestTerminationBefore(soap, NULL, NULL, "rgt:requestTerminationBefore");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgt__getSteeringCommands(soap, NULL, NULL, "rgt:getSteeringCommands");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgt__destroy(soap, NULL, NULL, "rgt:destroy");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgt__setCheckPointData(soap, NULL, NULL, "rgt:setCheckPointData");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgt__findServiceData(soap, NULL, NULL, "rgt:findServiceData");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgt__getInputFile(soap, NULL, NULL, "rgt:getInputFile");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgt__getChildNodes(soap, NULL, NULL, "rgt:getChildNodes");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgt__requestTerminationAfter(soap, NULL, NULL, "rgt:requestTerminationAfter");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgt__destroyResponse(soap, NULL, NULL, "rgt:destroyResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgt__getInputFileResponse(soap, NULL, NULL, "rgt:getInputFileResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgt__getSteeringCommandsResponse(soap, NULL, NULL, "rgt:getSteeringCommandsResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgt__requestTerminationBeforeResponse(soap, NULL, NULL, "rgt:requestTerminationBeforeResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgt__getChildNodesResponse(soap, NULL, NULL, "rgt:getChildNodesResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgt__setCheckPointDataResponse(soap, NULL, NULL, "rgt:setCheckPointDataResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgt__findServiceDataResponse(soap, NULL, NULL, "rgt:findServiceDataResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgt__getCheckPointDataResponse(soap, NULL, NULL, "rgt:getCheckPointDataResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgt__addNodeResponse(soap, NULL, NULL, "rgt:addNodeResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgt__requestTerminationAfterResponse(soap, NULL, NULL, "rgt:requestTerminationAfterResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgt__getParentNodeResponse(soap, NULL, NULL, "rgt:getParentNodeResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgtf__requestTerminationAfter(soap, NULL, NULL, "rgtf:requestTerminationAfter");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgtf__requestTerminationBefore(soap, NULL, NULL, "rgtf:requestTerminationBefore");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgtf__getActiveTrees(soap, NULL, NULL, "rgtf:getActiveTrees");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgtf__findServiceData(soap, NULL, NULL, "rgtf:findServiceData");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgtf__destroy(soap, NULL, NULL, "rgtf:destroy");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgtf__findByHandle(soap, NULL, NULL, "rgtf:findByHandle");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgtf__createNewTree(soap, NULL, NULL, "rgtf:createNewTree");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgtf__destroyResponse(soap, NULL, NULL, "rgtf:destroyResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgtf__requestTerminationAfterResponse(soap, NULL, NULL, "rgtf:requestTerminationAfterResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgtf__createNewTreeResponse(soap, NULL, NULL, "rgtf:createNewTreeResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgtf__getActiveTreesResponse(soap, NULL, NULL, "rgtf:getActiveTreesResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgtf__findByHandleResponse(soap, NULL, NULL, "rgtf:findByHandleResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgtf__findServiceDataResponse(soap, NULL, NULL, "rgtf:findServiceDataResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_rgtf__requestTerminationBeforeResponse(soap, NULL, NULL, "rgtf:requestTerminationBeforeResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgr__findServiceData(soap, NULL, NULL, "sgr:findServiceData");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgr__add(soap, NULL, NULL, "sgr:add");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgr__remove(soap, NULL, NULL, "sgr:remove");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgr__removeResponse(soap, NULL, NULL, "sgr:removeResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgr__addResponse(soap, NULL, NULL, "sgr:addResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_ArrayOf_USCORE_xsd_USCORE_string(soap, NULL, NULL, "xsd:string");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgr__findServiceDataResponse(soap, NULL, NULL, "sgr:findServiceDataResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__ClearStatusMsgQueue(soap, NULL, NULL, "sgs:ClearStatusMsgQueue");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__Resume(soap, NULL, NULL, "sgs:Resume");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__AppStart(soap, NULL, NULL, "sgs:AppStart");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__GetNotifications(soap, NULL, NULL, "sgs:GetNotifications");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__Pause(soap, NULL, NULL, "sgs:Pause");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__AppRecordChkpoint(soap, NULL, NULL, "sgs:AppRecordChkpoint");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__findServiceData(soap, NULL, NULL, "sgs:findServiceData");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__PutControl(soap, NULL, NULL, "sgs:PutControl");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__Detach(soap, NULL, NULL, "sgs:Detach");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__Stop(soap, NULL, NULL, "sgs:Stop");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__GetNthDataSource(soap, NULL, NULL, "sgs:GetNthDataSource");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__Attach(soap, NULL, NULL, "sgs:Attach");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__Restart(soap, NULL, NULL, "sgs:Restart");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__GetStatus(soap, NULL, NULL, "sgs:GetStatus");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__GetControl(soap, NULL, NULL, "sgs:GetControl");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__AppStop(soap, NULL, NULL, "sgs:AppStop");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__PutStatus(soap, NULL, NULL, "sgs:PutStatus");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__AppDetach(soap, NULL, NULL, "sgs:AppDetach");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__destroy(soap, NULL, NULL, "sgs:destroy");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__setServiceData(soap, NULL, NULL, "sgs:setServiceData");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__findServiceDataResponse(soap, NULL, NULL, "sgs:findServiceDataResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__setServiceDataResponse(soap, NULL, NULL, "sgs:setServiceDataResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__ResumeResponse(soap, NULL, NULL, "sgs:ResumeResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__AttachResponse(soap, NULL, NULL, "sgs:AttachResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__GetControlResponse(soap, NULL, NULL, "sgs:GetControlResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__GetNotificationsResponse(soap, NULL, NULL, "sgs:GetNotificationsResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__ClearStatusMsgQueueResponse(soap, NULL, NULL, "sgs:ClearStatusMsgQueueResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__DetachResponse(soap, NULL, NULL, "sgs:DetachResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__PutStatusResponse(soap, NULL, NULL, "sgs:PutStatusResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__destroyResponse(soap, NULL, NULL, "sgs:destroyResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__AppStopResponse(soap, NULL, NULL, "sgs:AppStopResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__StopResponse(soap, NULL, NULL, "sgs:StopResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__PutControlResponse(soap, NULL, NULL, "sgs:PutControlResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__GetNthDataSourceResponse(soap, NULL, NULL, "sgs:GetNthDataSourceResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__AppDetachResponse(soap, NULL, NULL, "sgs:AppDetachResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__AppRecordChkpointResponse(soap, NULL, NULL, "sgs:AppRecordChkpointResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__RestartResponse(soap, NULL, NULL, "sgs:RestartResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__AppStartResponse(soap, NULL, NULL, "sgs:AppStartResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__PauseResponse(soap, NULL, NULL, "sgs:PauseResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_sgs__GetStatusResponse(soap, NULL, NULL, "sgs:GetStatusResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_string(soap, NULL, NULL, "xsd:string");
			if (soap->error)
			{	soap->peeked = 1;
				soap_ignore_element(soap);
			}
		}
		if (soap->error)
			break;
	}
	if (soap->error == SOAP_NO_TAG)
		soap->error = SOAP_OK;
	return soap->error;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version != 1 || (soap->mode & SOAP_XML_GRAPH) || (soap->mode & SOAP_XML_TREE))
		return SOAP_OK;
	for (i = 0; i < SOAP_PTRHASH; i++)
		for (pp = soap->pht[i]; pp; pp = pp->next)
			if ((soap->mode & SOAP_IO_LENGTH) ? pp->mark1 == 2 : pp->mark2 == 2)
				switch (pp->type)
				{
				case SOAP_TYPE_byte:
					soap_out_byte(soap, "id", pp->id, (const char *)pp->ptr, "xsd:byte");
					break;
				case SOAP_TYPE_xsd__int:
					soap_out_xsd__int(soap, "id", pp->id, (const int *)pp->ptr, "xsd:int");
					break;
				case SOAP_TYPE_int:
					soap_out_int(soap, "id", pp->id, (const int *)pp->ptr, "xsd:int");
					break;
				case SOAP_TYPE_rgt__addNode:
					soap_out_rgt__addNode(soap, "id", pp->id, (const struct rgt__addNode *)pp->ptr, "rgt:addNode");
					break;
				case SOAP_TYPE_rgt__getParentNode:
					soap_out_rgt__getParentNode(soap, "id", pp->id, (const struct rgt__getParentNode *)pp->ptr, "rgt:getParentNode");
					break;
				case SOAP_TYPE_rgt__getCheckPointData:
					soap_out_rgt__getCheckPointData(soap, "id", pp->id, (const struct rgt__getCheckPointData *)pp->ptr, "rgt:getCheckPointData");
					break;
				case SOAP_TYPE_rgt__requestTerminationBefore:
					soap_out_rgt__requestTerminationBefore(soap, "id", pp->id, (const struct rgt__requestTerminationBefore *)pp->ptr, "rgt:requestTerminationBefore");
					break;
				case SOAP_TYPE_rgt__getSteeringCommands:
					soap_out_rgt__getSteeringCommands(soap, "id", pp->id, (const struct rgt__getSteeringCommands *)pp->ptr, "rgt:getSteeringCommands");
					break;
				case SOAP_TYPE_rgt__destroy:
					soap_out_rgt__destroy(soap, "id", pp->id, (const struct rgt__destroy *)pp->ptr, "rgt:destroy");
					break;
				case SOAP_TYPE_rgt__setCheckPointData:
					soap_out_rgt__setCheckPointData(soap, "id", pp->id, (const struct rgt__setCheckPointData *)pp->ptr, "rgt:setCheckPointData");
					break;
				case SOAP_TYPE_rgt__findServiceData:
					soap_out_rgt__findServiceData(soap, "id", pp->id, (const struct rgt__findServiceData *)pp->ptr, "rgt:findServiceData");
					break;
				case SOAP_TYPE_rgt__getInputFile:
					soap_out_rgt__getInputFile(soap, "id", pp->id, (const struct rgt__getInputFile *)pp->ptr, "rgt:getInputFile");
					break;
				case SOAP_TYPE_rgt__getChildNodes:
					soap_out_rgt__getChildNodes(soap, "id", pp->id, (const struct rgt__getChildNodes *)pp->ptr, "rgt:getChildNodes");
					break;
				case SOAP_TYPE_rgt__requestTerminationAfter:
					soap_out_rgt__requestTerminationAfter(soap, "id", pp->id, (const struct rgt__requestTerminationAfter *)pp->ptr, "rgt:requestTerminationAfter");
					break;
				case SOAP_TYPE_rgt__destroyResponse:
					soap_out_rgt__destroyResponse(soap, "id", pp->id, (const struct rgt__destroyResponse *)pp->ptr, "rgt:destroyResponse");
					break;
				case SOAP_TYPE_rgt__getInputFileResponse:
					soap_out_rgt__getInputFileResponse(soap, "id", pp->id, (const struct rgt__getInputFileResponse *)pp->ptr, "rgt:getInputFileResponse");
					break;
				case SOAP_TYPE_rgt__getSteeringCommandsResponse:
					soap_out_rgt__getSteeringCommandsResponse(soap, "id", pp->id, (const struct rgt__getSteeringCommandsResponse *)pp->ptr, "rgt:getSteeringCommandsResponse");
					break;
				case SOAP_TYPE_rgt__requestTerminationBeforeResponse:
					soap_out_rgt__requestTerminationBeforeResponse(soap, "id", pp->id, (const struct rgt__requestTerminationBeforeResponse *)pp->ptr, "rgt:requestTerminationBeforeResponse");
					break;
				case SOAP_TYPE_rgt__getChildNodesResponse:
					soap_out_rgt__getChildNodesResponse(soap, "id", pp->id, (const struct rgt__getChildNodesResponse *)pp->ptr, "rgt:getChildNodesResponse");
					break;
				case SOAP_TYPE_rgt__setCheckPointDataResponse:
					soap_out_rgt__setCheckPointDataResponse(soap, "id", pp->id, (const struct rgt__setCheckPointDataResponse *)pp->ptr, "rgt:setCheckPointDataResponse");
					break;
				case SOAP_TYPE_rgt__findServiceDataResponse:
					soap_out_rgt__findServiceDataResponse(soap, "id", pp->id, (const struct rgt__findServiceDataResponse *)pp->ptr, "rgt:findServiceDataResponse");
					break;
				case SOAP_TYPE_rgt__getCheckPointDataResponse:
					soap_out_rgt__getCheckPointDataResponse(soap, "id", pp->id, (const struct rgt__getCheckPointDataResponse *)pp->ptr, "rgt:getCheckPointDataResponse");
					break;
				case SOAP_TYPE_rgt__addNodeResponse:
					soap_out_rgt__addNodeResponse(soap, "id", pp->id, (const struct rgt__addNodeResponse *)pp->ptr, "rgt:addNodeResponse");
					break;
				case SOAP_TYPE_rgt__requestTerminationAfterResponse:
					soap_out_rgt__requestTerminationAfterResponse(soap, "id", pp->id, (const struct rgt__requestTerminationAfterResponse *)pp->ptr, "rgt:requestTerminationAfterResponse");
					break;
				case SOAP_TYPE_rgt__getParentNodeResponse:
					soap_out_rgt__getParentNodeResponse(soap, "id", pp->id, (const struct rgt__getParentNodeResponse *)pp->ptr, "rgt:getParentNodeResponse");
					break;
				case SOAP_TYPE_rgtf__requestTerminationAfter:
					soap_out_rgtf__requestTerminationAfter(soap, "id", pp->id, (const struct rgtf__requestTerminationAfter *)pp->ptr, "rgtf:requestTerminationAfter");
					break;
				case SOAP_TYPE_rgtf__requestTerminationBefore:
					soap_out_rgtf__requestTerminationBefore(soap, "id", pp->id, (const struct rgtf__requestTerminationBefore *)pp->ptr, "rgtf:requestTerminationBefore");
					break;
				case SOAP_TYPE_rgtf__getActiveTrees:
					soap_out_rgtf__getActiveTrees(soap, "id", pp->id, (const struct rgtf__getActiveTrees *)pp->ptr, "rgtf:getActiveTrees");
					break;
				case SOAP_TYPE_rgtf__findServiceData:
					soap_out_rgtf__findServiceData(soap, "id", pp->id, (const struct rgtf__findServiceData *)pp->ptr, "rgtf:findServiceData");
					break;
				case SOAP_TYPE_rgtf__destroy:
					soap_out_rgtf__destroy(soap, "id", pp->id, (const struct rgtf__destroy *)pp->ptr, "rgtf:destroy");
					break;
				case SOAP_TYPE_rgtf__findByHandle:
					soap_out_rgtf__findByHandle(soap, "id", pp->id, (const struct rgtf__findByHandle *)pp->ptr, "rgtf:findByHandle");
					break;
				case SOAP_TYPE_rgtf__createNewTree:
					soap_out_rgtf__createNewTree(soap, "id", pp->id, (const struct rgtf__createNewTree *)pp->ptr, "rgtf:createNewTree");
					break;
				case SOAP_TYPE_rgtf__destroyResponse:
					soap_out_rgtf__destroyResponse(soap, "id", pp->id, (const struct rgtf__destroyResponse *)pp->ptr, "rgtf:destroyResponse");
					break;
				case SOAP_TYPE_rgtf__requestTerminationAfterResponse:
					soap_out_rgtf__requestTerminationAfterResponse(soap, "id", pp->id, (const struct rgtf__requestTerminationAfterResponse *)pp->ptr, "rgtf:requestTerminationAfterResponse");
					break;
				case SOAP_TYPE_rgtf__createNewTreeResponse:
					soap_out_rgtf__createNewTreeResponse(soap, "id", pp->id, (const struct rgtf__createNewTreeResponse *)pp->ptr, "rgtf:createNewTreeResponse");
					break;
				case SOAP_TYPE_rgtf__getActiveTreesResponse:
					soap_out_rgtf__getActiveTreesResponse(soap, "id", pp->id, (const struct rgtf__getActiveTreesResponse *)pp->ptr, "rgtf:getActiveTreesResponse");
					break;
				case SOAP_TYPE_rgtf__findByHandleResponse:
					soap_out_rgtf__findByHandleResponse(soap, "id", pp->id, (const struct rgtf__findByHandleResponse *)pp->ptr, "rgtf:findByHandleResponse");
					break;
				case SOAP_TYPE_rgtf__findServiceDataResponse:
					soap_out_rgtf__findServiceDataResponse(soap, "id", pp->id, (const struct rgtf__findServiceDataResponse *)pp->ptr, "rgtf:findServiceDataResponse");
					break;
				case SOAP_TYPE_rgtf__requestTerminationBeforeResponse:
					soap_out_rgtf__requestTerminationBeforeResponse(soap, "id", pp->id, (const struct rgtf__requestTerminationBeforeResponse *)pp->ptr, "rgtf:requestTerminationBeforeResponse");
					break;
				case SOAP_TYPE_sgr__findServiceData:
					soap_out_sgr__findServiceData(soap, "id", pp->id, (const struct sgr__findServiceData *)pp->ptr, "sgr:findServiceData");
					break;
				case SOAP_TYPE_sgr__add:
					soap_out_sgr__add(soap, "id", pp->id, (const struct sgr__add *)pp->ptr, "sgr:add");
					break;
				case SOAP_TYPE_sgr__remove:
					soap_out_sgr__remove(soap, "id", pp->id, (const struct sgr__remove *)pp->ptr, "sgr:remove");
					break;
				case SOAP_TYPE_sgr__removeResponse:
					soap_out_sgr__removeResponse(soap, "id", pp->id, (const struct sgr__removeResponse *)pp->ptr, "sgr:removeResponse");
					break;
				case SOAP_TYPE_sgr__addResponse:
					soap_out_sgr__addResponse(soap, "id", pp->id, (const struct sgr__addResponse *)pp->ptr, "sgr:addResponse");
					break;
				case SOAP_TYPE_ArrayOf_USCORE_xsd_USCORE_string:
					soap_out_ArrayOf_USCORE_xsd_USCORE_string(soap, "id", pp->id, (const struct ArrayOf_USCORE_xsd_USCORE_string *)pp->ptr, "xsd:string");
					break;
				case SOAP_TYPE_sgr__findServiceDataResponse:
					soap_out_sgr__findServiceDataResponse(soap, "id", pp->id, (const struct sgr__findServiceDataResponse *)pp->ptr, "sgr:findServiceDataResponse");
					break;
				case SOAP_TYPE_sgs__ClearStatusMsgQueue:
					soap_out_sgs__ClearStatusMsgQueue(soap, "id", pp->id, (const struct sgs__ClearStatusMsgQueue *)pp->ptr, "sgs:ClearStatusMsgQueue");
					break;
				case SOAP_TYPE_sgs__Resume:
					soap_out_sgs__Resume(soap, "id", pp->id, (const struct sgs__Resume *)pp->ptr, "sgs:Resume");
					break;
				case SOAP_TYPE_sgs__AppStart:
					soap_out_sgs__AppStart(soap, "id", pp->id, (const struct sgs__AppStart *)pp->ptr, "sgs:AppStart");
					break;
				case SOAP_TYPE_sgs__GetNotifications:
					soap_out_sgs__GetNotifications(soap, "id", pp->id, (const struct sgs__GetNotifications *)pp->ptr, "sgs:GetNotifications");
					break;
				case SOAP_TYPE_sgs__Pause:
					soap_out_sgs__Pause(soap, "id", pp->id, (const struct sgs__Pause *)pp->ptr, "sgs:Pause");
					break;
				case SOAP_TYPE_sgs__AppRecordChkpoint:
					soap_out_sgs__AppRecordChkpoint(soap, "id", pp->id, (const struct sgs__AppRecordChkpoint *)pp->ptr, "sgs:AppRecordChkpoint");
					break;
				case SOAP_TYPE_sgs__findServiceData:
					soap_out_sgs__findServiceData(soap, "id", pp->id, (const struct sgs__findServiceData *)pp->ptr, "sgs:findServiceData");
					break;
				case SOAP_TYPE_sgs__PutControl:
					soap_out_sgs__PutControl(soap, "id", pp->id, (const struct sgs__PutControl *)pp->ptr, "sgs:PutControl");
					break;
				case SOAP_TYPE_sgs__Detach:
					soap_out_sgs__Detach(soap, "id", pp->id, (const struct sgs__Detach *)pp->ptr, "sgs:Detach");
					break;
				case SOAP_TYPE_sgs__Stop:
					soap_out_sgs__Stop(soap, "id", pp->id, (const struct sgs__Stop *)pp->ptr, "sgs:Stop");
					break;
				case SOAP_TYPE_sgs__GetNthDataSource:
					soap_out_sgs__GetNthDataSource(soap, "id", pp->id, (const struct sgs__GetNthDataSource *)pp->ptr, "sgs:GetNthDataSource");
					break;
				case SOAP_TYPE_sgs__Attach:
					soap_out_sgs__Attach(soap, "id", pp->id, (const struct sgs__Attach *)pp->ptr, "sgs:Attach");
					break;
				case SOAP_TYPE_sgs__Restart:
					soap_out_sgs__Restart(soap, "id", pp->id, (const struct sgs__Restart *)pp->ptr, "sgs:Restart");
					break;
				case SOAP_TYPE_sgs__GetStatus:
					soap_out_sgs__GetStatus(soap, "id", pp->id, (const struct sgs__GetStatus *)pp->ptr, "sgs:GetStatus");
					break;
				case SOAP_TYPE_sgs__GetControl:
					soap_out_sgs__GetControl(soap, "id", pp->id, (const struct sgs__GetControl *)pp->ptr, "sgs:GetControl");
					break;
				case SOAP_TYPE_sgs__AppStop:
					soap_out_sgs__AppStop(soap, "id", pp->id, (const struct sgs__AppStop *)pp->ptr, "sgs:AppStop");
					break;
				case SOAP_TYPE_sgs__PutStatus:
					soap_out_sgs__PutStatus(soap, "id", pp->id, (const struct sgs__PutStatus *)pp->ptr, "sgs:PutStatus");
					break;
				case SOAP_TYPE_sgs__AppDetach:
					soap_out_sgs__AppDetach(soap, "id", pp->id, (const struct sgs__AppDetach *)pp->ptr, "sgs:AppDetach");
					break;
				case SOAP_TYPE_sgs__destroy:
					soap_out_sgs__destroy(soap, "id", pp->id, (const struct sgs__destroy *)pp->ptr, "sgs:destroy");
					break;
				case SOAP_TYPE_sgs__setServiceData:
					soap_out_sgs__setServiceData(soap, "id", pp->id, (const struct sgs__setServiceData *)pp->ptr, "sgs:setServiceData");
					break;
				case SOAP_TYPE_sgs__findServiceDataResponse:
					soap_out_sgs__findServiceDataResponse(soap, "id", pp->id, (const struct sgs__findServiceDataResponse *)pp->ptr, "sgs:findServiceDataResponse");
					break;
				case SOAP_TYPE_sgs__setServiceDataResponse:
					soap_out_sgs__setServiceDataResponse(soap, "id", pp->id, (const struct sgs__setServiceDataResponse *)pp->ptr, "sgs:setServiceDataResponse");
					break;
				case SOAP_TYPE_sgs__ResumeResponse:
					soap_out_sgs__ResumeResponse(soap, "id", pp->id, (const struct sgs__ResumeResponse *)pp->ptr, "sgs:ResumeResponse");
					break;
				case SOAP_TYPE_sgs__AttachResponse:
					soap_out_sgs__AttachResponse(soap, "id", pp->id, (const struct sgs__AttachResponse *)pp->ptr, "sgs:AttachResponse");
					break;
				case SOAP_TYPE_sgs__GetControlResponse:
					soap_out_sgs__GetControlResponse(soap, "id", pp->id, (const struct sgs__GetControlResponse *)pp->ptr, "sgs:GetControlResponse");
					break;
				case SOAP_TYPE_sgs__GetNotificationsResponse:
					soap_out_sgs__GetNotificationsResponse(soap, "id", pp->id, (const struct sgs__GetNotificationsResponse *)pp->ptr, "sgs:GetNotificationsResponse");
					break;
				case SOAP_TYPE_sgs__ClearStatusMsgQueueResponse:
					soap_out_sgs__ClearStatusMsgQueueResponse(soap, "id", pp->id, (const struct sgs__ClearStatusMsgQueueResponse *)pp->ptr, "sgs:ClearStatusMsgQueueResponse");
					break;
				case SOAP_TYPE_sgs__DetachResponse:
					soap_out_sgs__DetachResponse(soap, "id", pp->id, (const struct sgs__DetachResponse *)pp->ptr, "sgs:DetachResponse");
					break;
				case SOAP_TYPE_sgs__PutStatusResponse:
					soap_out_sgs__PutStatusResponse(soap, "id", pp->id, (const struct sgs__PutStatusResponse *)pp->ptr, "sgs:PutStatusResponse");
					break;
				case SOAP_TYPE_sgs__destroyResponse:
					soap_out_sgs__destroyResponse(soap, "id", pp->id, (const struct sgs__destroyResponse *)pp->ptr, "sgs:destroyResponse");
					break;
				case SOAP_TYPE_sgs__AppStopResponse:
					soap_out_sgs__AppStopResponse(soap, "id", pp->id, (const struct sgs__AppStopResponse *)pp->ptr, "sgs:AppStopResponse");
					break;
				case SOAP_TYPE_sgs__StopResponse:
					soap_out_sgs__StopResponse(soap, "id", pp->id, (const struct sgs__StopResponse *)pp->ptr, "sgs:StopResponse");
					break;
				case SOAP_TYPE_sgs__PutControlResponse:
					soap_out_sgs__PutControlResponse(soap, "id", pp->id, (const struct sgs__PutControlResponse *)pp->ptr, "sgs:PutControlResponse");
					break;
				case SOAP_TYPE_sgs__GetNthDataSourceResponse:
					soap_out_sgs__GetNthDataSourceResponse(soap, "id", pp->id, (const struct sgs__GetNthDataSourceResponse *)pp->ptr, "sgs:GetNthDataSourceResponse");
					break;
				case SOAP_TYPE_sgs__AppDetachResponse:
					soap_out_sgs__AppDetachResponse(soap, "id", pp->id, (const struct sgs__AppDetachResponse *)pp->ptr, "sgs:AppDetachResponse");
					break;
				case SOAP_TYPE_sgs__AppRecordChkpointResponse:
					soap_out_sgs__AppRecordChkpointResponse(soap, "id", pp->id, (const struct sgs__AppRecordChkpointResponse *)pp->ptr, "sgs:AppRecordChkpointResponse");
					break;
				case SOAP_TYPE_sgs__RestartResponse:
					soap_out_sgs__RestartResponse(soap, "id", pp->id, (const struct sgs__RestartResponse *)pp->ptr, "sgs:RestartResponse");
					break;
				case SOAP_TYPE_sgs__AppStartResponse:
					soap_out_sgs__AppStartResponse(soap, "id", pp->id, (const struct sgs__AppStartResponse *)pp->ptr, "sgs:AppStartResponse");
					break;
				case SOAP_TYPE_sgs__PauseResponse:
					soap_out_sgs__PauseResponse(soap, "id", pp->id, (const struct sgs__PauseResponse *)pp->ptr, "sgs:PauseResponse");
					break;
				case SOAP_TYPE_sgs__GetStatusResponse:
					soap_out_sgs__GetStatusResponse(soap, "id", pp->id, (const struct sgs__GetStatusResponse *)pp->ptr, "sgs:GetStatusResponse");
					break;
				case SOAP_TYPE_PointerTorgt__addNodeResponse:
					soap_out_PointerTorgt__addNodeResponse(soap, "id", pp->id, (struct rgt__addNodeResponse *const*)pp->ptr, "rgt:addNodeResponse");
					break;
				case SOAP_TYPE_PointerTorgt__getParentNodeResponse:
					soap_out_PointerTorgt__getParentNodeResponse(soap, "id", pp->id, (struct rgt__getParentNodeResponse *const*)pp->ptr, "rgt:getParentNodeResponse");
					break;
				case SOAP_TYPE_PointerTorgt__getCheckPointDataResponse:
					soap_out_PointerTorgt__getCheckPointDataResponse(soap, "id", pp->id, (struct rgt__getCheckPointDataResponse *const*)pp->ptr, "rgt:getCheckPointDataResponse");
					break;
				case SOAP_TYPE_PointerTorgt__requestTerminationBeforeResponse:
					soap_out_PointerTorgt__requestTerminationBeforeResponse(soap, "id", pp->id, (struct rgt__requestTerminationBeforeResponse *const*)pp->ptr, "rgt:requestTerminationBeforeResponse");
					break;
				case SOAP_TYPE_PointerTorgt__getSteeringCommandsResponse:
					soap_out_PointerTorgt__getSteeringCommandsResponse(soap, "id", pp->id, (struct rgt__getSteeringCommandsResponse *const*)pp->ptr, "rgt:getSteeringCommandsResponse");
					break;
				case SOAP_TYPE_PointerTorgt__destroyResponse:
					soap_out_PointerTorgt__destroyResponse(soap, "id", pp->id, (struct rgt__destroyResponse *const*)pp->ptr, "rgt:destroyResponse");
					break;
				case SOAP_TYPE_PointerTorgt__setCheckPointDataResponse:
					soap_out_PointerTorgt__setCheckPointDataResponse(soap, "id", pp->id, (struct rgt__setCheckPointDataResponse *const*)pp->ptr, "rgt:setCheckPointDataResponse");
					break;
				case SOAP_TYPE_PointerTorgt__findServiceDataResponse:
					soap_out_PointerTorgt__findServiceDataResponse(soap, "id", pp->id, (struct rgt__findServiceDataResponse *const*)pp->ptr, "rgt:findServiceDataResponse");
					break;
				case SOAP_TYPE_PointerTorgt__getInputFileResponse:
					soap_out_PointerTorgt__getInputFileResponse(soap, "id", pp->id, (struct rgt__getInputFileResponse *const*)pp->ptr, "rgt:getInputFileResponse");
					break;
				case SOAP_TYPE_PointerTorgt__getChildNodesResponse:
					soap_out_PointerTorgt__getChildNodesResponse(soap, "id", pp->id, (struct rgt__getChildNodesResponse *const*)pp->ptr, "rgt:getChildNodesResponse");
					break;
				case SOAP_TYPE_PointerTorgt__requestTerminationAfterResponse:
					soap_out_PointerTorgt__requestTerminationAfterResponse(soap, "id", pp->id, (struct rgt__requestTerminationAfterResponse *const*)pp->ptr, "rgt:requestTerminationAfterResponse");
					break;
				case SOAP_TYPE_PointerTorgtf__requestTerminationAfterResponse:
					soap_out_PointerTorgtf__requestTerminationAfterResponse(soap, "id", pp->id, (struct rgtf__requestTerminationAfterResponse *const*)pp->ptr, "rgtf:requestTerminationAfterResponse");
					break;
				case SOAP_TYPE_PointerTorgtf__requestTerminationBeforeResponse:
					soap_out_PointerTorgtf__requestTerminationBeforeResponse(soap, "id", pp->id, (struct rgtf__requestTerminationBeforeResponse *const*)pp->ptr, "rgtf:requestTerminationBeforeResponse");
					break;
				case SOAP_TYPE_PointerTorgtf__getActiveTreesResponse:
					soap_out_PointerTorgtf__getActiveTreesResponse(soap, "id", pp->id, (struct rgtf__getActiveTreesResponse *const*)pp->ptr, "rgtf:getActiveTreesResponse");
					break;
				case SOAP_TYPE_PointerTorgtf__findServiceDataResponse:
					soap_out_PointerTorgtf__findServiceDataResponse(soap, "id", pp->id, (struct rgtf__findServiceDataResponse *const*)pp->ptr, "rgtf:findServiceDataResponse");
					break;
				case SOAP_TYPE_PointerTorgtf__destroyResponse:
					soap_out_PointerTorgtf__destroyResponse(soap, "id", pp->id, (struct rgtf__destroyResponse *const*)pp->ptr, "rgtf:destroyResponse");
					break;
				case SOAP_TYPE_PointerTorgtf__findByHandleResponse:
					soap_out_PointerTorgtf__findByHandleResponse(soap, "id", pp->id, (struct rgtf__findByHandleResponse *const*)pp->ptr, "rgtf:findByHandleResponse");
					break;
				case SOAP_TYPE_PointerTorgtf__createNewTreeResponse:
					soap_out_PointerTorgtf__createNewTreeResponse(soap, "id", pp->id, (struct rgtf__createNewTreeResponse *const*)pp->ptr, "rgtf:createNewTreeResponse");
					break;
				case SOAP_TYPE_PointerTosgr__findServiceDataResponse:
					soap_out_PointerTosgr__findServiceDataResponse(soap, "id", pp->id, (struct sgr__findServiceDataResponse *const*)pp->ptr, "sgr:findServiceDataResponse");
					break;
				case SOAP_TYPE_PointerTosgr__addResponse:
					soap_out_PointerTosgr__addResponse(soap, "id", pp->id, (struct sgr__addResponse *const*)pp->ptr, "sgr:addResponse");
					break;
				case SOAP_TYPE_PointerTosgr__removeResponse:
					soap_out_PointerTosgr__removeResponse(soap, "id", pp->id, (struct sgr__removeResponse *const*)pp->ptr, "sgr:removeResponse");
					break;
				case SOAP_TYPE_PointerToxsd__string:
					soap_out_PointerToxsd__string(soap, "id", pp->id, (char **const*)pp->ptr, "xsd:string");
					break;
				case SOAP_TYPE_PointerToArrayOf_USCORE_xsd_USCORE_string:
					soap_out_PointerToArrayOf_USCORE_xsd_USCORE_string(soap, "id", pp->id, (struct ArrayOf_USCORE_xsd_USCORE_string *const*)pp->ptr, "xsd:string");
					break;
				case SOAP_TYPE_PointerTosgs__ClearStatusMsgQueueResponse:
					soap_out_PointerTosgs__ClearStatusMsgQueueResponse(soap, "id", pp->id, (struct sgs__ClearStatusMsgQueueResponse *const*)pp->ptr, "sgs:ClearStatusMsgQueueResponse");
					break;
				case SOAP_TYPE_PointerTosgs__ResumeResponse:
					soap_out_PointerTosgs__ResumeResponse(soap, "id", pp->id, (struct sgs__ResumeResponse *const*)pp->ptr, "sgs:ResumeResponse");
					break;
				case SOAP_TYPE_PointerTosgs__AppStartResponse:
					soap_out_PointerTosgs__AppStartResponse(soap, "id", pp->id, (struct sgs__AppStartResponse *const*)pp->ptr, "sgs:AppStartResponse");
					break;
				case SOAP_TYPE_PointerTosgs__GetNotificationsResponse:
					soap_out_PointerTosgs__GetNotificationsResponse(soap, "id", pp->id, (struct sgs__GetNotificationsResponse *const*)pp->ptr, "sgs:GetNotificationsResponse");
					break;
				case SOAP_TYPE_PointerTosgs__PauseResponse:
					soap_out_PointerTosgs__PauseResponse(soap, "id", pp->id, (struct sgs__PauseResponse *const*)pp->ptr, "sgs:PauseResponse");
					break;
				case SOAP_TYPE_PointerTosgs__AppRecordChkpointResponse:
					soap_out_PointerTosgs__AppRecordChkpointResponse(soap, "id", pp->id, (struct sgs__AppRecordChkpointResponse *const*)pp->ptr, "sgs:AppRecordChkpointResponse");
					break;
				case SOAP_TYPE_PointerTosgs__findServiceDataResponse:
					soap_out_PointerTosgs__findServiceDataResponse(soap, "id", pp->id, (struct sgs__findServiceDataResponse *const*)pp->ptr, "sgs:findServiceDataResponse");
					break;
				case SOAP_TYPE_PointerTosgs__PutControlResponse:
					soap_out_PointerTosgs__PutControlResponse(soap, "id", pp->id, (struct sgs__PutControlResponse *const*)pp->ptr, "sgs:PutControlResponse");
					break;
				case SOAP_TYPE_PointerTosgs__DetachResponse:
					soap_out_PointerTosgs__DetachResponse(soap, "id", pp->id, (struct sgs__DetachResponse *const*)pp->ptr, "sgs:DetachResponse");
					break;
				case SOAP_TYPE_PointerTosgs__StopResponse:
					soap_out_PointerTosgs__StopResponse(soap, "id", pp->id, (struct sgs__StopResponse *const*)pp->ptr, "sgs:StopResponse");
					break;
				case SOAP_TYPE_PointerTosgs__GetNthDataSourceResponse:
					soap_out_PointerTosgs__GetNthDataSourceResponse(soap, "id", pp->id, (struct sgs__GetNthDataSourceResponse *const*)pp->ptr, "sgs:GetNthDataSourceResponse");
					break;
				case SOAP_TYPE_PointerTosgs__AttachResponse:
					soap_out_PointerTosgs__AttachResponse(soap, "id", pp->id, (struct sgs__AttachResponse *const*)pp->ptr, "sgs:AttachResponse");
					break;
				case SOAP_TYPE_PointerTosgs__RestartResponse:
					soap_out_PointerTosgs__RestartResponse(soap, "id", pp->id, (struct sgs__RestartResponse *const*)pp->ptr, "sgs:RestartResponse");
					break;
				case SOAP_TYPE_PointerTosgs__GetStatusResponse:
					soap_out_PointerTosgs__GetStatusResponse(soap, "id", pp->id, (struct sgs__GetStatusResponse *const*)pp->ptr, "sgs:GetStatusResponse");
					break;
				case SOAP_TYPE_PointerTosgs__GetControlResponse:
					soap_out_PointerTosgs__GetControlResponse(soap, "id", pp->id, (struct sgs__GetControlResponse *const*)pp->ptr, "sgs:GetControlResponse");
					break;
				case SOAP_TYPE_PointerTosgs__AppStopResponse:
					soap_out_PointerTosgs__AppStopResponse(soap, "id", pp->id, (struct sgs__AppStopResponse *const*)pp->ptr, "sgs:AppStopResponse");
					break;
				case SOAP_TYPE_PointerTosgs__PutStatusResponse:
					soap_out_PointerTosgs__PutStatusResponse(soap, "id", pp->id, (struct sgs__PutStatusResponse *const*)pp->ptr, "sgs:PutStatusResponse");
					break;
				case SOAP_TYPE_PointerTosgs__AppDetachResponse:
					soap_out_PointerTosgs__AppDetachResponse(soap, "id", pp->id, (struct sgs__AppDetachResponse *const*)pp->ptr, "sgs:AppDetachResponse");
					break;
				case SOAP_TYPE_PointerTosgs__destroyResponse:
					soap_out_PointerTosgs__destroyResponse(soap, "id", pp->id, (struct sgs__destroyResponse *const*)pp->ptr, "sgs:destroyResponse");
					break;
				case SOAP_TYPE_PointerTosgs__setServiceDataResponse:
					soap_out_PointerTosgs__setServiceDataResponse(soap, "id", pp->id, (struct sgs__setServiceDataResponse *const*)pp->ptr, "sgs:setServiceDataResponse");
					break;
				case SOAP_TYPE_xsd__string:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsd:string");
					break;
				case SOAP_TYPE_string:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsd:string");
					break;
				}
		
	return SOAP_OK;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_getattachments(struct soap *soap)
{
	if (!(soap->mode & SOAP_ENC_DIME))
		return SOAP_OK;
	while (soap->dime_flags & SOAP_DIME_CF)
	{	if (soap_getdimehdr(soap))
			return soap->error;
		if (soap_move(soap, soap->dime_size))
			return soap->error = SOAP_EOF;
	}
	if (soap_move(soap, ((soap->dime_size+3)&-4)-soap_tell(soap)))
		return soap->error = SOAP_EOF;
	for (;;)
	{	if (soap_getdime(soap) || !soap->dime_id)
			break;
		switch (soap_lookup_type(soap, soap->dime_id))
		{
		case SOAP_TYPE_xsd__string:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsd__string, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_string:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_string, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		default:
			soap->error = SOAP_DIME_ERROR;
		}
		if (soap->error)
			break;
	}
	if (soap->error == SOAP_EOD)
		soap->error = SOAP_OK;
	return soap->error;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_putattachments(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (!(soap->mode & SOAP_ENC_DIME))
		return SOAP_OK;
	if (soap_send_raw(soap, "\0\0\0", -(int)soap->count&3))
		return soap->error;
	for (i = 0; i < SOAP_PTRHASH; i++)
		for (pp = soap->pht[i]; pp; pp = pp->next)
			if (pp->mark2 == 3)
				switch (pp->type)
				{
				}
		
	return SOAP_OK;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_byte(struct soap *soap, char *a)
{
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_byte(struct soap *soap, char const*a)
{
	soap_reference(soap, a, SOAP_TYPE_byte);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_byte(struct soap *soap, char *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_byte, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_byte(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_byte(soap, tag, i, a, type);
		}
	else
		soap_out_byte(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC1 char * SOAP_FMAC2 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * SOAP_FMAC2 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsd__int(struct soap *soap, int *a)
{
#ifdef SOAP_DEFAULT_xsd__int
	*a = SOAP_DEFAULT_xsd__int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsd__int(struct soap *soap, int const*a)
{
	soap_reference(soap, a, SOAP_TYPE_xsd__int);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsd__int(struct soap *soap, int *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsd__int, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsd__int(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsd__int(soap, tag, i, a, type);
		}
	else
		soap_out_xsd__int(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsd__int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_xsd__int);
}

SOAP_FMAC1 int * SOAP_FMAC2 soap_get_xsd__int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 int * SOAP_FMAC2 soap_in_xsd__int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_xsd__int);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_int(struct soap *soap, int *a)
{
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_int(struct soap *soap, int const*a)
{
	soap_reference(soap, a, SOAP_TYPE_int);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_int(struct soap *soap, int *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_int, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_int(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_int(soap, tag, i, a, type);
		}
	else
		soap_out_int(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC1 int * SOAP_FMAC2 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 int * SOAP_FMAC2 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_SOAP_ENV__Fault))
		soap_mark_SOAP_ENV__Fault(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	soap_embedded(soap, &a->faultcode, SOAP_TYPE_string);
	soap_mark_string(soap, &a->faultcode);
	soap_embedded(soap, &a->faultstring, SOAP_TYPE_string);
	soap_mark_string(soap, &a->faultstring);
	soap_embedded(soap, &a->faultactor, SOAP_TYPE_string);
	soap_mark_string(soap, &a->faultactor);
	soap_embedded(soap, &a->detail, SOAP_TYPE_string);
	soap_mark_string(soap, &a->detail);
	soap_embedded(soap, &a->SOAP_ENV__Code, SOAP_TYPE_PointerToSOAP_ENV__Code);
	soap_mark_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_embedded(soap, &a->SOAP_ENV__Reason, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Reason);
	soap_embedded(soap, &a->SOAP_ENV__Detail, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	soap_default_string(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	soap_default_string(soap, &a->detail);
	soap_default_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_default_string(soap, &a->SOAP_ENV__Reason);
	soap_default_string(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_SOAP_ENV__Fault, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_SOAP_ENV__Fault(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_SOAP_ENV__Fault(soap, tag, i, a, type);
		}
	else
		soap_out_SOAP_ENV__Fault(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out_string(soap, "faultcode", -1, &a->faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_string(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_string(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_string(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Fault(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode = 0;
					continue;
				}
			if (soap_flag_faultstring && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultstring", &a->faultstring, ""))
				{	soap_flag_faultstring = 0;
					continue;
				}
			if (soap_flag_faultactor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultactor", &a->faultactor, ""))
				{	soap_flag_faultactor = 0;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "detail", &a->detail, ""))
				{	soap_flag_detail = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0), SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault));
		if (soap->alloced)
			soap_default_SOAP_ENV__Fault(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_SOAP_ENV__Code))
		soap_mark_SOAP_ENV__Code(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	soap_embedded(soap, &a->SOAP_ENV__Value, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Value);
	soap_embedded(soap, &a->SOAP_ENV__Node, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Node);
	soap_embedded(soap, &a->SOAP_ENV__Role, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Role);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	soap_default_string(soap, &a->SOAP_ENV__Value);
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_SOAP_ENV__Code, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_SOAP_ENV__Code(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_SOAP_ENV__Code(soap, tag, i, a, type);
		}
	else
		soap_out_SOAP_ENV__Code(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out_string(soap, "SOAP-ENV:Value", -1, &a->SOAP_ENV__Value, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Code(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, ""))
				{	soap_flag_SOAP_ENV__Node = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, ""))
				{	soap_flag_SOAP_ENV__Role = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0), SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code));
		if (soap->alloced)
			soap_default_SOAP_ENV__Code(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_SOAP_ENV__Header))
		soap_mark_SOAP_ENV__Header(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	/* transient dummy skipped */
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	/* transient dummy skipped */
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_SOAP_ENV__Header, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_SOAP_ENV__Header(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_SOAP_ENV__Header(soap, tag, i, a, type);
		}
	else
		soap_out_SOAP_ENV__Header(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	/* transient dummy skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Header(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
		/* transient dummy skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0), SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header));
		if (soap->alloced)
			soap_default_SOAP_ENV__Header(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgt__addNode(struct soap *soap, struct rgt__addNode const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgt__addNode))
		soap_mark_rgt__addNode(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgt__addNode(struct soap *soap, const struct rgt__addNode *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
	soap_embedded(soap, &a->in1, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in1);
	soap_embedded(soap, &a->in2, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in2);
	soap_embedded(soap, &a->in3, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in3);
	soap_embedded(soap, &a->in4, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in4);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgt__addNode(struct soap *soap, struct rgt__addNode *a)
{
	soap_default_xsd__string(soap, &a->in0);
	soap_default_xsd__string(soap, &a->in1);
	soap_default_xsd__string(soap, &a->in2);
	soap_default_xsd__string(soap, &a->in3);
	soap_default_xsd__string(soap, &a->in4);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgt__addNode(struct soap *soap, struct rgt__addNode *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgt__addNode, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgt__addNode(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgt__addNode(soap, tag, i, a, type);
		}
	else
		soap_out_rgt__addNode(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgt__addNode(struct soap *soap, const char *tag, int id, const struct rgt__addNode *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__addNode), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_out_xsd__string(soap, "in1", -1, &a->in1, "xsd:string");
	soap_out_xsd__string(soap, "in2", -1, &a->in2, "xsd:string");
	soap_out_xsd__string(soap, "in3", -1, &a->in3, "xsd:string");
	soap_out_xsd__string(soap, "in4", -1, &a->in4, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__addNode * SOAP_FMAC2 soap_get_rgt__addNode(struct soap *soap, struct rgt__addNode *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__addNode(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__addNode * SOAP_FMAC2 soap_in_rgt__addNode(struct soap *soap, const char *tag, struct rgt__addNode *a, const char *type)
{
	short soap_flag_in0 = 1, soap_flag_in1 = 1, soap_flag_in2 = 1, soap_flag_in3 = 1, soap_flag_in4 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgt__addNode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__addNode, sizeof(struct rgt__addNode), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgt__addNode(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap_flag_in1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in1", &a->in1, "xsd:string"))
				{	soap_flag_in1 = 0;
					continue;
				}
			if (soap_flag_in2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in2", &a->in2, "xsd:string"))
				{	soap_flag_in2 = 0;
					continue;
				}
			if (soap_flag_in3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in3", &a->in3, "xsd:string"))
				{	soap_flag_in3 = 0;
					continue;
				}
			if (soap_flag_in4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in4", &a->in4, "xsd:string"))
				{	soap_flag_in4 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgt__addNode *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__addNode, sizeof(struct rgt__addNode), 0), SOAP_TYPE_rgt__addNode, sizeof(struct rgt__addNode));
		if (soap->alloced)
			soap_default_rgt__addNode(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgt__getParentNode(struct soap *soap, struct rgt__getParentNode const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgt__getParentNode))
		soap_mark_rgt__getParentNode(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgt__getParentNode(struct soap *soap, const struct rgt__getParentNode *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgt__getParentNode(struct soap *soap, struct rgt__getParentNode *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgt__getParentNode(struct soap *soap, struct rgt__getParentNode *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgt__getParentNode, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgt__getParentNode(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgt__getParentNode(soap, tag, i, a, type);
		}
	else
		soap_out_rgt__getParentNode(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgt__getParentNode(struct soap *soap, const char *tag, int id, const struct rgt__getParentNode *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__getParentNode), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__getParentNode * SOAP_FMAC2 soap_get_rgt__getParentNode(struct soap *soap, struct rgt__getParentNode *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__getParentNode(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__getParentNode * SOAP_FMAC2 soap_in_rgt__getParentNode(struct soap *soap, const char *tag, struct rgt__getParentNode *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgt__getParentNode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getParentNode, sizeof(struct rgt__getParentNode), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgt__getParentNode(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgt__getParentNode *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getParentNode, sizeof(struct rgt__getParentNode), 0), SOAP_TYPE_rgt__getParentNode, sizeof(struct rgt__getParentNode));
		if (soap->alloced)
			soap_default_rgt__getParentNode(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgt__getCheckPointData(struct soap *soap, struct rgt__getCheckPointData const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgt__getCheckPointData))
		soap_mark_rgt__getCheckPointData(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgt__getCheckPointData(struct soap *soap, const struct rgt__getCheckPointData *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgt__getCheckPointData(struct soap *soap, struct rgt__getCheckPointData *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgt__getCheckPointData(struct soap *soap, struct rgt__getCheckPointData *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgt__getCheckPointData, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgt__getCheckPointData(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgt__getCheckPointData(soap, tag, i, a, type);
		}
	else
		soap_out_rgt__getCheckPointData(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgt__getCheckPointData(struct soap *soap, const char *tag, int id, const struct rgt__getCheckPointData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__getCheckPointData), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__getCheckPointData * SOAP_FMAC2 soap_get_rgt__getCheckPointData(struct soap *soap, struct rgt__getCheckPointData *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__getCheckPointData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__getCheckPointData * SOAP_FMAC2 soap_in_rgt__getCheckPointData(struct soap *soap, const char *tag, struct rgt__getCheckPointData *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgt__getCheckPointData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getCheckPointData, sizeof(struct rgt__getCheckPointData), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgt__getCheckPointData(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgt__getCheckPointData *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getCheckPointData, sizeof(struct rgt__getCheckPointData), 0), SOAP_TYPE_rgt__getCheckPointData, sizeof(struct rgt__getCheckPointData));
		if (soap->alloced)
			soap_default_rgt__getCheckPointData(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgt__requestTerminationBefore(struct soap *soap, struct rgt__requestTerminationBefore const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgt__requestTerminationBefore))
		soap_mark_rgt__requestTerminationBefore(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgt__requestTerminationBefore(struct soap *soap, const struct rgt__requestTerminationBefore *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgt__requestTerminationBefore(struct soap *soap, struct rgt__requestTerminationBefore *a)
{
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgt__requestTerminationBefore(struct soap *soap, struct rgt__requestTerminationBefore *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgt__requestTerminationBefore, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgt__requestTerminationBefore(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgt__requestTerminationBefore(soap, tag, i, a, type);
		}
	else
		soap_out_rgt__requestTerminationBefore(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgt__requestTerminationBefore(struct soap *soap, const char *tag, int id, const struct rgt__requestTerminationBefore *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__requestTerminationBefore), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__requestTerminationBefore * SOAP_FMAC2 soap_get_rgt__requestTerminationBefore(struct soap *soap, struct rgt__requestTerminationBefore *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__requestTerminationBefore(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__requestTerminationBefore * SOAP_FMAC2 soap_in_rgt__requestTerminationBefore(struct soap *soap, const char *tag, struct rgt__requestTerminationBefore *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgt__requestTerminationBefore *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__requestTerminationBefore, sizeof(struct rgt__requestTerminationBefore), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgt__requestTerminationBefore(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgt__requestTerminationBefore *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__requestTerminationBefore, sizeof(struct rgt__requestTerminationBefore), 0), SOAP_TYPE_rgt__requestTerminationBefore, sizeof(struct rgt__requestTerminationBefore));
		if (soap->alloced)
			soap_default_rgt__requestTerminationBefore(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgt__getSteeringCommands(struct soap *soap, struct rgt__getSteeringCommands const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgt__getSteeringCommands))
		soap_mark_rgt__getSteeringCommands(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgt__getSteeringCommands(struct soap *soap, const struct rgt__getSteeringCommands *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgt__getSteeringCommands(struct soap *soap, struct rgt__getSteeringCommands *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgt__getSteeringCommands(struct soap *soap, struct rgt__getSteeringCommands *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgt__getSteeringCommands, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgt__getSteeringCommands(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgt__getSteeringCommands(soap, tag, i, a, type);
		}
	else
		soap_out_rgt__getSteeringCommands(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgt__getSteeringCommands(struct soap *soap, const char *tag, int id, const struct rgt__getSteeringCommands *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__getSteeringCommands), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__getSteeringCommands * SOAP_FMAC2 soap_get_rgt__getSteeringCommands(struct soap *soap, struct rgt__getSteeringCommands *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__getSteeringCommands(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__getSteeringCommands * SOAP_FMAC2 soap_in_rgt__getSteeringCommands(struct soap *soap, const char *tag, struct rgt__getSteeringCommands *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgt__getSteeringCommands *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getSteeringCommands, sizeof(struct rgt__getSteeringCommands), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgt__getSteeringCommands(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgt__getSteeringCommands *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getSteeringCommands, sizeof(struct rgt__getSteeringCommands), 0), SOAP_TYPE_rgt__getSteeringCommands, sizeof(struct rgt__getSteeringCommands));
		if (soap->alloced)
			soap_default_rgt__getSteeringCommands(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgt__destroy(struct soap *soap, struct rgt__destroy const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgt__destroy))
		soap_mark_rgt__destroy(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgt__destroy(struct soap *soap, const struct rgt__destroy *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgt__destroy(struct soap *soap, struct rgt__destroy *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgt__destroy(struct soap *soap, struct rgt__destroy *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgt__destroy, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgt__destroy(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgt__destroy(soap, tag, i, a, type);
		}
	else
		soap_out_rgt__destroy(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgt__destroy(struct soap *soap, const char *tag, int id, const struct rgt__destroy *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__destroy), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__destroy * SOAP_FMAC2 soap_get_rgt__destroy(struct soap *soap, struct rgt__destroy *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__destroy(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__destroy * SOAP_FMAC2 soap_in_rgt__destroy(struct soap *soap, const char *tag, struct rgt__destroy *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgt__destroy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__destroy, sizeof(struct rgt__destroy), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgt__destroy(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgt__destroy *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__destroy, sizeof(struct rgt__destroy), 0), SOAP_TYPE_rgt__destroy, sizeof(struct rgt__destroy));
		if (soap->alloced)
			soap_default_rgt__destroy(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgt__setCheckPointData(struct soap *soap, struct rgt__setCheckPointData const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgt__setCheckPointData))
		soap_mark_rgt__setCheckPointData(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgt__setCheckPointData(struct soap *soap, const struct rgt__setCheckPointData *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgt__setCheckPointData(struct soap *soap, struct rgt__setCheckPointData *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgt__setCheckPointData(struct soap *soap, struct rgt__setCheckPointData *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgt__setCheckPointData, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgt__setCheckPointData(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgt__setCheckPointData(soap, tag, i, a, type);
		}
	else
		soap_out_rgt__setCheckPointData(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgt__setCheckPointData(struct soap *soap, const char *tag, int id, const struct rgt__setCheckPointData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__setCheckPointData), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__setCheckPointData * SOAP_FMAC2 soap_get_rgt__setCheckPointData(struct soap *soap, struct rgt__setCheckPointData *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__setCheckPointData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__setCheckPointData * SOAP_FMAC2 soap_in_rgt__setCheckPointData(struct soap *soap, const char *tag, struct rgt__setCheckPointData *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgt__setCheckPointData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__setCheckPointData, sizeof(struct rgt__setCheckPointData), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgt__setCheckPointData(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgt__setCheckPointData *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__setCheckPointData, sizeof(struct rgt__setCheckPointData), 0), SOAP_TYPE_rgt__setCheckPointData, sizeof(struct rgt__setCheckPointData));
		if (soap->alloced)
			soap_default_rgt__setCheckPointData(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgt__findServiceData(struct soap *soap, struct rgt__findServiceData const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgt__findServiceData))
		soap_mark_rgt__findServiceData(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgt__findServiceData(struct soap *soap, const struct rgt__findServiceData *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgt__findServiceData(struct soap *soap, struct rgt__findServiceData *a)
{
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgt__findServiceData(struct soap *soap, struct rgt__findServiceData *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgt__findServiceData, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgt__findServiceData(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgt__findServiceData(soap, tag, i, a, type);
		}
	else
		soap_out_rgt__findServiceData(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgt__findServiceData(struct soap *soap, const char *tag, int id, const struct rgt__findServiceData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__findServiceData), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__findServiceData * SOAP_FMAC2 soap_get_rgt__findServiceData(struct soap *soap, struct rgt__findServiceData *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__findServiceData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__findServiceData * SOAP_FMAC2 soap_in_rgt__findServiceData(struct soap *soap, const char *tag, struct rgt__findServiceData *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgt__findServiceData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__findServiceData, sizeof(struct rgt__findServiceData), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgt__findServiceData(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgt__findServiceData *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__findServiceData, sizeof(struct rgt__findServiceData), 0), SOAP_TYPE_rgt__findServiceData, sizeof(struct rgt__findServiceData));
		if (soap->alloced)
			soap_default_rgt__findServiceData(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgt__getInputFile(struct soap *soap, struct rgt__getInputFile const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgt__getInputFile))
		soap_mark_rgt__getInputFile(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgt__getInputFile(struct soap *soap, const struct rgt__getInputFile *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgt__getInputFile(struct soap *soap, struct rgt__getInputFile *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgt__getInputFile(struct soap *soap, struct rgt__getInputFile *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgt__getInputFile, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgt__getInputFile(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgt__getInputFile(soap, tag, i, a, type);
		}
	else
		soap_out_rgt__getInputFile(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgt__getInputFile(struct soap *soap, const char *tag, int id, const struct rgt__getInputFile *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__getInputFile), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__getInputFile * SOAP_FMAC2 soap_get_rgt__getInputFile(struct soap *soap, struct rgt__getInputFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__getInputFile(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__getInputFile * SOAP_FMAC2 soap_in_rgt__getInputFile(struct soap *soap, const char *tag, struct rgt__getInputFile *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgt__getInputFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getInputFile, sizeof(struct rgt__getInputFile), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgt__getInputFile(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgt__getInputFile *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getInputFile, sizeof(struct rgt__getInputFile), 0), SOAP_TYPE_rgt__getInputFile, sizeof(struct rgt__getInputFile));
		if (soap->alloced)
			soap_default_rgt__getInputFile(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgt__getChildNodes(struct soap *soap, struct rgt__getChildNodes const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgt__getChildNodes))
		soap_mark_rgt__getChildNodes(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgt__getChildNodes(struct soap *soap, const struct rgt__getChildNodes *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgt__getChildNodes(struct soap *soap, struct rgt__getChildNodes *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgt__getChildNodes(struct soap *soap, struct rgt__getChildNodes *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgt__getChildNodes, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgt__getChildNodes(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgt__getChildNodes(soap, tag, i, a, type);
		}
	else
		soap_out_rgt__getChildNodes(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgt__getChildNodes(struct soap *soap, const char *tag, int id, const struct rgt__getChildNodes *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__getChildNodes), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__getChildNodes * SOAP_FMAC2 soap_get_rgt__getChildNodes(struct soap *soap, struct rgt__getChildNodes *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__getChildNodes(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__getChildNodes * SOAP_FMAC2 soap_in_rgt__getChildNodes(struct soap *soap, const char *tag, struct rgt__getChildNodes *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgt__getChildNodes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getChildNodes, sizeof(struct rgt__getChildNodes), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgt__getChildNodes(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgt__getChildNodes *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getChildNodes, sizeof(struct rgt__getChildNodes), 0), SOAP_TYPE_rgt__getChildNodes, sizeof(struct rgt__getChildNodes));
		if (soap->alloced)
			soap_default_rgt__getChildNodes(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgt__requestTerminationAfter(struct soap *soap, struct rgt__requestTerminationAfter const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgt__requestTerminationAfter))
		soap_mark_rgt__requestTerminationAfter(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgt__requestTerminationAfter(struct soap *soap, const struct rgt__requestTerminationAfter *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgt__requestTerminationAfter(struct soap *soap, struct rgt__requestTerminationAfter *a)
{
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgt__requestTerminationAfter(struct soap *soap, struct rgt__requestTerminationAfter *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgt__requestTerminationAfter, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgt__requestTerminationAfter(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgt__requestTerminationAfter(soap, tag, i, a, type);
		}
	else
		soap_out_rgt__requestTerminationAfter(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgt__requestTerminationAfter(struct soap *soap, const char *tag, int id, const struct rgt__requestTerminationAfter *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__requestTerminationAfter), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__requestTerminationAfter * SOAP_FMAC2 soap_get_rgt__requestTerminationAfter(struct soap *soap, struct rgt__requestTerminationAfter *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__requestTerminationAfter(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__requestTerminationAfter * SOAP_FMAC2 soap_in_rgt__requestTerminationAfter(struct soap *soap, const char *tag, struct rgt__requestTerminationAfter *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgt__requestTerminationAfter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__requestTerminationAfter, sizeof(struct rgt__requestTerminationAfter), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgt__requestTerminationAfter(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgt__requestTerminationAfter *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__requestTerminationAfter, sizeof(struct rgt__requestTerminationAfter), 0), SOAP_TYPE_rgt__requestTerminationAfter, sizeof(struct rgt__requestTerminationAfter));
		if (soap->alloced)
			soap_default_rgt__requestTerminationAfter(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgt__destroyResponse(struct soap *soap, struct rgt__destroyResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgt__destroyResponse))
		soap_mark_rgt__destroyResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgt__destroyResponse(struct soap *soap, const struct rgt__destroyResponse *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgt__destroyResponse(struct soap *soap, struct rgt__destroyResponse *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgt__destroyResponse(struct soap *soap, struct rgt__destroyResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgt__destroyResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgt__destroyResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgt__destroyResponse(soap, tag, i, a, type);
		}
	else
		soap_out_rgt__destroyResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgt__destroyResponse(struct soap *soap, const char *tag, int id, const struct rgt__destroyResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__destroyResponse), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__destroyResponse * SOAP_FMAC2 soap_get_rgt__destroyResponse(struct soap *soap, struct rgt__destroyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__destroyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__destroyResponse * SOAP_FMAC2 soap_in_rgt__destroyResponse(struct soap *soap, const char *tag, struct rgt__destroyResponse *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgt__destroyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__destroyResponse, sizeof(struct rgt__destroyResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgt__destroyResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgt__destroyResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__destroyResponse, sizeof(struct rgt__destroyResponse), 0), SOAP_TYPE_rgt__destroyResponse, sizeof(struct rgt__destroyResponse));
		if (soap->alloced)
			soap_default_rgt__destroyResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgt__getInputFileResponse(struct soap *soap, struct rgt__getInputFileResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgt__getInputFileResponse))
		soap_mark_rgt__getInputFileResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgt__getInputFileResponse(struct soap *soap, const struct rgt__getInputFileResponse *a)
{
	soap_embedded(soap, &a->_getInputFileReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_getInputFileReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgt__getInputFileResponse(struct soap *soap, struct rgt__getInputFileResponse *a)
{
	soap_default_xsd__string(soap, &a->_getInputFileReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgt__getInputFileResponse(struct soap *soap, struct rgt__getInputFileResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgt__getInputFileResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgt__getInputFileResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgt__getInputFileResponse(soap, tag, i, a, type);
		}
	else
		soap_out_rgt__getInputFileResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgt__getInputFileResponse(struct soap *soap, const char *tag, int id, const struct rgt__getInputFileResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__getInputFileResponse), type);
	soap_out_xsd__string(soap, "getInputFileReturn", -1, &a->_getInputFileReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__getInputFileResponse * SOAP_FMAC2 soap_get_rgt__getInputFileResponse(struct soap *soap, struct rgt__getInputFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__getInputFileResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__getInputFileResponse * SOAP_FMAC2 soap_in_rgt__getInputFileResponse(struct soap *soap, const char *tag, struct rgt__getInputFileResponse *a, const char *type)
{
	short soap_flag__getInputFileReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgt__getInputFileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getInputFileResponse, sizeof(struct rgt__getInputFileResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgt__getInputFileResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getInputFileReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_getInputFileReturn, "xsd:string"))
				{	soap_flag__getInputFileReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgt__getInputFileResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getInputFileResponse, sizeof(struct rgt__getInputFileResponse), 0), SOAP_TYPE_rgt__getInputFileResponse, sizeof(struct rgt__getInputFileResponse));
		if (soap->alloced)
			soap_default_rgt__getInputFileResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgt__getSteeringCommandsResponse(struct soap *soap, struct rgt__getSteeringCommandsResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgt__getSteeringCommandsResponse))
		soap_mark_rgt__getSteeringCommandsResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgt__getSteeringCommandsResponse(struct soap *soap, const struct rgt__getSteeringCommandsResponse *a)
{
	soap_embedded(soap, &a->_getSteeringCommandsReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_getSteeringCommandsReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgt__getSteeringCommandsResponse(struct soap *soap, struct rgt__getSteeringCommandsResponse *a)
{
	soap_default_xsd__string(soap, &a->_getSteeringCommandsReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgt__getSteeringCommandsResponse(struct soap *soap, struct rgt__getSteeringCommandsResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgt__getSteeringCommandsResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgt__getSteeringCommandsResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgt__getSteeringCommandsResponse(soap, tag, i, a, type);
		}
	else
		soap_out_rgt__getSteeringCommandsResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgt__getSteeringCommandsResponse(struct soap *soap, const char *tag, int id, const struct rgt__getSteeringCommandsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__getSteeringCommandsResponse), type);
	soap_out_xsd__string(soap, "getSteeringCommandsReturn", -1, &a->_getSteeringCommandsReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__getSteeringCommandsResponse * SOAP_FMAC2 soap_get_rgt__getSteeringCommandsResponse(struct soap *soap, struct rgt__getSteeringCommandsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__getSteeringCommandsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__getSteeringCommandsResponse * SOAP_FMAC2 soap_in_rgt__getSteeringCommandsResponse(struct soap *soap, const char *tag, struct rgt__getSteeringCommandsResponse *a, const char *type)
{
	short soap_flag__getSteeringCommandsReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgt__getSteeringCommandsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getSteeringCommandsResponse, sizeof(struct rgt__getSteeringCommandsResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgt__getSteeringCommandsResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getSteeringCommandsReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_getSteeringCommandsReturn, "xsd:string"))
				{	soap_flag__getSteeringCommandsReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgt__getSteeringCommandsResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getSteeringCommandsResponse, sizeof(struct rgt__getSteeringCommandsResponse), 0), SOAP_TYPE_rgt__getSteeringCommandsResponse, sizeof(struct rgt__getSteeringCommandsResponse));
		if (soap->alloced)
			soap_default_rgt__getSteeringCommandsResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgt__requestTerminationBeforeResponse(struct soap *soap, struct rgt__requestTerminationBeforeResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgt__requestTerminationBeforeResponse))
		soap_mark_rgt__requestTerminationBeforeResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgt__requestTerminationBeforeResponse(struct soap *soap, const struct rgt__requestTerminationBeforeResponse *a)
{
	soap_embedded(soap, &a->_requestTerminationBeforeReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_requestTerminationBeforeReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgt__requestTerminationBeforeResponse(struct soap *soap, struct rgt__requestTerminationBeforeResponse *a)
{
	soap_default_xsd__string(soap, &a->_requestTerminationBeforeReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgt__requestTerminationBeforeResponse(struct soap *soap, struct rgt__requestTerminationBeforeResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgt__requestTerminationBeforeResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgt__requestTerminationBeforeResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgt__requestTerminationBeforeResponse(soap, tag, i, a, type);
		}
	else
		soap_out_rgt__requestTerminationBeforeResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgt__requestTerminationBeforeResponse(struct soap *soap, const char *tag, int id, const struct rgt__requestTerminationBeforeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__requestTerminationBeforeResponse), type);
	soap_out_xsd__string(soap, "requestTerminationBeforeReturn", -1, &a->_requestTerminationBeforeReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__requestTerminationBeforeResponse * SOAP_FMAC2 soap_get_rgt__requestTerminationBeforeResponse(struct soap *soap, struct rgt__requestTerminationBeforeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__requestTerminationBeforeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__requestTerminationBeforeResponse * SOAP_FMAC2 soap_in_rgt__requestTerminationBeforeResponse(struct soap *soap, const char *tag, struct rgt__requestTerminationBeforeResponse *a, const char *type)
{
	short soap_flag__requestTerminationBeforeReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgt__requestTerminationBeforeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__requestTerminationBeforeResponse, sizeof(struct rgt__requestTerminationBeforeResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgt__requestTerminationBeforeResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__requestTerminationBeforeReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_requestTerminationBeforeReturn, "xsd:string"))
				{	soap_flag__requestTerminationBeforeReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgt__requestTerminationBeforeResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__requestTerminationBeforeResponse, sizeof(struct rgt__requestTerminationBeforeResponse), 0), SOAP_TYPE_rgt__requestTerminationBeforeResponse, sizeof(struct rgt__requestTerminationBeforeResponse));
		if (soap->alloced)
			soap_default_rgt__requestTerminationBeforeResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgt__getChildNodesResponse(struct soap *soap, struct rgt__getChildNodesResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgt__getChildNodesResponse))
		soap_mark_rgt__getChildNodesResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgt__getChildNodesResponse(struct soap *soap, const struct rgt__getChildNodesResponse *a)
{
	soap_embedded(soap, &a->_getChildNodesReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_getChildNodesReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgt__getChildNodesResponse(struct soap *soap, struct rgt__getChildNodesResponse *a)
{
	soap_default_xsd__string(soap, &a->_getChildNodesReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgt__getChildNodesResponse(struct soap *soap, struct rgt__getChildNodesResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgt__getChildNodesResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgt__getChildNodesResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgt__getChildNodesResponse(soap, tag, i, a, type);
		}
	else
		soap_out_rgt__getChildNodesResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgt__getChildNodesResponse(struct soap *soap, const char *tag, int id, const struct rgt__getChildNodesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__getChildNodesResponse), type);
	soap_out_xsd__string(soap, "getChildNodesReturn", -1, &a->_getChildNodesReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__getChildNodesResponse * SOAP_FMAC2 soap_get_rgt__getChildNodesResponse(struct soap *soap, struct rgt__getChildNodesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__getChildNodesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__getChildNodesResponse * SOAP_FMAC2 soap_in_rgt__getChildNodesResponse(struct soap *soap, const char *tag, struct rgt__getChildNodesResponse *a, const char *type)
{
	short soap_flag__getChildNodesReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgt__getChildNodesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getChildNodesResponse, sizeof(struct rgt__getChildNodesResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgt__getChildNodesResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getChildNodesReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_getChildNodesReturn, "xsd:string"))
				{	soap_flag__getChildNodesReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgt__getChildNodesResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getChildNodesResponse, sizeof(struct rgt__getChildNodesResponse), 0), SOAP_TYPE_rgt__getChildNodesResponse, sizeof(struct rgt__getChildNodesResponse));
		if (soap->alloced)
			soap_default_rgt__getChildNodesResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgt__setCheckPointDataResponse(struct soap *soap, struct rgt__setCheckPointDataResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgt__setCheckPointDataResponse))
		soap_mark_rgt__setCheckPointDataResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgt__setCheckPointDataResponse(struct soap *soap, const struct rgt__setCheckPointDataResponse *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgt__setCheckPointDataResponse(struct soap *soap, struct rgt__setCheckPointDataResponse *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgt__setCheckPointDataResponse(struct soap *soap, struct rgt__setCheckPointDataResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgt__setCheckPointDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgt__setCheckPointDataResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgt__setCheckPointDataResponse(soap, tag, i, a, type);
		}
	else
		soap_out_rgt__setCheckPointDataResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgt__setCheckPointDataResponse(struct soap *soap, const char *tag, int id, const struct rgt__setCheckPointDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__setCheckPointDataResponse), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__setCheckPointDataResponse * SOAP_FMAC2 soap_get_rgt__setCheckPointDataResponse(struct soap *soap, struct rgt__setCheckPointDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__setCheckPointDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__setCheckPointDataResponse * SOAP_FMAC2 soap_in_rgt__setCheckPointDataResponse(struct soap *soap, const char *tag, struct rgt__setCheckPointDataResponse *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgt__setCheckPointDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__setCheckPointDataResponse, sizeof(struct rgt__setCheckPointDataResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgt__setCheckPointDataResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgt__setCheckPointDataResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__setCheckPointDataResponse, sizeof(struct rgt__setCheckPointDataResponse), 0), SOAP_TYPE_rgt__setCheckPointDataResponse, sizeof(struct rgt__setCheckPointDataResponse));
		if (soap->alloced)
			soap_default_rgt__setCheckPointDataResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgt__findServiceDataResponse(struct soap *soap, struct rgt__findServiceDataResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgt__findServiceDataResponse))
		soap_mark_rgt__findServiceDataResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgt__findServiceDataResponse(struct soap *soap, const struct rgt__findServiceDataResponse *a)
{
	soap_embedded(soap, &a->_findServiceDataReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_findServiceDataReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgt__findServiceDataResponse(struct soap *soap, struct rgt__findServiceDataResponse *a)
{
	soap_default_xsd__string(soap, &a->_findServiceDataReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgt__findServiceDataResponse(struct soap *soap, struct rgt__findServiceDataResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgt__findServiceDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgt__findServiceDataResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgt__findServiceDataResponse(soap, tag, i, a, type);
		}
	else
		soap_out_rgt__findServiceDataResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgt__findServiceDataResponse(struct soap *soap, const char *tag, int id, const struct rgt__findServiceDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__findServiceDataResponse), type);
	soap_out_xsd__string(soap, "findServiceDataReturn", -1, &a->_findServiceDataReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__findServiceDataResponse * SOAP_FMAC2 soap_get_rgt__findServiceDataResponse(struct soap *soap, struct rgt__findServiceDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__findServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__findServiceDataResponse * SOAP_FMAC2 soap_in_rgt__findServiceDataResponse(struct soap *soap, const char *tag, struct rgt__findServiceDataResponse *a, const char *type)
{
	short soap_flag__findServiceDataReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgt__findServiceDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__findServiceDataResponse, sizeof(struct rgt__findServiceDataResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgt__findServiceDataResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__findServiceDataReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_findServiceDataReturn, "xsd:string"))
				{	soap_flag__findServiceDataReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgt__findServiceDataResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__findServiceDataResponse, sizeof(struct rgt__findServiceDataResponse), 0), SOAP_TYPE_rgt__findServiceDataResponse, sizeof(struct rgt__findServiceDataResponse));
		if (soap->alloced)
			soap_default_rgt__findServiceDataResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgt__getCheckPointDataResponse(struct soap *soap, struct rgt__getCheckPointDataResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgt__getCheckPointDataResponse))
		soap_mark_rgt__getCheckPointDataResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgt__getCheckPointDataResponse(struct soap *soap, const struct rgt__getCheckPointDataResponse *a)
{
	soap_embedded(soap, &a->_getCheckPointDataReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_getCheckPointDataReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgt__getCheckPointDataResponse(struct soap *soap, struct rgt__getCheckPointDataResponse *a)
{
	soap_default_xsd__string(soap, &a->_getCheckPointDataReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgt__getCheckPointDataResponse(struct soap *soap, struct rgt__getCheckPointDataResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgt__getCheckPointDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgt__getCheckPointDataResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgt__getCheckPointDataResponse(soap, tag, i, a, type);
		}
	else
		soap_out_rgt__getCheckPointDataResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgt__getCheckPointDataResponse(struct soap *soap, const char *tag, int id, const struct rgt__getCheckPointDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__getCheckPointDataResponse), type);
	soap_out_xsd__string(soap, "getCheckPointDataReturn", -1, &a->_getCheckPointDataReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__getCheckPointDataResponse * SOAP_FMAC2 soap_get_rgt__getCheckPointDataResponse(struct soap *soap, struct rgt__getCheckPointDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__getCheckPointDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__getCheckPointDataResponse * SOAP_FMAC2 soap_in_rgt__getCheckPointDataResponse(struct soap *soap, const char *tag, struct rgt__getCheckPointDataResponse *a, const char *type)
{
	short soap_flag__getCheckPointDataReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgt__getCheckPointDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getCheckPointDataResponse, sizeof(struct rgt__getCheckPointDataResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgt__getCheckPointDataResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getCheckPointDataReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_getCheckPointDataReturn, "xsd:string"))
				{	soap_flag__getCheckPointDataReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgt__getCheckPointDataResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getCheckPointDataResponse, sizeof(struct rgt__getCheckPointDataResponse), 0), SOAP_TYPE_rgt__getCheckPointDataResponse, sizeof(struct rgt__getCheckPointDataResponse));
		if (soap->alloced)
			soap_default_rgt__getCheckPointDataResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgt__addNodeResponse(struct soap *soap, struct rgt__addNodeResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgt__addNodeResponse))
		soap_mark_rgt__addNodeResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgt__addNodeResponse(struct soap *soap, const struct rgt__addNodeResponse *a)
{
	soap_embedded(soap, &a->_addNodeReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_addNodeReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgt__addNodeResponse(struct soap *soap, struct rgt__addNodeResponse *a)
{
	soap_default_xsd__string(soap, &a->_addNodeReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgt__addNodeResponse(struct soap *soap, struct rgt__addNodeResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgt__addNodeResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgt__addNodeResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgt__addNodeResponse(soap, tag, i, a, type);
		}
	else
		soap_out_rgt__addNodeResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgt__addNodeResponse(struct soap *soap, const char *tag, int id, const struct rgt__addNodeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__addNodeResponse), type);
	soap_out_xsd__string(soap, "addNodeReturn", -1, &a->_addNodeReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__addNodeResponse * SOAP_FMAC2 soap_get_rgt__addNodeResponse(struct soap *soap, struct rgt__addNodeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__addNodeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__addNodeResponse * SOAP_FMAC2 soap_in_rgt__addNodeResponse(struct soap *soap, const char *tag, struct rgt__addNodeResponse *a, const char *type)
{
	short soap_flag__addNodeReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgt__addNodeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__addNodeResponse, sizeof(struct rgt__addNodeResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgt__addNodeResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__addNodeReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_addNodeReturn, "xsd:string"))
				{	soap_flag__addNodeReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgt__addNodeResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__addNodeResponse, sizeof(struct rgt__addNodeResponse), 0), SOAP_TYPE_rgt__addNodeResponse, sizeof(struct rgt__addNodeResponse));
		if (soap->alloced)
			soap_default_rgt__addNodeResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgt__requestTerminationAfterResponse(struct soap *soap, struct rgt__requestTerminationAfterResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgt__requestTerminationAfterResponse))
		soap_mark_rgt__requestTerminationAfterResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgt__requestTerminationAfterResponse(struct soap *soap, const struct rgt__requestTerminationAfterResponse *a)
{
	soap_embedded(soap, &a->_requestTerminationAfterReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_requestTerminationAfterReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgt__requestTerminationAfterResponse(struct soap *soap, struct rgt__requestTerminationAfterResponse *a)
{
	soap_default_xsd__string(soap, &a->_requestTerminationAfterReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgt__requestTerminationAfterResponse(struct soap *soap, struct rgt__requestTerminationAfterResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgt__requestTerminationAfterResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgt__requestTerminationAfterResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgt__requestTerminationAfterResponse(soap, tag, i, a, type);
		}
	else
		soap_out_rgt__requestTerminationAfterResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgt__requestTerminationAfterResponse(struct soap *soap, const char *tag, int id, const struct rgt__requestTerminationAfterResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__requestTerminationAfterResponse), type);
	soap_out_xsd__string(soap, "requestTerminationAfterReturn", -1, &a->_requestTerminationAfterReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__requestTerminationAfterResponse * SOAP_FMAC2 soap_get_rgt__requestTerminationAfterResponse(struct soap *soap, struct rgt__requestTerminationAfterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__requestTerminationAfterResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__requestTerminationAfterResponse * SOAP_FMAC2 soap_in_rgt__requestTerminationAfterResponse(struct soap *soap, const char *tag, struct rgt__requestTerminationAfterResponse *a, const char *type)
{
	short soap_flag__requestTerminationAfterReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgt__requestTerminationAfterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__requestTerminationAfterResponse, sizeof(struct rgt__requestTerminationAfterResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgt__requestTerminationAfterResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__requestTerminationAfterReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_requestTerminationAfterReturn, "xsd:string"))
				{	soap_flag__requestTerminationAfterReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgt__requestTerminationAfterResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__requestTerminationAfterResponse, sizeof(struct rgt__requestTerminationAfterResponse), 0), SOAP_TYPE_rgt__requestTerminationAfterResponse, sizeof(struct rgt__requestTerminationAfterResponse));
		if (soap->alloced)
			soap_default_rgt__requestTerminationAfterResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgt__getParentNodeResponse(struct soap *soap, struct rgt__getParentNodeResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgt__getParentNodeResponse))
		soap_mark_rgt__getParentNodeResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgt__getParentNodeResponse(struct soap *soap, const struct rgt__getParentNodeResponse *a)
{
	soap_embedded(soap, &a->_getParentNodeReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_getParentNodeReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgt__getParentNodeResponse(struct soap *soap, struct rgt__getParentNodeResponse *a)
{
	soap_default_xsd__string(soap, &a->_getParentNodeReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgt__getParentNodeResponse(struct soap *soap, struct rgt__getParentNodeResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgt__getParentNodeResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgt__getParentNodeResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgt__getParentNodeResponse(soap, tag, i, a, type);
		}
	else
		soap_out_rgt__getParentNodeResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgt__getParentNodeResponse(struct soap *soap, const char *tag, int id, const struct rgt__getParentNodeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgt__getParentNodeResponse), type);
	soap_out_xsd__string(soap, "getParentNodeReturn", -1, &a->_getParentNodeReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__getParentNodeResponse * SOAP_FMAC2 soap_get_rgt__getParentNodeResponse(struct soap *soap, struct rgt__getParentNodeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgt__getParentNodeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__getParentNodeResponse * SOAP_FMAC2 soap_in_rgt__getParentNodeResponse(struct soap *soap, const char *tag, struct rgt__getParentNodeResponse *a, const char *type)
{
	short soap_flag__getParentNodeReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgt__getParentNodeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getParentNodeResponse, sizeof(struct rgt__getParentNodeResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgt__getParentNodeResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getParentNodeReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_getParentNodeReturn, "xsd:string"))
				{	soap_flag__getParentNodeReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgt__getParentNodeResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgt__getParentNodeResponse, sizeof(struct rgt__getParentNodeResponse), 0), SOAP_TYPE_rgt__getParentNodeResponse, sizeof(struct rgt__getParentNodeResponse));
		if (soap->alloced)
			soap_default_rgt__getParentNodeResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgtf__requestTerminationAfter(struct soap *soap, struct rgtf__requestTerminationAfter const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgtf__requestTerminationAfter))
		soap_mark_rgtf__requestTerminationAfter(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgtf__requestTerminationAfter(struct soap *soap, const struct rgtf__requestTerminationAfter *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgtf__requestTerminationAfter(struct soap *soap, struct rgtf__requestTerminationAfter *a)
{
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgtf__requestTerminationAfter(struct soap *soap, struct rgtf__requestTerminationAfter *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgtf__requestTerminationAfter, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgtf__requestTerminationAfter(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgtf__requestTerminationAfter(soap, tag, i, a, type);
		}
	else
		soap_out_rgtf__requestTerminationAfter(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgtf__requestTerminationAfter(struct soap *soap, const char *tag, int id, const struct rgtf__requestTerminationAfter *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__requestTerminationAfter), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgtf__requestTerminationAfter * SOAP_FMAC2 soap_get_rgtf__requestTerminationAfter(struct soap *soap, struct rgtf__requestTerminationAfter *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__requestTerminationAfter(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgtf__requestTerminationAfter * SOAP_FMAC2 soap_in_rgtf__requestTerminationAfter(struct soap *soap, const char *tag, struct rgtf__requestTerminationAfter *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgtf__requestTerminationAfter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__requestTerminationAfter, sizeof(struct rgtf__requestTerminationAfter), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgtf__requestTerminationAfter(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgtf__requestTerminationAfter *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__requestTerminationAfter, sizeof(struct rgtf__requestTerminationAfter), 0), SOAP_TYPE_rgtf__requestTerminationAfter, sizeof(struct rgtf__requestTerminationAfter));
		if (soap->alloced)
			soap_default_rgtf__requestTerminationAfter(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgtf__requestTerminationBefore(struct soap *soap, struct rgtf__requestTerminationBefore const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgtf__requestTerminationBefore))
		soap_mark_rgtf__requestTerminationBefore(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgtf__requestTerminationBefore(struct soap *soap, const struct rgtf__requestTerminationBefore *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgtf__requestTerminationBefore(struct soap *soap, struct rgtf__requestTerminationBefore *a)
{
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgtf__requestTerminationBefore(struct soap *soap, struct rgtf__requestTerminationBefore *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgtf__requestTerminationBefore, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgtf__requestTerminationBefore(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgtf__requestTerminationBefore(soap, tag, i, a, type);
		}
	else
		soap_out_rgtf__requestTerminationBefore(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgtf__requestTerminationBefore(struct soap *soap, const char *tag, int id, const struct rgtf__requestTerminationBefore *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__requestTerminationBefore), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgtf__requestTerminationBefore * SOAP_FMAC2 soap_get_rgtf__requestTerminationBefore(struct soap *soap, struct rgtf__requestTerminationBefore *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__requestTerminationBefore(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgtf__requestTerminationBefore * SOAP_FMAC2 soap_in_rgtf__requestTerminationBefore(struct soap *soap, const char *tag, struct rgtf__requestTerminationBefore *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgtf__requestTerminationBefore *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__requestTerminationBefore, sizeof(struct rgtf__requestTerminationBefore), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgtf__requestTerminationBefore(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgtf__requestTerminationBefore *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__requestTerminationBefore, sizeof(struct rgtf__requestTerminationBefore), 0), SOAP_TYPE_rgtf__requestTerminationBefore, sizeof(struct rgtf__requestTerminationBefore));
		if (soap->alloced)
			soap_default_rgtf__requestTerminationBefore(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgtf__getActiveTrees(struct soap *soap, struct rgtf__getActiveTrees const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgtf__getActiveTrees))
		soap_mark_rgtf__getActiveTrees(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgtf__getActiveTrees(struct soap *soap, const struct rgtf__getActiveTrees *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgtf__getActiveTrees(struct soap *soap, struct rgtf__getActiveTrees *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgtf__getActiveTrees(struct soap *soap, struct rgtf__getActiveTrees *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgtf__getActiveTrees, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgtf__getActiveTrees(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgtf__getActiveTrees(soap, tag, i, a, type);
		}
	else
		soap_out_rgtf__getActiveTrees(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgtf__getActiveTrees(struct soap *soap, const char *tag, int id, const struct rgtf__getActiveTrees *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__getActiveTrees), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgtf__getActiveTrees * SOAP_FMAC2 soap_get_rgtf__getActiveTrees(struct soap *soap, struct rgtf__getActiveTrees *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__getActiveTrees(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgtf__getActiveTrees * SOAP_FMAC2 soap_in_rgtf__getActiveTrees(struct soap *soap, const char *tag, struct rgtf__getActiveTrees *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgtf__getActiveTrees *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__getActiveTrees, sizeof(struct rgtf__getActiveTrees), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgtf__getActiveTrees(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgtf__getActiveTrees *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__getActiveTrees, sizeof(struct rgtf__getActiveTrees), 0), SOAP_TYPE_rgtf__getActiveTrees, sizeof(struct rgtf__getActiveTrees));
		if (soap->alloced)
			soap_default_rgtf__getActiveTrees(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgtf__findServiceData(struct soap *soap, struct rgtf__findServiceData const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgtf__findServiceData))
		soap_mark_rgtf__findServiceData(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgtf__findServiceData(struct soap *soap, const struct rgtf__findServiceData *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgtf__findServiceData(struct soap *soap, struct rgtf__findServiceData *a)
{
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgtf__findServiceData(struct soap *soap, struct rgtf__findServiceData *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgtf__findServiceData, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgtf__findServiceData(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgtf__findServiceData(soap, tag, i, a, type);
		}
	else
		soap_out_rgtf__findServiceData(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgtf__findServiceData(struct soap *soap, const char *tag, int id, const struct rgtf__findServiceData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__findServiceData), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgtf__findServiceData * SOAP_FMAC2 soap_get_rgtf__findServiceData(struct soap *soap, struct rgtf__findServiceData *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__findServiceData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgtf__findServiceData * SOAP_FMAC2 soap_in_rgtf__findServiceData(struct soap *soap, const char *tag, struct rgtf__findServiceData *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgtf__findServiceData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__findServiceData, sizeof(struct rgtf__findServiceData), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgtf__findServiceData(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgtf__findServiceData *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__findServiceData, sizeof(struct rgtf__findServiceData), 0), SOAP_TYPE_rgtf__findServiceData, sizeof(struct rgtf__findServiceData));
		if (soap->alloced)
			soap_default_rgtf__findServiceData(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgtf__destroy(struct soap *soap, struct rgtf__destroy const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgtf__destroy))
		soap_mark_rgtf__destroy(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgtf__destroy(struct soap *soap, const struct rgtf__destroy *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgtf__destroy(struct soap *soap, struct rgtf__destroy *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgtf__destroy(struct soap *soap, struct rgtf__destroy *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgtf__destroy, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgtf__destroy(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgtf__destroy(soap, tag, i, a, type);
		}
	else
		soap_out_rgtf__destroy(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgtf__destroy(struct soap *soap, const char *tag, int id, const struct rgtf__destroy *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__destroy), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgtf__destroy * SOAP_FMAC2 soap_get_rgtf__destroy(struct soap *soap, struct rgtf__destroy *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__destroy(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgtf__destroy * SOAP_FMAC2 soap_in_rgtf__destroy(struct soap *soap, const char *tag, struct rgtf__destroy *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgtf__destroy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__destroy, sizeof(struct rgtf__destroy), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgtf__destroy(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgtf__destroy *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__destroy, sizeof(struct rgtf__destroy), 0), SOAP_TYPE_rgtf__destroy, sizeof(struct rgtf__destroy));
		if (soap->alloced)
			soap_default_rgtf__destroy(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgtf__findByHandle(struct soap *soap, struct rgtf__findByHandle const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgtf__findByHandle))
		soap_mark_rgtf__findByHandle(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgtf__findByHandle(struct soap *soap, const struct rgtf__findByHandle *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
	soap_embedded(soap, &a->in1, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgtf__findByHandle(struct soap *soap, struct rgtf__findByHandle *a)
{
	soap_default_xsd__string(soap, &a->in0);
	soap_default_xsd__string(soap, &a->in1);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgtf__findByHandle(struct soap *soap, struct rgtf__findByHandle *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgtf__findByHandle, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgtf__findByHandle(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgtf__findByHandle(soap, tag, i, a, type);
		}
	else
		soap_out_rgtf__findByHandle(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgtf__findByHandle(struct soap *soap, const char *tag, int id, const struct rgtf__findByHandle *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__findByHandle), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_out_xsd__string(soap, "in1", -1, &a->in1, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgtf__findByHandle * SOAP_FMAC2 soap_get_rgtf__findByHandle(struct soap *soap, struct rgtf__findByHandle *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__findByHandle(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgtf__findByHandle * SOAP_FMAC2 soap_in_rgtf__findByHandle(struct soap *soap, const char *tag, struct rgtf__findByHandle *a, const char *type)
{
	short soap_flag_in0 = 1, soap_flag_in1 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgtf__findByHandle *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__findByHandle, sizeof(struct rgtf__findByHandle), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgtf__findByHandle(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap_flag_in1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in1", &a->in1, "xsd:string"))
				{	soap_flag_in1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgtf__findByHandle *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__findByHandle, sizeof(struct rgtf__findByHandle), 0), SOAP_TYPE_rgtf__findByHandle, sizeof(struct rgtf__findByHandle));
		if (soap->alloced)
			soap_default_rgtf__findByHandle(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgtf__createNewTree(struct soap *soap, struct rgtf__createNewTree const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgtf__createNewTree))
		soap_mark_rgtf__createNewTree(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgtf__createNewTree(struct soap *soap, const struct rgtf__createNewTree *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
	soap_embedded(soap, &a->in1, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in1);
	soap_embedded(soap, &a->in2, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in2);
	soap_embedded(soap, &a->in3, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in3);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgtf__createNewTree(struct soap *soap, struct rgtf__createNewTree *a)
{
	soap_default_xsd__string(soap, &a->in0);
	soap_default_xsd__string(soap, &a->in1);
	soap_default_xsd__string(soap, &a->in2);
	soap_default_xsd__string(soap, &a->in3);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgtf__createNewTree(struct soap *soap, struct rgtf__createNewTree *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgtf__createNewTree, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgtf__createNewTree(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgtf__createNewTree(soap, tag, i, a, type);
		}
	else
		soap_out_rgtf__createNewTree(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgtf__createNewTree(struct soap *soap, const char *tag, int id, const struct rgtf__createNewTree *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__createNewTree), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_out_xsd__string(soap, "in1", -1, &a->in1, "xsd:string");
	soap_out_xsd__string(soap, "in2", -1, &a->in2, "xsd:string");
	soap_out_xsd__string(soap, "in3", -1, &a->in3, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgtf__createNewTree * SOAP_FMAC2 soap_get_rgtf__createNewTree(struct soap *soap, struct rgtf__createNewTree *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__createNewTree(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgtf__createNewTree * SOAP_FMAC2 soap_in_rgtf__createNewTree(struct soap *soap, const char *tag, struct rgtf__createNewTree *a, const char *type)
{
	short soap_flag_in0 = 1, soap_flag_in1 = 1, soap_flag_in2 = 1, soap_flag_in3 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgtf__createNewTree *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__createNewTree, sizeof(struct rgtf__createNewTree), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgtf__createNewTree(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap_flag_in1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in1", &a->in1, "xsd:string"))
				{	soap_flag_in1 = 0;
					continue;
				}
			if (soap_flag_in2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in2", &a->in2, "xsd:string"))
				{	soap_flag_in2 = 0;
					continue;
				}
			if (soap_flag_in3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in3", &a->in3, "xsd:string"))
				{	soap_flag_in3 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgtf__createNewTree *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__createNewTree, sizeof(struct rgtf__createNewTree), 0), SOAP_TYPE_rgtf__createNewTree, sizeof(struct rgtf__createNewTree));
		if (soap->alloced)
			soap_default_rgtf__createNewTree(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgtf__destroyResponse(struct soap *soap, struct rgtf__destroyResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgtf__destroyResponse))
		soap_mark_rgtf__destroyResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgtf__destroyResponse(struct soap *soap, const struct rgtf__destroyResponse *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgtf__destroyResponse(struct soap *soap, struct rgtf__destroyResponse *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgtf__destroyResponse(struct soap *soap, struct rgtf__destroyResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgtf__destroyResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgtf__destroyResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgtf__destroyResponse(soap, tag, i, a, type);
		}
	else
		soap_out_rgtf__destroyResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgtf__destroyResponse(struct soap *soap, const char *tag, int id, const struct rgtf__destroyResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__destroyResponse), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgtf__destroyResponse * SOAP_FMAC2 soap_get_rgtf__destroyResponse(struct soap *soap, struct rgtf__destroyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__destroyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgtf__destroyResponse * SOAP_FMAC2 soap_in_rgtf__destroyResponse(struct soap *soap, const char *tag, struct rgtf__destroyResponse *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgtf__destroyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__destroyResponse, sizeof(struct rgtf__destroyResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgtf__destroyResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgtf__destroyResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__destroyResponse, sizeof(struct rgtf__destroyResponse), 0), SOAP_TYPE_rgtf__destroyResponse, sizeof(struct rgtf__destroyResponse));
		if (soap->alloced)
			soap_default_rgtf__destroyResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgtf__requestTerminationAfterResponse(struct soap *soap, struct rgtf__requestTerminationAfterResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgtf__requestTerminationAfterResponse))
		soap_mark_rgtf__requestTerminationAfterResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgtf__requestTerminationAfterResponse(struct soap *soap, const struct rgtf__requestTerminationAfterResponse *a)
{
	soap_embedded(soap, &a->_requestTerminationAfterReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_requestTerminationAfterReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgtf__requestTerminationAfterResponse(struct soap *soap, struct rgtf__requestTerminationAfterResponse *a)
{
	soap_default_xsd__string(soap, &a->_requestTerminationAfterReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgtf__requestTerminationAfterResponse(struct soap *soap, struct rgtf__requestTerminationAfterResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgtf__requestTerminationAfterResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgtf__requestTerminationAfterResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgtf__requestTerminationAfterResponse(soap, tag, i, a, type);
		}
	else
		soap_out_rgtf__requestTerminationAfterResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgtf__requestTerminationAfterResponse(struct soap *soap, const char *tag, int id, const struct rgtf__requestTerminationAfterResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__requestTerminationAfterResponse), type);
	soap_out_xsd__string(soap, "requestTerminationAfterReturn", -1, &a->_requestTerminationAfterReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgtf__requestTerminationAfterResponse * SOAP_FMAC2 soap_get_rgtf__requestTerminationAfterResponse(struct soap *soap, struct rgtf__requestTerminationAfterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__requestTerminationAfterResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgtf__requestTerminationAfterResponse * SOAP_FMAC2 soap_in_rgtf__requestTerminationAfterResponse(struct soap *soap, const char *tag, struct rgtf__requestTerminationAfterResponse *a, const char *type)
{
	short soap_flag__requestTerminationAfterReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgtf__requestTerminationAfterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__requestTerminationAfterResponse, sizeof(struct rgtf__requestTerminationAfterResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgtf__requestTerminationAfterResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__requestTerminationAfterReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_requestTerminationAfterReturn, "xsd:string"))
				{	soap_flag__requestTerminationAfterReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgtf__requestTerminationAfterResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__requestTerminationAfterResponse, sizeof(struct rgtf__requestTerminationAfterResponse), 0), SOAP_TYPE_rgtf__requestTerminationAfterResponse, sizeof(struct rgtf__requestTerminationAfterResponse));
		if (soap->alloced)
			soap_default_rgtf__requestTerminationAfterResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgtf__createNewTreeResponse(struct soap *soap, struct rgtf__createNewTreeResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgtf__createNewTreeResponse))
		soap_mark_rgtf__createNewTreeResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgtf__createNewTreeResponse(struct soap *soap, const struct rgtf__createNewTreeResponse *a)
{
	soap_embedded(soap, &a->_createNewTreeReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_createNewTreeReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgtf__createNewTreeResponse(struct soap *soap, struct rgtf__createNewTreeResponse *a)
{
	soap_default_xsd__string(soap, &a->_createNewTreeReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgtf__createNewTreeResponse(struct soap *soap, struct rgtf__createNewTreeResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgtf__createNewTreeResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgtf__createNewTreeResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgtf__createNewTreeResponse(soap, tag, i, a, type);
		}
	else
		soap_out_rgtf__createNewTreeResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgtf__createNewTreeResponse(struct soap *soap, const char *tag, int id, const struct rgtf__createNewTreeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__createNewTreeResponse), type);
	soap_out_xsd__string(soap, "createNewTreeReturn", -1, &a->_createNewTreeReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgtf__createNewTreeResponse * SOAP_FMAC2 soap_get_rgtf__createNewTreeResponse(struct soap *soap, struct rgtf__createNewTreeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__createNewTreeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgtf__createNewTreeResponse * SOAP_FMAC2 soap_in_rgtf__createNewTreeResponse(struct soap *soap, const char *tag, struct rgtf__createNewTreeResponse *a, const char *type)
{
	short soap_flag__createNewTreeReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgtf__createNewTreeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__createNewTreeResponse, sizeof(struct rgtf__createNewTreeResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgtf__createNewTreeResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__createNewTreeReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_createNewTreeReturn, "xsd:string"))
				{	soap_flag__createNewTreeReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgtf__createNewTreeResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__createNewTreeResponse, sizeof(struct rgtf__createNewTreeResponse), 0), SOAP_TYPE_rgtf__createNewTreeResponse, sizeof(struct rgtf__createNewTreeResponse));
		if (soap->alloced)
			soap_default_rgtf__createNewTreeResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgtf__getActiveTreesResponse(struct soap *soap, struct rgtf__getActiveTreesResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgtf__getActiveTreesResponse))
		soap_mark_rgtf__getActiveTreesResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgtf__getActiveTreesResponse(struct soap *soap, const struct rgtf__getActiveTreesResponse *a)
{
	soap_embedded(soap, &a->_getActiveTreesReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_getActiveTreesReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgtf__getActiveTreesResponse(struct soap *soap, struct rgtf__getActiveTreesResponse *a)
{
	soap_default_xsd__string(soap, &a->_getActiveTreesReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgtf__getActiveTreesResponse(struct soap *soap, struct rgtf__getActiveTreesResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgtf__getActiveTreesResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgtf__getActiveTreesResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgtf__getActiveTreesResponse(soap, tag, i, a, type);
		}
	else
		soap_out_rgtf__getActiveTreesResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgtf__getActiveTreesResponse(struct soap *soap, const char *tag, int id, const struct rgtf__getActiveTreesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__getActiveTreesResponse), type);
	soap_out_xsd__string(soap, "getActiveTreesReturn", -1, &a->_getActiveTreesReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgtf__getActiveTreesResponse * SOAP_FMAC2 soap_get_rgtf__getActiveTreesResponse(struct soap *soap, struct rgtf__getActiveTreesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__getActiveTreesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgtf__getActiveTreesResponse * SOAP_FMAC2 soap_in_rgtf__getActiveTreesResponse(struct soap *soap, const char *tag, struct rgtf__getActiveTreesResponse *a, const char *type)
{
	short soap_flag__getActiveTreesReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgtf__getActiveTreesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__getActiveTreesResponse, sizeof(struct rgtf__getActiveTreesResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgtf__getActiveTreesResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getActiveTreesReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_getActiveTreesReturn, "xsd:string"))
				{	soap_flag__getActiveTreesReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgtf__getActiveTreesResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__getActiveTreesResponse, sizeof(struct rgtf__getActiveTreesResponse), 0), SOAP_TYPE_rgtf__getActiveTreesResponse, sizeof(struct rgtf__getActiveTreesResponse));
		if (soap->alloced)
			soap_default_rgtf__getActiveTreesResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgtf__findByHandleResponse(struct soap *soap, struct rgtf__findByHandleResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgtf__findByHandleResponse))
		soap_mark_rgtf__findByHandleResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgtf__findByHandleResponse(struct soap *soap, const struct rgtf__findByHandleResponse *a)
{
	soap_embedded(soap, &a->_findByHandleReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_findByHandleReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgtf__findByHandleResponse(struct soap *soap, struct rgtf__findByHandleResponse *a)
{
	soap_default_xsd__string(soap, &a->_findByHandleReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgtf__findByHandleResponse(struct soap *soap, struct rgtf__findByHandleResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgtf__findByHandleResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgtf__findByHandleResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgtf__findByHandleResponse(soap, tag, i, a, type);
		}
	else
		soap_out_rgtf__findByHandleResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgtf__findByHandleResponse(struct soap *soap, const char *tag, int id, const struct rgtf__findByHandleResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__findByHandleResponse), type);
	soap_out_xsd__string(soap, "findByHandleReturn", -1, &a->_findByHandleReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgtf__findByHandleResponse * SOAP_FMAC2 soap_get_rgtf__findByHandleResponse(struct soap *soap, struct rgtf__findByHandleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__findByHandleResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgtf__findByHandleResponse * SOAP_FMAC2 soap_in_rgtf__findByHandleResponse(struct soap *soap, const char *tag, struct rgtf__findByHandleResponse *a, const char *type)
{
	short soap_flag__findByHandleReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgtf__findByHandleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__findByHandleResponse, sizeof(struct rgtf__findByHandleResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgtf__findByHandleResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__findByHandleReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_findByHandleReturn, "xsd:string"))
				{	soap_flag__findByHandleReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgtf__findByHandleResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__findByHandleResponse, sizeof(struct rgtf__findByHandleResponse), 0), SOAP_TYPE_rgtf__findByHandleResponse, sizeof(struct rgtf__findByHandleResponse));
		if (soap->alloced)
			soap_default_rgtf__findByHandleResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgtf__findServiceDataResponse(struct soap *soap, struct rgtf__findServiceDataResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgtf__findServiceDataResponse))
		soap_mark_rgtf__findServiceDataResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgtf__findServiceDataResponse(struct soap *soap, const struct rgtf__findServiceDataResponse *a)
{
	soap_embedded(soap, &a->_findServiceDataReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_findServiceDataReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgtf__findServiceDataResponse(struct soap *soap, struct rgtf__findServiceDataResponse *a)
{
	soap_default_xsd__string(soap, &a->_findServiceDataReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgtf__findServiceDataResponse(struct soap *soap, struct rgtf__findServiceDataResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgtf__findServiceDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgtf__findServiceDataResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgtf__findServiceDataResponse(soap, tag, i, a, type);
		}
	else
		soap_out_rgtf__findServiceDataResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgtf__findServiceDataResponse(struct soap *soap, const char *tag, int id, const struct rgtf__findServiceDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__findServiceDataResponse), type);
	soap_out_xsd__string(soap, "findServiceDataReturn", -1, &a->_findServiceDataReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgtf__findServiceDataResponse * SOAP_FMAC2 soap_get_rgtf__findServiceDataResponse(struct soap *soap, struct rgtf__findServiceDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__findServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgtf__findServiceDataResponse * SOAP_FMAC2 soap_in_rgtf__findServiceDataResponse(struct soap *soap, const char *tag, struct rgtf__findServiceDataResponse *a, const char *type)
{
	short soap_flag__findServiceDataReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgtf__findServiceDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__findServiceDataResponse, sizeof(struct rgtf__findServiceDataResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgtf__findServiceDataResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__findServiceDataReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_findServiceDataReturn, "xsd:string"))
				{	soap_flag__findServiceDataReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgtf__findServiceDataResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__findServiceDataResponse, sizeof(struct rgtf__findServiceDataResponse), 0), SOAP_TYPE_rgtf__findServiceDataResponse, sizeof(struct rgtf__findServiceDataResponse));
		if (soap->alloced)
			soap_default_rgtf__findServiceDataResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_rgtf__requestTerminationBeforeResponse(struct soap *soap, struct rgtf__requestTerminationBeforeResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_rgtf__requestTerminationBeforeResponse))
		soap_mark_rgtf__requestTerminationBeforeResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_rgtf__requestTerminationBeforeResponse(struct soap *soap, const struct rgtf__requestTerminationBeforeResponse *a)
{
	soap_embedded(soap, &a->_requestTerminationBeforeReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_requestTerminationBeforeReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_rgtf__requestTerminationBeforeResponse(struct soap *soap, struct rgtf__requestTerminationBeforeResponse *a)
{
	soap_default_xsd__string(soap, &a->_requestTerminationBeforeReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_rgtf__requestTerminationBeforeResponse(struct soap *soap, struct rgtf__requestTerminationBeforeResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_rgtf__requestTerminationBeforeResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_rgtf__requestTerminationBeforeResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_rgtf__requestTerminationBeforeResponse(soap, tag, i, a, type);
		}
	else
		soap_out_rgtf__requestTerminationBeforeResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_rgtf__requestTerminationBeforeResponse(struct soap *soap, const char *tag, int id, const struct rgtf__requestTerminationBeforeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rgtf__requestTerminationBeforeResponse), type);
	soap_out_xsd__string(soap, "requestTerminationBeforeReturn", -1, &a->_requestTerminationBeforeReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct rgtf__requestTerminationBeforeResponse * SOAP_FMAC2 soap_get_rgtf__requestTerminationBeforeResponse(struct soap *soap, struct rgtf__requestTerminationBeforeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rgtf__requestTerminationBeforeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgtf__requestTerminationBeforeResponse * SOAP_FMAC2 soap_in_rgtf__requestTerminationBeforeResponse(struct soap *soap, const char *tag, struct rgtf__requestTerminationBeforeResponse *a, const char *type)
{
	short soap_flag__requestTerminationBeforeReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct rgtf__requestTerminationBeforeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__requestTerminationBeforeResponse, sizeof(struct rgtf__requestTerminationBeforeResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_rgtf__requestTerminationBeforeResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__requestTerminationBeforeReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_requestTerminationBeforeReturn, "xsd:string"))
				{	soap_flag__requestTerminationBeforeReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct rgtf__requestTerminationBeforeResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rgtf__requestTerminationBeforeResponse, sizeof(struct rgtf__requestTerminationBeforeResponse), 0), SOAP_TYPE_rgtf__requestTerminationBeforeResponse, sizeof(struct rgtf__requestTerminationBeforeResponse));
		if (soap->alloced)
			soap_default_rgtf__requestTerminationBeforeResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgr__findServiceData(struct soap *soap, struct sgr__findServiceData const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgr__findServiceData))
		soap_mark_sgr__findServiceData(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgr__findServiceData(struct soap *soap, const struct sgr__findServiceData *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgr__findServiceData(struct soap *soap, struct sgr__findServiceData *a)
{
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgr__findServiceData(struct soap *soap, struct sgr__findServiceData *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgr__findServiceData, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgr__findServiceData(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgr__findServiceData(soap, tag, i, a, type);
		}
	else
		soap_out_sgr__findServiceData(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgr__findServiceData(struct soap *soap, const char *tag, int id, const struct sgr__findServiceData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgr__findServiceData), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgr__findServiceData * SOAP_FMAC2 soap_get_sgr__findServiceData(struct soap *soap, struct sgr__findServiceData *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgr__findServiceData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgr__findServiceData * SOAP_FMAC2 soap_in_sgr__findServiceData(struct soap *soap, const char *tag, struct sgr__findServiceData *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgr__findServiceData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgr__findServiceData, sizeof(struct sgr__findServiceData), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgr__findServiceData(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgr__findServiceData *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgr__findServiceData, sizeof(struct sgr__findServiceData), 0), SOAP_TYPE_sgr__findServiceData, sizeof(struct sgr__findServiceData));
		if (soap->alloced)
			soap_default_sgr__findServiceData(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgr__add(struct soap *soap, struct sgr__add const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgr__add))
		soap_mark_sgr__add(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgr__add(struct soap *soap, const struct sgr__add *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
	soap_embedded(soap, &a->in1, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in1);
	soap_embedded(soap, &a->in2, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in2);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgr__add(struct soap *soap, struct sgr__add *a)
{
	soap_default_xsd__string(soap, &a->in0);
	soap_default_xsd__string(soap, &a->in1);
	soap_default_xsd__string(soap, &a->in2);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgr__add(struct soap *soap, struct sgr__add *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgr__add, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgr__add(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgr__add(soap, tag, i, a, type);
		}
	else
		soap_out_sgr__add(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgr__add(struct soap *soap, const char *tag, int id, const struct sgr__add *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgr__add), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_out_xsd__string(soap, "in1", -1, &a->in1, "xsd:string");
	soap_out_xsd__string(soap, "in2", -1, &a->in2, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgr__add * SOAP_FMAC2 soap_get_sgr__add(struct soap *soap, struct sgr__add *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgr__add(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgr__add * SOAP_FMAC2 soap_in_sgr__add(struct soap *soap, const char *tag, struct sgr__add *a, const char *type)
{
	short soap_flag_in0 = 1, soap_flag_in1 = 1, soap_flag_in2 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgr__add *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgr__add, sizeof(struct sgr__add), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgr__add(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap_flag_in1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in1", &a->in1, "xsd:string"))
				{	soap_flag_in1 = 0;
					continue;
				}
			if (soap_flag_in2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in2", &a->in2, "xsd:string"))
				{	soap_flag_in2 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgr__add *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgr__add, sizeof(struct sgr__add), 0), SOAP_TYPE_sgr__add, sizeof(struct sgr__add));
		if (soap->alloced)
			soap_default_sgr__add(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgr__remove(struct soap *soap, struct sgr__remove const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgr__remove))
		soap_mark_sgr__remove(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgr__remove(struct soap *soap, const struct sgr__remove *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgr__remove(struct soap *soap, struct sgr__remove *a)
{
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgr__remove(struct soap *soap, struct sgr__remove *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgr__remove, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgr__remove(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgr__remove(soap, tag, i, a, type);
		}
	else
		soap_out_sgr__remove(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgr__remove(struct soap *soap, const char *tag, int id, const struct sgr__remove *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgr__remove), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgr__remove * SOAP_FMAC2 soap_get_sgr__remove(struct soap *soap, struct sgr__remove *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgr__remove(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgr__remove * SOAP_FMAC2 soap_in_sgr__remove(struct soap *soap, const char *tag, struct sgr__remove *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgr__remove *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgr__remove, sizeof(struct sgr__remove), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgr__remove(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgr__remove *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgr__remove, sizeof(struct sgr__remove), 0), SOAP_TYPE_sgr__remove, sizeof(struct sgr__remove));
		if (soap->alloced)
			soap_default_sgr__remove(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgr__removeResponse(struct soap *soap, struct sgr__removeResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgr__removeResponse))
		soap_mark_sgr__removeResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgr__removeResponse(struct soap *soap, const struct sgr__removeResponse *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgr__removeResponse(struct soap *soap, struct sgr__removeResponse *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgr__removeResponse(struct soap *soap, struct sgr__removeResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgr__removeResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgr__removeResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgr__removeResponse(soap, tag, i, a, type);
		}
	else
		soap_out_sgr__removeResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgr__removeResponse(struct soap *soap, const char *tag, int id, const struct sgr__removeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgr__removeResponse), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgr__removeResponse * SOAP_FMAC2 soap_get_sgr__removeResponse(struct soap *soap, struct sgr__removeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgr__removeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgr__removeResponse * SOAP_FMAC2 soap_in_sgr__removeResponse(struct soap *soap, const char *tag, struct sgr__removeResponse *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgr__removeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgr__removeResponse, sizeof(struct sgr__removeResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgr__removeResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgr__removeResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgr__removeResponse, sizeof(struct sgr__removeResponse), 0), SOAP_TYPE_sgr__removeResponse, sizeof(struct sgr__removeResponse));
		if (soap->alloced)
			soap_default_sgr__removeResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgr__addResponse(struct soap *soap, struct sgr__addResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgr__addResponse))
		soap_mark_sgr__addResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgr__addResponse(struct soap *soap, const struct sgr__addResponse *a)
{
	soap_embedded(soap, &a->_addReturn, SOAP_TYPE_PointerToArrayOf_USCORE_xsd_USCORE_string);
	soap_mark_PointerToArrayOf_USCORE_xsd_USCORE_string(soap, &a->_addReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgr__addResponse(struct soap *soap, struct sgr__addResponse *a)
{
	soap_default_PointerToArrayOf_USCORE_xsd_USCORE_string(soap, &a->_addReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgr__addResponse(struct soap *soap, struct sgr__addResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgr__addResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgr__addResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgr__addResponse(soap, tag, i, a, type);
		}
	else
		soap_out_sgr__addResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgr__addResponse(struct soap *soap, const char *tag, int id, const struct sgr__addResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgr__addResponse), type);
	soap_out_PointerToArrayOf_USCORE_xsd_USCORE_string(soap, "addReturn", -1, &a->_addReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgr__addResponse * SOAP_FMAC2 soap_get_sgr__addResponse(struct soap *soap, struct sgr__addResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgr__addResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgr__addResponse * SOAP_FMAC2 soap_in_sgr__addResponse(struct soap *soap, const char *tag, struct sgr__addResponse *a, const char *type)
{
	short soap_flag__addReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgr__addResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgr__addResponse, sizeof(struct sgr__addResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgr__addResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__addReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCORE_xsd_USCORE_string(soap, NULL, &a->_addReturn, "xsd:string"))
				{	soap_flag__addReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgr__addResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgr__addResponse, sizeof(struct sgr__addResponse), 0), SOAP_TYPE_sgr__addResponse, sizeof(struct sgr__addResponse));
		if (soap->alloced)
			soap_default_sgr__addResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_ArrayOf_USCORE_xsd_USCORE_string(struct soap *soap, struct ArrayOf_USCORE_xsd_USCORE_string const*a)
{
	soap_mark_ArrayOf_USCORE_xsd_USCORE_string(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_ArrayOf_USCORE_xsd_USCORE_string(struct soap *soap, struct ArrayOf_USCORE_xsd_USCORE_string const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, a->__size, SOAP_TYPE_ArrayOf_USCORE_xsd_USCORE_string))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_xsd__string);
			soap_mark_xsd__string(soap, a->__ptr + i);
		}
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_ArrayOf_USCORE_xsd_USCORE_string(struct soap *soap, struct ArrayOf_USCORE_xsd_USCORE_string *a)
{
	a->__size = 0;
	a->__ptr = NULL;
	a->__offset = 0;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_ArrayOf_USCORE_xsd_USCORE_string(struct soap *soap, struct ArrayOf_USCORE_xsd_USCORE_string *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_array_pointer_lookup(soap, a, (struct soap_array*)&a->__ptr, a->__size, SOAP_TYPE_ArrayOf_USCORE_xsd_USCORE_string, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_ArrayOf_USCORE_xsd_USCORE_string(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_ArrayOf_USCORE_xsd_USCORE_string(soap, tag, i, a, type);
		}
	else
		soap_out_ArrayOf_USCORE_xsd_USCORE_string(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_ArrayOf_USCORE_xsd_USCORE_string(struct soap *soap, const char *tag, int id, const struct ArrayOf_USCORE_xsd_USCORE_string *a, const char *type)
{
	int i;
	struct soap_plist *pp;
	int n = a->__size;
	char *t = soap_putsize(soap, type, n + a->__offset);
	i = soap_array_pointer_lookup(soap, a, (struct soap_array*)&a->__ptr, n, SOAP_TYPE_ArrayOf_USCORE_xsd_USCORE_string, &pp);
	if (!a->__ptr)
	{	soap_element_null(soap, tag, i, t);
		return SOAP_OK;
	}
	if (id <= 0 && i)
	{	if (soap_is_embedded(soap, pp))
		{	soap_element_ref(soap, tag, 0, i);
			return SOAP_OK;
		}
		if (soap_is_single(soap, pp))
			i = 0;
	}
	else if (id > 0)
		i = id;
	soap_array_begin_out(soap, tag, i, t, soap_putoffset(soap, a->__offset));
	if (i)
		soap_set_embedded(soap, pp);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_xsd__string(soap, "item", 0, &a->__ptr[i], "xsd:string");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct ArrayOf_USCORE_xsd_USCORE_string * SOAP_FMAC2 soap_get_ArrayOf_USCORE_xsd_USCORE_string(struct soap *soap, struct ArrayOf_USCORE_xsd_USCORE_string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOf_USCORE_xsd_USCORE_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct ArrayOf_USCORE_xsd_USCORE_string * SOAP_FMAC2 soap_in_ArrayOf_USCORE_xsd_USCORE_string(struct soap *soap, const char *tag, struct ArrayOf_USCORE_xsd_USCORE_string *a, const char *type)
{	int i, j;
	char **p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if ((a = (struct ArrayOf_USCORE_xsd_USCORE_string *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOf_USCORE_xsd_USCORE_string, sizeof(struct ArrayOf_USCORE_xsd_USCORE_string), 0)))
			soap_default_ArrayOf_USCORE_xsd_USCORE_string(soap, a);
			if (soap->body && soap_element_end_in(soap, tag))
				return NULL;
	}
	else if (!*soap->href)
	{	if (!(a = (struct ArrayOf_USCORE_xsd_USCORE_string *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOf_USCORE_xsd_USCORE_string, sizeof(struct ArrayOf_USCORE_xsd_USCORE_string), 0)))
			return NULL;
		if (soap->alloced)
			soap_default_ArrayOf_USCORE_xsd_USCORE_string(soap, a);
		if (soap->body)
		{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		a->__offset = j;
		if (j >= 0 && a->__size >= 0)
		{	a->__ptr = (char **)soap_malloc(soap, sizeof(char *) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_xsd__string(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
					return NULL;
					}
				}
				if (!soap_in_xsd__string(soap, NULL, a->__ptr+i, "xsd:string"))
				{	if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (char **)soap_push_block(soap, sizeof(char *));
				if (!p)
					return NULL;
				soap_default_xsd__string(soap, p);
				if (!soap_in_xsd__string(soap, NULL, p, "xsd:string"))
				{	if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (char **)soap_malloc(soap, soap->blist->size);
			soap_store_block(soap, (char*)a->__ptr);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct ArrayOf_USCORE_xsd_USCORE_string *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOf_USCORE_xsd_USCORE_string, sizeof(struct ArrayOf_USCORE_xsd_USCORE_string), 0), SOAP_TYPE_ArrayOf_USCORE_xsd_USCORE_string, sizeof(struct ArrayOf_USCORE_xsd_USCORE_string));
		if (soap->alloced)
			soap_default_ArrayOf_USCORE_xsd_USCORE_string(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgr__findServiceDataResponse(struct soap *soap, struct sgr__findServiceDataResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgr__findServiceDataResponse))
		soap_mark_sgr__findServiceDataResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgr__findServiceDataResponse(struct soap *soap, const struct sgr__findServiceDataResponse *a)
{
	soap_embedded(soap, &a->_findServiceDataReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_findServiceDataReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgr__findServiceDataResponse(struct soap *soap, struct sgr__findServiceDataResponse *a)
{
	soap_default_xsd__string(soap, &a->_findServiceDataReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgr__findServiceDataResponse(struct soap *soap, struct sgr__findServiceDataResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgr__findServiceDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgr__findServiceDataResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgr__findServiceDataResponse(soap, tag, i, a, type);
		}
	else
		soap_out_sgr__findServiceDataResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgr__findServiceDataResponse(struct soap *soap, const char *tag, int id, const struct sgr__findServiceDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgr__findServiceDataResponse), type);
	soap_out_xsd__string(soap, "findServiceDataReturn", -1, &a->_findServiceDataReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgr__findServiceDataResponse * SOAP_FMAC2 soap_get_sgr__findServiceDataResponse(struct soap *soap, struct sgr__findServiceDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgr__findServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgr__findServiceDataResponse * SOAP_FMAC2 soap_in_sgr__findServiceDataResponse(struct soap *soap, const char *tag, struct sgr__findServiceDataResponse *a, const char *type)
{
	short soap_flag__findServiceDataReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgr__findServiceDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgr__findServiceDataResponse, sizeof(struct sgr__findServiceDataResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgr__findServiceDataResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__findServiceDataReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_findServiceDataReturn, "xsd:string"))
				{	soap_flag__findServiceDataReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgr__findServiceDataResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgr__findServiceDataResponse, sizeof(struct sgr__findServiceDataResponse), 0), SOAP_TYPE_sgr__findServiceDataResponse, sizeof(struct sgr__findServiceDataResponse));
		if (soap->alloced)
			soap_default_sgr__findServiceDataResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__ClearStatusMsgQueue(struct soap *soap, struct sgs__ClearStatusMsgQueue const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__ClearStatusMsgQueue))
		soap_mark_sgs__ClearStatusMsgQueue(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__ClearStatusMsgQueue(struct soap *soap, const struct sgs__ClearStatusMsgQueue *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__ClearStatusMsgQueue(struct soap *soap, struct sgs__ClearStatusMsgQueue *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__ClearStatusMsgQueue(struct soap *soap, struct sgs__ClearStatusMsgQueue *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__ClearStatusMsgQueue, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__ClearStatusMsgQueue(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__ClearStatusMsgQueue(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__ClearStatusMsgQueue(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__ClearStatusMsgQueue(struct soap *soap, const char *tag, int id, const struct sgs__ClearStatusMsgQueue *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__ClearStatusMsgQueue), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__ClearStatusMsgQueue * SOAP_FMAC2 soap_get_sgs__ClearStatusMsgQueue(struct soap *soap, struct sgs__ClearStatusMsgQueue *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__ClearStatusMsgQueue(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__ClearStatusMsgQueue * SOAP_FMAC2 soap_in_sgs__ClearStatusMsgQueue(struct soap *soap, const char *tag, struct sgs__ClearStatusMsgQueue *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__ClearStatusMsgQueue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__ClearStatusMsgQueue, sizeof(struct sgs__ClearStatusMsgQueue), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__ClearStatusMsgQueue(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__ClearStatusMsgQueue *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__ClearStatusMsgQueue, sizeof(struct sgs__ClearStatusMsgQueue), 0), SOAP_TYPE_sgs__ClearStatusMsgQueue, sizeof(struct sgs__ClearStatusMsgQueue));
		if (soap->alloced)
			soap_default_sgs__ClearStatusMsgQueue(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__Resume(struct soap *soap, struct sgs__Resume const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__Resume))
		soap_mark_sgs__Resume(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__Resume(struct soap *soap, const struct sgs__Resume *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__Resume(struct soap *soap, struct sgs__Resume *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__Resume(struct soap *soap, struct sgs__Resume *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__Resume, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__Resume(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__Resume(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__Resume(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__Resume(struct soap *soap, const char *tag, int id, const struct sgs__Resume *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__Resume), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__Resume * SOAP_FMAC2 soap_get_sgs__Resume(struct soap *soap, struct sgs__Resume *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__Resume(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__Resume * SOAP_FMAC2 soap_in_sgs__Resume(struct soap *soap, const char *tag, struct sgs__Resume *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__Resume *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__Resume, sizeof(struct sgs__Resume), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__Resume(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__Resume *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__Resume, sizeof(struct sgs__Resume), 0), SOAP_TYPE_sgs__Resume, sizeof(struct sgs__Resume));
		if (soap->alloced)
			soap_default_sgs__Resume(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__AppStart(struct soap *soap, struct sgs__AppStart const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__AppStart))
		soap_mark_sgs__AppStart(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__AppStart(struct soap *soap, const struct sgs__AppStart *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__AppStart(struct soap *soap, struct sgs__AppStart *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__AppStart(struct soap *soap, struct sgs__AppStart *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__AppStart, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__AppStart(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__AppStart(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__AppStart(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__AppStart(struct soap *soap, const char *tag, int id, const struct sgs__AppStart *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__AppStart), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__AppStart * SOAP_FMAC2 soap_get_sgs__AppStart(struct soap *soap, struct sgs__AppStart *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__AppStart(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__AppStart * SOAP_FMAC2 soap_in_sgs__AppStart(struct soap *soap, const char *tag, struct sgs__AppStart *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__AppStart *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppStart, sizeof(struct sgs__AppStart), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__AppStart(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__AppStart *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppStart, sizeof(struct sgs__AppStart), 0), SOAP_TYPE_sgs__AppStart, sizeof(struct sgs__AppStart));
		if (soap->alloced)
			soap_default_sgs__AppStart(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__GetNotifications(struct soap *soap, struct sgs__GetNotifications const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__GetNotifications))
		soap_mark_sgs__GetNotifications(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__GetNotifications(struct soap *soap, const struct sgs__GetNotifications *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__GetNotifications(struct soap *soap, struct sgs__GetNotifications *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__GetNotifications(struct soap *soap, struct sgs__GetNotifications *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__GetNotifications, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__GetNotifications(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__GetNotifications(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__GetNotifications(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__GetNotifications(struct soap *soap, const char *tag, int id, const struct sgs__GetNotifications *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__GetNotifications), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__GetNotifications * SOAP_FMAC2 soap_get_sgs__GetNotifications(struct soap *soap, struct sgs__GetNotifications *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__GetNotifications(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__GetNotifications * SOAP_FMAC2 soap_in_sgs__GetNotifications(struct soap *soap, const char *tag, struct sgs__GetNotifications *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__GetNotifications *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetNotifications, sizeof(struct sgs__GetNotifications), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__GetNotifications(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__GetNotifications *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetNotifications, sizeof(struct sgs__GetNotifications), 0), SOAP_TYPE_sgs__GetNotifications, sizeof(struct sgs__GetNotifications));
		if (soap->alloced)
			soap_default_sgs__GetNotifications(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__Pause(struct soap *soap, struct sgs__Pause const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__Pause))
		soap_mark_sgs__Pause(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__Pause(struct soap *soap, const struct sgs__Pause *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__Pause(struct soap *soap, struct sgs__Pause *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__Pause(struct soap *soap, struct sgs__Pause *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__Pause, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__Pause(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__Pause(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__Pause(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__Pause(struct soap *soap, const char *tag, int id, const struct sgs__Pause *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__Pause), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__Pause * SOAP_FMAC2 soap_get_sgs__Pause(struct soap *soap, struct sgs__Pause *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__Pause(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__Pause * SOAP_FMAC2 soap_in_sgs__Pause(struct soap *soap, const char *tag, struct sgs__Pause *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__Pause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__Pause, sizeof(struct sgs__Pause), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__Pause(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__Pause *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__Pause, sizeof(struct sgs__Pause), 0), SOAP_TYPE_sgs__Pause, sizeof(struct sgs__Pause));
		if (soap->alloced)
			soap_default_sgs__Pause(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__AppRecordChkpoint(struct soap *soap, struct sgs__AppRecordChkpoint const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__AppRecordChkpoint))
		soap_mark_sgs__AppRecordChkpoint(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__AppRecordChkpoint(struct soap *soap, const struct sgs__AppRecordChkpoint *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
	soap_embedded(soap, &a->in1, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__AppRecordChkpoint(struct soap *soap, struct sgs__AppRecordChkpoint *a)
{
	soap_default_xsd__string(soap, &a->in0);
	soap_default_xsd__string(soap, &a->in1);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__AppRecordChkpoint(struct soap *soap, struct sgs__AppRecordChkpoint *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__AppRecordChkpoint, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__AppRecordChkpoint(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__AppRecordChkpoint(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__AppRecordChkpoint(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__AppRecordChkpoint(struct soap *soap, const char *tag, int id, const struct sgs__AppRecordChkpoint *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__AppRecordChkpoint), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_out_xsd__string(soap, "in1", -1, &a->in1, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__AppRecordChkpoint * SOAP_FMAC2 soap_get_sgs__AppRecordChkpoint(struct soap *soap, struct sgs__AppRecordChkpoint *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__AppRecordChkpoint(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__AppRecordChkpoint * SOAP_FMAC2 soap_in_sgs__AppRecordChkpoint(struct soap *soap, const char *tag, struct sgs__AppRecordChkpoint *a, const char *type)
{
	short soap_flag_in0 = 1, soap_flag_in1 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__AppRecordChkpoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppRecordChkpoint, sizeof(struct sgs__AppRecordChkpoint), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__AppRecordChkpoint(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap_flag_in1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in1", &a->in1, "xsd:string"))
				{	soap_flag_in1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__AppRecordChkpoint *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppRecordChkpoint, sizeof(struct sgs__AppRecordChkpoint), 0), SOAP_TYPE_sgs__AppRecordChkpoint, sizeof(struct sgs__AppRecordChkpoint));
		if (soap->alloced)
			soap_default_sgs__AppRecordChkpoint(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__findServiceData(struct soap *soap, struct sgs__findServiceData const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__findServiceData))
		soap_mark_sgs__findServiceData(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__findServiceData(struct soap *soap, const struct sgs__findServiceData *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__findServiceData(struct soap *soap, struct sgs__findServiceData *a)
{
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__findServiceData(struct soap *soap, struct sgs__findServiceData *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__findServiceData, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__findServiceData(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__findServiceData(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__findServiceData(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__findServiceData(struct soap *soap, const char *tag, int id, const struct sgs__findServiceData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__findServiceData), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__findServiceData * SOAP_FMAC2 soap_get_sgs__findServiceData(struct soap *soap, struct sgs__findServiceData *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__findServiceData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__findServiceData * SOAP_FMAC2 soap_in_sgs__findServiceData(struct soap *soap, const char *tag, struct sgs__findServiceData *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__findServiceData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__findServiceData, sizeof(struct sgs__findServiceData), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__findServiceData(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__findServiceData *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__findServiceData, sizeof(struct sgs__findServiceData), 0), SOAP_TYPE_sgs__findServiceData, sizeof(struct sgs__findServiceData));
		if (soap->alloced)
			soap_default_sgs__findServiceData(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__PutControl(struct soap *soap, struct sgs__PutControl const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__PutControl))
		soap_mark_sgs__PutControl(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__PutControl(struct soap *soap, const struct sgs__PutControl *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__PutControl(struct soap *soap, struct sgs__PutControl *a)
{
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__PutControl(struct soap *soap, struct sgs__PutControl *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__PutControl, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__PutControl(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__PutControl(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__PutControl(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__PutControl(struct soap *soap, const char *tag, int id, const struct sgs__PutControl *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__PutControl), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__PutControl * SOAP_FMAC2 soap_get_sgs__PutControl(struct soap *soap, struct sgs__PutControl *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__PutControl(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__PutControl * SOAP_FMAC2 soap_in_sgs__PutControl(struct soap *soap, const char *tag, struct sgs__PutControl *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__PutControl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__PutControl, sizeof(struct sgs__PutControl), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__PutControl(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__PutControl *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__PutControl, sizeof(struct sgs__PutControl), 0), SOAP_TYPE_sgs__PutControl, sizeof(struct sgs__PutControl));
		if (soap->alloced)
			soap_default_sgs__PutControl(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__Detach(struct soap *soap, struct sgs__Detach const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__Detach))
		soap_mark_sgs__Detach(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__Detach(struct soap *soap, const struct sgs__Detach *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__Detach(struct soap *soap, struct sgs__Detach *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__Detach(struct soap *soap, struct sgs__Detach *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__Detach, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__Detach(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__Detach(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__Detach(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__Detach(struct soap *soap, const char *tag, int id, const struct sgs__Detach *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__Detach), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__Detach * SOAP_FMAC2 soap_get_sgs__Detach(struct soap *soap, struct sgs__Detach *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__Detach(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__Detach * SOAP_FMAC2 soap_in_sgs__Detach(struct soap *soap, const char *tag, struct sgs__Detach *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__Detach *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__Detach, sizeof(struct sgs__Detach), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__Detach(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__Detach *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__Detach, sizeof(struct sgs__Detach), 0), SOAP_TYPE_sgs__Detach, sizeof(struct sgs__Detach));
		if (soap->alloced)
			soap_default_sgs__Detach(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__Stop(struct soap *soap, struct sgs__Stop const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__Stop))
		soap_mark_sgs__Stop(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__Stop(struct soap *soap, const struct sgs__Stop *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__Stop(struct soap *soap, struct sgs__Stop *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__Stop(struct soap *soap, struct sgs__Stop *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__Stop, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__Stop(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__Stop(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__Stop(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__Stop(struct soap *soap, const char *tag, int id, const struct sgs__Stop *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__Stop), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__Stop * SOAP_FMAC2 soap_get_sgs__Stop(struct soap *soap, struct sgs__Stop *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__Stop(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__Stop * SOAP_FMAC2 soap_in_sgs__Stop(struct soap *soap, const char *tag, struct sgs__Stop *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__Stop *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__Stop, sizeof(struct sgs__Stop), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__Stop(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__Stop *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__Stop, sizeof(struct sgs__Stop), 0), SOAP_TYPE_sgs__Stop, sizeof(struct sgs__Stop));
		if (soap->alloced)
			soap_default_sgs__Stop(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__GetNthDataSource(struct soap *soap, struct sgs__GetNthDataSource const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__GetNthDataSource))
		soap_mark_sgs__GetNthDataSource(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__GetNthDataSource(struct soap *soap, const struct sgs__GetNthDataSource *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__int);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__GetNthDataSource(struct soap *soap, struct sgs__GetNthDataSource *a)
{
	soap_default_xsd__int(soap, &a->in0);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__GetNthDataSource(struct soap *soap, struct sgs__GetNthDataSource *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__GetNthDataSource, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__GetNthDataSource(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__GetNthDataSource(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__GetNthDataSource(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__GetNthDataSource(struct soap *soap, const char *tag, int id, const struct sgs__GetNthDataSource *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__GetNthDataSource), type);
	soap_out_xsd__int(soap, "in0", -1, &a->in0, "xsd:int");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__GetNthDataSource * SOAP_FMAC2 soap_get_sgs__GetNthDataSource(struct soap *soap, struct sgs__GetNthDataSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__GetNthDataSource(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__GetNthDataSource * SOAP_FMAC2 soap_in_sgs__GetNthDataSource(struct soap *soap, const char *tag, struct sgs__GetNthDataSource *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__GetNthDataSource *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetNthDataSource, sizeof(struct sgs__GetNthDataSource), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__GetNthDataSource(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "in0", &a->in0, "xsd:int"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__GetNthDataSource *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetNthDataSource, sizeof(struct sgs__GetNthDataSource), 0), SOAP_TYPE_sgs__GetNthDataSource, sizeof(struct sgs__GetNthDataSource));
		if (soap->alloced)
			soap_default_sgs__GetNthDataSource(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__Attach(struct soap *soap, struct sgs__Attach const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__Attach))
		soap_mark_sgs__Attach(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__Attach(struct soap *soap, const struct sgs__Attach *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__Attach(struct soap *soap, struct sgs__Attach *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__Attach(struct soap *soap, struct sgs__Attach *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__Attach, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__Attach(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__Attach(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__Attach(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__Attach(struct soap *soap, const char *tag, int id, const struct sgs__Attach *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__Attach), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__Attach * SOAP_FMAC2 soap_get_sgs__Attach(struct soap *soap, struct sgs__Attach *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__Attach(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__Attach * SOAP_FMAC2 soap_in_sgs__Attach(struct soap *soap, const char *tag, struct sgs__Attach *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__Attach *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__Attach, sizeof(struct sgs__Attach), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__Attach(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__Attach *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__Attach, sizeof(struct sgs__Attach), 0), SOAP_TYPE_sgs__Attach, sizeof(struct sgs__Attach));
		if (soap->alloced)
			soap_default_sgs__Attach(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__Restart(struct soap *soap, struct sgs__Restart const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__Restart))
		soap_mark_sgs__Restart(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__Restart(struct soap *soap, const struct sgs__Restart *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__Restart(struct soap *soap, struct sgs__Restart *a)
{
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__Restart(struct soap *soap, struct sgs__Restart *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__Restart, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__Restart(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__Restart(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__Restart(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__Restart(struct soap *soap, const char *tag, int id, const struct sgs__Restart *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__Restart), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__Restart * SOAP_FMAC2 soap_get_sgs__Restart(struct soap *soap, struct sgs__Restart *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__Restart(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__Restart * SOAP_FMAC2 soap_in_sgs__Restart(struct soap *soap, const char *tag, struct sgs__Restart *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__Restart *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__Restart, sizeof(struct sgs__Restart), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__Restart(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__Restart *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__Restart, sizeof(struct sgs__Restart), 0), SOAP_TYPE_sgs__Restart, sizeof(struct sgs__Restart));
		if (soap->alloced)
			soap_default_sgs__Restart(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__GetStatus(struct soap *soap, struct sgs__GetStatus const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__GetStatus))
		soap_mark_sgs__GetStatus(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__GetStatus(struct soap *soap, const struct sgs__GetStatus *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__GetStatus(struct soap *soap, struct sgs__GetStatus *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__GetStatus(struct soap *soap, struct sgs__GetStatus *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__GetStatus, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__GetStatus(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__GetStatus(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__GetStatus(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__GetStatus(struct soap *soap, const char *tag, int id, const struct sgs__GetStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__GetStatus), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__GetStatus * SOAP_FMAC2 soap_get_sgs__GetStatus(struct soap *soap, struct sgs__GetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__GetStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__GetStatus * SOAP_FMAC2 soap_in_sgs__GetStatus(struct soap *soap, const char *tag, struct sgs__GetStatus *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__GetStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetStatus, sizeof(struct sgs__GetStatus), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__GetStatus(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__GetStatus *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetStatus, sizeof(struct sgs__GetStatus), 0), SOAP_TYPE_sgs__GetStatus, sizeof(struct sgs__GetStatus));
		if (soap->alloced)
			soap_default_sgs__GetStatus(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__GetControl(struct soap *soap, struct sgs__GetControl const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__GetControl))
		soap_mark_sgs__GetControl(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__GetControl(struct soap *soap, const struct sgs__GetControl *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__GetControl(struct soap *soap, struct sgs__GetControl *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__GetControl(struct soap *soap, struct sgs__GetControl *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__GetControl, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__GetControl(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__GetControl(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__GetControl(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__GetControl(struct soap *soap, const char *tag, int id, const struct sgs__GetControl *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__GetControl), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__GetControl * SOAP_FMAC2 soap_get_sgs__GetControl(struct soap *soap, struct sgs__GetControl *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__GetControl(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__GetControl * SOAP_FMAC2 soap_in_sgs__GetControl(struct soap *soap, const char *tag, struct sgs__GetControl *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__GetControl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetControl, sizeof(struct sgs__GetControl), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__GetControl(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__GetControl *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetControl, sizeof(struct sgs__GetControl), 0), SOAP_TYPE_sgs__GetControl, sizeof(struct sgs__GetControl));
		if (soap->alloced)
			soap_default_sgs__GetControl(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__AppStop(struct soap *soap, struct sgs__AppStop const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__AppStop))
		soap_mark_sgs__AppStop(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__AppStop(struct soap *soap, const struct sgs__AppStop *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__AppStop(struct soap *soap, struct sgs__AppStop *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__AppStop(struct soap *soap, struct sgs__AppStop *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__AppStop, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__AppStop(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__AppStop(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__AppStop(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__AppStop(struct soap *soap, const char *tag, int id, const struct sgs__AppStop *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__AppStop), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__AppStop * SOAP_FMAC2 soap_get_sgs__AppStop(struct soap *soap, struct sgs__AppStop *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__AppStop(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__AppStop * SOAP_FMAC2 soap_in_sgs__AppStop(struct soap *soap, const char *tag, struct sgs__AppStop *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__AppStop *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppStop, sizeof(struct sgs__AppStop), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__AppStop(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__AppStop *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppStop, sizeof(struct sgs__AppStop), 0), SOAP_TYPE_sgs__AppStop, sizeof(struct sgs__AppStop));
		if (soap->alloced)
			soap_default_sgs__AppStop(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__PutStatus(struct soap *soap, struct sgs__PutStatus const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__PutStatus))
		soap_mark_sgs__PutStatus(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__PutStatus(struct soap *soap, const struct sgs__PutStatus *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__PutStatus(struct soap *soap, struct sgs__PutStatus *a)
{
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__PutStatus(struct soap *soap, struct sgs__PutStatus *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__PutStatus, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__PutStatus(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__PutStatus(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__PutStatus(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__PutStatus(struct soap *soap, const char *tag, int id, const struct sgs__PutStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__PutStatus), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__PutStatus * SOAP_FMAC2 soap_get_sgs__PutStatus(struct soap *soap, struct sgs__PutStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__PutStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__PutStatus * SOAP_FMAC2 soap_in_sgs__PutStatus(struct soap *soap, const char *tag, struct sgs__PutStatus *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__PutStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__PutStatus, sizeof(struct sgs__PutStatus), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__PutStatus(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__PutStatus *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__PutStatus, sizeof(struct sgs__PutStatus), 0), SOAP_TYPE_sgs__PutStatus, sizeof(struct sgs__PutStatus));
		if (soap->alloced)
			soap_default_sgs__PutStatus(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__AppDetach(struct soap *soap, struct sgs__AppDetach const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__AppDetach))
		soap_mark_sgs__AppDetach(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__AppDetach(struct soap *soap, const struct sgs__AppDetach *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__AppDetach(struct soap *soap, struct sgs__AppDetach *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__AppDetach(struct soap *soap, struct sgs__AppDetach *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__AppDetach, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__AppDetach(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__AppDetach(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__AppDetach(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__AppDetach(struct soap *soap, const char *tag, int id, const struct sgs__AppDetach *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__AppDetach), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__AppDetach * SOAP_FMAC2 soap_get_sgs__AppDetach(struct soap *soap, struct sgs__AppDetach *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__AppDetach(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__AppDetach * SOAP_FMAC2 soap_in_sgs__AppDetach(struct soap *soap, const char *tag, struct sgs__AppDetach *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__AppDetach *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppDetach, sizeof(struct sgs__AppDetach), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__AppDetach(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__AppDetach *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppDetach, sizeof(struct sgs__AppDetach), 0), SOAP_TYPE_sgs__AppDetach, sizeof(struct sgs__AppDetach));
		if (soap->alloced)
			soap_default_sgs__AppDetach(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__destroy(struct soap *soap, struct sgs__destroy const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__destroy))
		soap_mark_sgs__destroy(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__destroy(struct soap *soap, const struct sgs__destroy *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__destroy(struct soap *soap, struct sgs__destroy *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__destroy(struct soap *soap, struct sgs__destroy *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__destroy, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__destroy(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__destroy(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__destroy(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__destroy(struct soap *soap, const char *tag, int id, const struct sgs__destroy *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__destroy), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__destroy * SOAP_FMAC2 soap_get_sgs__destroy(struct soap *soap, struct sgs__destroy *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__destroy(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__destroy * SOAP_FMAC2 soap_in_sgs__destroy(struct soap *soap, const char *tag, struct sgs__destroy *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__destroy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__destroy, sizeof(struct sgs__destroy), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__destroy(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__destroy *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__destroy, sizeof(struct sgs__destroy), 0), SOAP_TYPE_sgs__destroy, sizeof(struct sgs__destroy));
		if (soap->alloced)
			soap_default_sgs__destroy(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__setServiceData(struct soap *soap, struct sgs__setServiceData const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__setServiceData))
		soap_mark_sgs__setServiceData(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__setServiceData(struct soap *soap, const struct sgs__setServiceData *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__setServiceData(struct soap *soap, struct sgs__setServiceData *a)
{
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__setServiceData(struct soap *soap, struct sgs__setServiceData *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__setServiceData, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__setServiceData(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__setServiceData(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__setServiceData(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__setServiceData(struct soap *soap, const char *tag, int id, const struct sgs__setServiceData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__setServiceData), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__setServiceData * SOAP_FMAC2 soap_get_sgs__setServiceData(struct soap *soap, struct sgs__setServiceData *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__setServiceData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__setServiceData * SOAP_FMAC2 soap_in_sgs__setServiceData(struct soap *soap, const char *tag, struct sgs__setServiceData *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__setServiceData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__setServiceData, sizeof(struct sgs__setServiceData), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__setServiceData(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__setServiceData *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__setServiceData, sizeof(struct sgs__setServiceData), 0), SOAP_TYPE_sgs__setServiceData, sizeof(struct sgs__setServiceData));
		if (soap->alloced)
			soap_default_sgs__setServiceData(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__findServiceDataResponse(struct soap *soap, struct sgs__findServiceDataResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__findServiceDataResponse))
		soap_mark_sgs__findServiceDataResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__findServiceDataResponse(struct soap *soap, const struct sgs__findServiceDataResponse *a)
{
	soap_embedded(soap, &a->_findServiceDataReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_findServiceDataReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__findServiceDataResponse(struct soap *soap, struct sgs__findServiceDataResponse *a)
{
	soap_default_xsd__string(soap, &a->_findServiceDataReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__findServiceDataResponse(struct soap *soap, struct sgs__findServiceDataResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__findServiceDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__findServiceDataResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__findServiceDataResponse(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__findServiceDataResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__findServiceDataResponse(struct soap *soap, const char *tag, int id, const struct sgs__findServiceDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__findServiceDataResponse), type);
	soap_out_xsd__string(soap, "findServiceDataReturn", -1, &a->_findServiceDataReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__findServiceDataResponse * SOAP_FMAC2 soap_get_sgs__findServiceDataResponse(struct soap *soap, struct sgs__findServiceDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__findServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__findServiceDataResponse * SOAP_FMAC2 soap_in_sgs__findServiceDataResponse(struct soap *soap, const char *tag, struct sgs__findServiceDataResponse *a, const char *type)
{
	short soap_flag__findServiceDataReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__findServiceDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__findServiceDataResponse, sizeof(struct sgs__findServiceDataResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__findServiceDataResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__findServiceDataReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_findServiceDataReturn, "xsd:string"))
				{	soap_flag__findServiceDataReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__findServiceDataResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__findServiceDataResponse, sizeof(struct sgs__findServiceDataResponse), 0), SOAP_TYPE_sgs__findServiceDataResponse, sizeof(struct sgs__findServiceDataResponse));
		if (soap->alloced)
			soap_default_sgs__findServiceDataResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__setServiceDataResponse(struct soap *soap, struct sgs__setServiceDataResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__setServiceDataResponse))
		soap_mark_sgs__setServiceDataResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__setServiceDataResponse(struct soap *soap, const struct sgs__setServiceDataResponse *a)
{
	soap_embedded(soap, &a->_setServiceDataReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_setServiceDataReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__setServiceDataResponse(struct soap *soap, struct sgs__setServiceDataResponse *a)
{
	soap_default_xsd__string(soap, &a->_setServiceDataReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__setServiceDataResponse(struct soap *soap, struct sgs__setServiceDataResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__setServiceDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__setServiceDataResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__setServiceDataResponse(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__setServiceDataResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__setServiceDataResponse(struct soap *soap, const char *tag, int id, const struct sgs__setServiceDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__setServiceDataResponse), type);
	soap_out_xsd__string(soap, "setServiceDataReturn", -1, &a->_setServiceDataReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__setServiceDataResponse * SOAP_FMAC2 soap_get_sgs__setServiceDataResponse(struct soap *soap, struct sgs__setServiceDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__setServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__setServiceDataResponse * SOAP_FMAC2 soap_in_sgs__setServiceDataResponse(struct soap *soap, const char *tag, struct sgs__setServiceDataResponse *a, const char *type)
{
	short soap_flag__setServiceDataReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__setServiceDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__setServiceDataResponse, sizeof(struct sgs__setServiceDataResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__setServiceDataResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__setServiceDataReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_setServiceDataReturn, "xsd:string"))
				{	soap_flag__setServiceDataReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__setServiceDataResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__setServiceDataResponse, sizeof(struct sgs__setServiceDataResponse), 0), SOAP_TYPE_sgs__setServiceDataResponse, sizeof(struct sgs__setServiceDataResponse));
		if (soap->alloced)
			soap_default_sgs__setServiceDataResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__ResumeResponse(struct soap *soap, struct sgs__ResumeResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__ResumeResponse))
		soap_mark_sgs__ResumeResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__ResumeResponse(struct soap *soap, const struct sgs__ResumeResponse *a)
{
	soap_embedded(soap, &a->_ResumeReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_ResumeReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__ResumeResponse(struct soap *soap, struct sgs__ResumeResponse *a)
{
	soap_default_xsd__string(soap, &a->_ResumeReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__ResumeResponse(struct soap *soap, struct sgs__ResumeResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__ResumeResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__ResumeResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__ResumeResponse(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__ResumeResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__ResumeResponse(struct soap *soap, const char *tag, int id, const struct sgs__ResumeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__ResumeResponse), type);
	soap_out_xsd__string(soap, "ResumeReturn", -1, &a->_ResumeReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__ResumeResponse * SOAP_FMAC2 soap_get_sgs__ResumeResponse(struct soap *soap, struct sgs__ResumeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__ResumeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__ResumeResponse * SOAP_FMAC2 soap_in_sgs__ResumeResponse(struct soap *soap, const char *tag, struct sgs__ResumeResponse *a, const char *type)
{
	short soap_flag__ResumeReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__ResumeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__ResumeResponse, sizeof(struct sgs__ResumeResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__ResumeResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__ResumeReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_ResumeReturn, "xsd:string"))
				{	soap_flag__ResumeReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__ResumeResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__ResumeResponse, sizeof(struct sgs__ResumeResponse), 0), SOAP_TYPE_sgs__ResumeResponse, sizeof(struct sgs__ResumeResponse));
		if (soap->alloced)
			soap_default_sgs__ResumeResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__AttachResponse(struct soap *soap, struct sgs__AttachResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__AttachResponse))
		soap_mark_sgs__AttachResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__AttachResponse(struct soap *soap, const struct sgs__AttachResponse *a)
{
	soap_embedded(soap, &a->_AttachReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_AttachReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__AttachResponse(struct soap *soap, struct sgs__AttachResponse *a)
{
	soap_default_xsd__string(soap, &a->_AttachReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__AttachResponse(struct soap *soap, struct sgs__AttachResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__AttachResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__AttachResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__AttachResponse(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__AttachResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__AttachResponse(struct soap *soap, const char *tag, int id, const struct sgs__AttachResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__AttachResponse), type);
	soap_out_xsd__string(soap, "AttachReturn", -1, &a->_AttachReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__AttachResponse * SOAP_FMAC2 soap_get_sgs__AttachResponse(struct soap *soap, struct sgs__AttachResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__AttachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__AttachResponse * SOAP_FMAC2 soap_in_sgs__AttachResponse(struct soap *soap, const char *tag, struct sgs__AttachResponse *a, const char *type)
{
	short soap_flag__AttachReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__AttachResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AttachResponse, sizeof(struct sgs__AttachResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__AttachResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__AttachReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_AttachReturn, "xsd:string"))
				{	soap_flag__AttachReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__AttachResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AttachResponse, sizeof(struct sgs__AttachResponse), 0), SOAP_TYPE_sgs__AttachResponse, sizeof(struct sgs__AttachResponse));
		if (soap->alloced)
			soap_default_sgs__AttachResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__GetControlResponse(struct soap *soap, struct sgs__GetControlResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__GetControlResponse))
		soap_mark_sgs__GetControlResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__GetControlResponse(struct soap *soap, const struct sgs__GetControlResponse *a)
{
	soap_embedded(soap, &a->_GetControlReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_GetControlReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__GetControlResponse(struct soap *soap, struct sgs__GetControlResponse *a)
{
	soap_default_xsd__string(soap, &a->_GetControlReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__GetControlResponse(struct soap *soap, struct sgs__GetControlResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__GetControlResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__GetControlResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__GetControlResponse(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__GetControlResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__GetControlResponse(struct soap *soap, const char *tag, int id, const struct sgs__GetControlResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__GetControlResponse), type);
	soap_out_xsd__string(soap, "GetControlReturn", -1, &a->_GetControlReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__GetControlResponse * SOAP_FMAC2 soap_get_sgs__GetControlResponse(struct soap *soap, struct sgs__GetControlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__GetControlResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__GetControlResponse * SOAP_FMAC2 soap_in_sgs__GetControlResponse(struct soap *soap, const char *tag, struct sgs__GetControlResponse *a, const char *type)
{
	short soap_flag__GetControlReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__GetControlResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetControlResponse, sizeof(struct sgs__GetControlResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__GetControlResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetControlReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_GetControlReturn, "xsd:string"))
				{	soap_flag__GetControlReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__GetControlResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetControlResponse, sizeof(struct sgs__GetControlResponse), 0), SOAP_TYPE_sgs__GetControlResponse, sizeof(struct sgs__GetControlResponse));
		if (soap->alloced)
			soap_default_sgs__GetControlResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__GetNotificationsResponse(struct soap *soap, struct sgs__GetNotificationsResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__GetNotificationsResponse))
		soap_mark_sgs__GetNotificationsResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__GetNotificationsResponse(struct soap *soap, const struct sgs__GetNotificationsResponse *a)
{
	soap_embedded(soap, &a->_GetNotificationsReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_GetNotificationsReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__GetNotificationsResponse(struct soap *soap, struct sgs__GetNotificationsResponse *a)
{
	soap_default_xsd__string(soap, &a->_GetNotificationsReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__GetNotificationsResponse(struct soap *soap, struct sgs__GetNotificationsResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__GetNotificationsResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__GetNotificationsResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__GetNotificationsResponse(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__GetNotificationsResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__GetNotificationsResponse(struct soap *soap, const char *tag, int id, const struct sgs__GetNotificationsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__GetNotificationsResponse), type);
	soap_out_xsd__string(soap, "GetNotificationsReturn", -1, &a->_GetNotificationsReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__GetNotificationsResponse * SOAP_FMAC2 soap_get_sgs__GetNotificationsResponse(struct soap *soap, struct sgs__GetNotificationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__GetNotificationsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__GetNotificationsResponse * SOAP_FMAC2 soap_in_sgs__GetNotificationsResponse(struct soap *soap, const char *tag, struct sgs__GetNotificationsResponse *a, const char *type)
{
	short soap_flag__GetNotificationsReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__GetNotificationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetNotificationsResponse, sizeof(struct sgs__GetNotificationsResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__GetNotificationsResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetNotificationsReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_GetNotificationsReturn, "xsd:string"))
				{	soap_flag__GetNotificationsReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__GetNotificationsResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetNotificationsResponse, sizeof(struct sgs__GetNotificationsResponse), 0), SOAP_TYPE_sgs__GetNotificationsResponse, sizeof(struct sgs__GetNotificationsResponse));
		if (soap->alloced)
			soap_default_sgs__GetNotificationsResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__ClearStatusMsgQueueResponse(struct soap *soap, struct sgs__ClearStatusMsgQueueResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__ClearStatusMsgQueueResponse))
		soap_mark_sgs__ClearStatusMsgQueueResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__ClearStatusMsgQueueResponse(struct soap *soap, const struct sgs__ClearStatusMsgQueueResponse *a)
{
	soap_embedded(soap, &a->_ClearStatusMsgQueueReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_ClearStatusMsgQueueReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__ClearStatusMsgQueueResponse(struct soap *soap, struct sgs__ClearStatusMsgQueueResponse *a)
{
	soap_default_xsd__string(soap, &a->_ClearStatusMsgQueueReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__ClearStatusMsgQueueResponse(struct soap *soap, struct sgs__ClearStatusMsgQueueResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__ClearStatusMsgQueueResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__ClearStatusMsgQueueResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__ClearStatusMsgQueueResponse(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__ClearStatusMsgQueueResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__ClearStatusMsgQueueResponse(struct soap *soap, const char *tag, int id, const struct sgs__ClearStatusMsgQueueResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__ClearStatusMsgQueueResponse), type);
	soap_out_xsd__string(soap, "ClearStatusMsgQueueReturn", -1, &a->_ClearStatusMsgQueueReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__ClearStatusMsgQueueResponse * SOAP_FMAC2 soap_get_sgs__ClearStatusMsgQueueResponse(struct soap *soap, struct sgs__ClearStatusMsgQueueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__ClearStatusMsgQueueResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__ClearStatusMsgQueueResponse * SOAP_FMAC2 soap_in_sgs__ClearStatusMsgQueueResponse(struct soap *soap, const char *tag, struct sgs__ClearStatusMsgQueueResponse *a, const char *type)
{
	short soap_flag__ClearStatusMsgQueueReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__ClearStatusMsgQueueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__ClearStatusMsgQueueResponse, sizeof(struct sgs__ClearStatusMsgQueueResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__ClearStatusMsgQueueResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__ClearStatusMsgQueueReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_ClearStatusMsgQueueReturn, "xsd:string"))
				{	soap_flag__ClearStatusMsgQueueReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__ClearStatusMsgQueueResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__ClearStatusMsgQueueResponse, sizeof(struct sgs__ClearStatusMsgQueueResponse), 0), SOAP_TYPE_sgs__ClearStatusMsgQueueResponse, sizeof(struct sgs__ClearStatusMsgQueueResponse));
		if (soap->alloced)
			soap_default_sgs__ClearStatusMsgQueueResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__DetachResponse(struct soap *soap, struct sgs__DetachResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__DetachResponse))
		soap_mark_sgs__DetachResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__DetachResponse(struct soap *soap, const struct sgs__DetachResponse *a)
{
	soap_embedded(soap, &a->_DetachReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_DetachReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__DetachResponse(struct soap *soap, struct sgs__DetachResponse *a)
{
	soap_default_xsd__string(soap, &a->_DetachReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__DetachResponse(struct soap *soap, struct sgs__DetachResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__DetachResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__DetachResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__DetachResponse(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__DetachResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__DetachResponse(struct soap *soap, const char *tag, int id, const struct sgs__DetachResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__DetachResponse), type);
	soap_out_xsd__string(soap, "DetachReturn", -1, &a->_DetachReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__DetachResponse * SOAP_FMAC2 soap_get_sgs__DetachResponse(struct soap *soap, struct sgs__DetachResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__DetachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__DetachResponse * SOAP_FMAC2 soap_in_sgs__DetachResponse(struct soap *soap, const char *tag, struct sgs__DetachResponse *a, const char *type)
{
	short soap_flag__DetachReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__DetachResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__DetachResponse, sizeof(struct sgs__DetachResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__DetachResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__DetachReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_DetachReturn, "xsd:string"))
				{	soap_flag__DetachReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__DetachResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__DetachResponse, sizeof(struct sgs__DetachResponse), 0), SOAP_TYPE_sgs__DetachResponse, sizeof(struct sgs__DetachResponse));
		if (soap->alloced)
			soap_default_sgs__DetachResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__PutStatusResponse(struct soap *soap, struct sgs__PutStatusResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__PutStatusResponse))
		soap_mark_sgs__PutStatusResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__PutStatusResponse(struct soap *soap, const struct sgs__PutStatusResponse *a)
{
	soap_embedded(soap, &a->_PutStatusReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_PutStatusReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__PutStatusResponse(struct soap *soap, struct sgs__PutStatusResponse *a)
{
	soap_default_xsd__string(soap, &a->_PutStatusReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__PutStatusResponse(struct soap *soap, struct sgs__PutStatusResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__PutStatusResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__PutStatusResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__PutStatusResponse(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__PutStatusResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__PutStatusResponse(struct soap *soap, const char *tag, int id, const struct sgs__PutStatusResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__PutStatusResponse), type);
	soap_out_xsd__string(soap, "PutStatusReturn", -1, &a->_PutStatusReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__PutStatusResponse * SOAP_FMAC2 soap_get_sgs__PutStatusResponse(struct soap *soap, struct sgs__PutStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__PutStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__PutStatusResponse * SOAP_FMAC2 soap_in_sgs__PutStatusResponse(struct soap *soap, const char *tag, struct sgs__PutStatusResponse *a, const char *type)
{
	short soap_flag__PutStatusReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__PutStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__PutStatusResponse, sizeof(struct sgs__PutStatusResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__PutStatusResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__PutStatusReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_PutStatusReturn, "xsd:string"))
				{	soap_flag__PutStatusReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__PutStatusResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__PutStatusResponse, sizeof(struct sgs__PutStatusResponse), 0), SOAP_TYPE_sgs__PutStatusResponse, sizeof(struct sgs__PutStatusResponse));
		if (soap->alloced)
			soap_default_sgs__PutStatusResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__destroyResponse(struct soap *soap, struct sgs__destroyResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__destroyResponse))
		soap_mark_sgs__destroyResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__destroyResponse(struct soap *soap, const struct sgs__destroyResponse *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__destroyResponse(struct soap *soap, struct sgs__destroyResponse *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__destroyResponse(struct soap *soap, struct sgs__destroyResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__destroyResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__destroyResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__destroyResponse(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__destroyResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__destroyResponse(struct soap *soap, const char *tag, int id, const struct sgs__destroyResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__destroyResponse), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__destroyResponse * SOAP_FMAC2 soap_get_sgs__destroyResponse(struct soap *soap, struct sgs__destroyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__destroyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__destroyResponse * SOAP_FMAC2 soap_in_sgs__destroyResponse(struct soap *soap, const char *tag, struct sgs__destroyResponse *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__destroyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__destroyResponse, sizeof(struct sgs__destroyResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__destroyResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__destroyResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__destroyResponse, sizeof(struct sgs__destroyResponse), 0), SOAP_TYPE_sgs__destroyResponse, sizeof(struct sgs__destroyResponse));
		if (soap->alloced)
			soap_default_sgs__destroyResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__AppStopResponse(struct soap *soap, struct sgs__AppStopResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__AppStopResponse))
		soap_mark_sgs__AppStopResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__AppStopResponse(struct soap *soap, const struct sgs__AppStopResponse *a)
{
	soap_embedded(soap, &a->_AppStopReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_AppStopReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__AppStopResponse(struct soap *soap, struct sgs__AppStopResponse *a)
{
	soap_default_xsd__string(soap, &a->_AppStopReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__AppStopResponse(struct soap *soap, struct sgs__AppStopResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__AppStopResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__AppStopResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__AppStopResponse(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__AppStopResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__AppStopResponse(struct soap *soap, const char *tag, int id, const struct sgs__AppStopResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__AppStopResponse), type);
	soap_out_xsd__string(soap, "AppStopReturn", -1, &a->_AppStopReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__AppStopResponse * SOAP_FMAC2 soap_get_sgs__AppStopResponse(struct soap *soap, struct sgs__AppStopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__AppStopResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__AppStopResponse * SOAP_FMAC2 soap_in_sgs__AppStopResponse(struct soap *soap, const char *tag, struct sgs__AppStopResponse *a, const char *type)
{
	short soap_flag__AppStopReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__AppStopResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppStopResponse, sizeof(struct sgs__AppStopResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__AppStopResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__AppStopReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_AppStopReturn, "xsd:string"))
				{	soap_flag__AppStopReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__AppStopResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppStopResponse, sizeof(struct sgs__AppStopResponse), 0), SOAP_TYPE_sgs__AppStopResponse, sizeof(struct sgs__AppStopResponse));
		if (soap->alloced)
			soap_default_sgs__AppStopResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__StopResponse(struct soap *soap, struct sgs__StopResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__StopResponse))
		soap_mark_sgs__StopResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__StopResponse(struct soap *soap, const struct sgs__StopResponse *a)
{
	soap_embedded(soap, &a->_StopReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_StopReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__StopResponse(struct soap *soap, struct sgs__StopResponse *a)
{
	soap_default_xsd__string(soap, &a->_StopReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__StopResponse(struct soap *soap, struct sgs__StopResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__StopResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__StopResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__StopResponse(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__StopResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__StopResponse(struct soap *soap, const char *tag, int id, const struct sgs__StopResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__StopResponse), type);
	soap_out_xsd__string(soap, "StopReturn", -1, &a->_StopReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__StopResponse * SOAP_FMAC2 soap_get_sgs__StopResponse(struct soap *soap, struct sgs__StopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__StopResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__StopResponse * SOAP_FMAC2 soap_in_sgs__StopResponse(struct soap *soap, const char *tag, struct sgs__StopResponse *a, const char *type)
{
	short soap_flag__StopReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__StopResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__StopResponse, sizeof(struct sgs__StopResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__StopResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__StopReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_StopReturn, "xsd:string"))
				{	soap_flag__StopReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__StopResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__StopResponse, sizeof(struct sgs__StopResponse), 0), SOAP_TYPE_sgs__StopResponse, sizeof(struct sgs__StopResponse));
		if (soap->alloced)
			soap_default_sgs__StopResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__PutControlResponse(struct soap *soap, struct sgs__PutControlResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__PutControlResponse))
		soap_mark_sgs__PutControlResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__PutControlResponse(struct soap *soap, const struct sgs__PutControlResponse *a)
{
	soap_embedded(soap, &a->_PutControlReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_PutControlReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__PutControlResponse(struct soap *soap, struct sgs__PutControlResponse *a)
{
	soap_default_xsd__string(soap, &a->_PutControlReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__PutControlResponse(struct soap *soap, struct sgs__PutControlResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__PutControlResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__PutControlResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__PutControlResponse(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__PutControlResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__PutControlResponse(struct soap *soap, const char *tag, int id, const struct sgs__PutControlResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__PutControlResponse), type);
	soap_out_xsd__string(soap, "PutControlReturn", -1, &a->_PutControlReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__PutControlResponse * SOAP_FMAC2 soap_get_sgs__PutControlResponse(struct soap *soap, struct sgs__PutControlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__PutControlResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__PutControlResponse * SOAP_FMAC2 soap_in_sgs__PutControlResponse(struct soap *soap, const char *tag, struct sgs__PutControlResponse *a, const char *type)
{
	short soap_flag__PutControlReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__PutControlResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__PutControlResponse, sizeof(struct sgs__PutControlResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__PutControlResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__PutControlReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_PutControlReturn, "xsd:string"))
				{	soap_flag__PutControlReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__PutControlResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__PutControlResponse, sizeof(struct sgs__PutControlResponse), 0), SOAP_TYPE_sgs__PutControlResponse, sizeof(struct sgs__PutControlResponse));
		if (soap->alloced)
			soap_default_sgs__PutControlResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__GetNthDataSourceResponse(struct soap *soap, struct sgs__GetNthDataSourceResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__GetNthDataSourceResponse))
		soap_mark_sgs__GetNthDataSourceResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__GetNthDataSourceResponse(struct soap *soap, const struct sgs__GetNthDataSourceResponse *a)
{
	soap_embedded(soap, &a->_GetNthDataSourceReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_GetNthDataSourceReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__GetNthDataSourceResponse(struct soap *soap, struct sgs__GetNthDataSourceResponse *a)
{
	soap_default_xsd__string(soap, &a->_GetNthDataSourceReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__GetNthDataSourceResponse(struct soap *soap, struct sgs__GetNthDataSourceResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__GetNthDataSourceResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__GetNthDataSourceResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__GetNthDataSourceResponse(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__GetNthDataSourceResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__GetNthDataSourceResponse(struct soap *soap, const char *tag, int id, const struct sgs__GetNthDataSourceResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__GetNthDataSourceResponse), type);
	soap_out_xsd__string(soap, "GetNthDataSourceReturn", -1, &a->_GetNthDataSourceReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__GetNthDataSourceResponse * SOAP_FMAC2 soap_get_sgs__GetNthDataSourceResponse(struct soap *soap, struct sgs__GetNthDataSourceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__GetNthDataSourceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__GetNthDataSourceResponse * SOAP_FMAC2 soap_in_sgs__GetNthDataSourceResponse(struct soap *soap, const char *tag, struct sgs__GetNthDataSourceResponse *a, const char *type)
{
	short soap_flag__GetNthDataSourceReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__GetNthDataSourceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetNthDataSourceResponse, sizeof(struct sgs__GetNthDataSourceResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__GetNthDataSourceResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetNthDataSourceReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_GetNthDataSourceReturn, "xsd:string"))
				{	soap_flag__GetNthDataSourceReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__GetNthDataSourceResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetNthDataSourceResponse, sizeof(struct sgs__GetNthDataSourceResponse), 0), SOAP_TYPE_sgs__GetNthDataSourceResponse, sizeof(struct sgs__GetNthDataSourceResponse));
		if (soap->alloced)
			soap_default_sgs__GetNthDataSourceResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__AppDetachResponse(struct soap *soap, struct sgs__AppDetachResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__AppDetachResponse))
		soap_mark_sgs__AppDetachResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__AppDetachResponse(struct soap *soap, const struct sgs__AppDetachResponse *a)
{
	soap_embedded(soap, &a->_AppDetachReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_AppDetachReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__AppDetachResponse(struct soap *soap, struct sgs__AppDetachResponse *a)
{
	soap_default_xsd__string(soap, &a->_AppDetachReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__AppDetachResponse(struct soap *soap, struct sgs__AppDetachResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__AppDetachResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__AppDetachResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__AppDetachResponse(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__AppDetachResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__AppDetachResponse(struct soap *soap, const char *tag, int id, const struct sgs__AppDetachResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__AppDetachResponse), type);
	soap_out_xsd__string(soap, "AppDetachReturn", -1, &a->_AppDetachReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__AppDetachResponse * SOAP_FMAC2 soap_get_sgs__AppDetachResponse(struct soap *soap, struct sgs__AppDetachResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__AppDetachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__AppDetachResponse * SOAP_FMAC2 soap_in_sgs__AppDetachResponse(struct soap *soap, const char *tag, struct sgs__AppDetachResponse *a, const char *type)
{
	short soap_flag__AppDetachReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__AppDetachResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppDetachResponse, sizeof(struct sgs__AppDetachResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__AppDetachResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__AppDetachReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_AppDetachReturn, "xsd:string"))
				{	soap_flag__AppDetachReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__AppDetachResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppDetachResponse, sizeof(struct sgs__AppDetachResponse), 0), SOAP_TYPE_sgs__AppDetachResponse, sizeof(struct sgs__AppDetachResponse));
		if (soap->alloced)
			soap_default_sgs__AppDetachResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__AppRecordChkpointResponse(struct soap *soap, struct sgs__AppRecordChkpointResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__AppRecordChkpointResponse))
		soap_mark_sgs__AppRecordChkpointResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__AppRecordChkpointResponse(struct soap *soap, const struct sgs__AppRecordChkpointResponse *a)
{
	soap_embedded(soap, &a->_AppRecordChkpointReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_AppRecordChkpointReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__AppRecordChkpointResponse(struct soap *soap, struct sgs__AppRecordChkpointResponse *a)
{
	soap_default_xsd__string(soap, &a->_AppRecordChkpointReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__AppRecordChkpointResponse(struct soap *soap, struct sgs__AppRecordChkpointResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__AppRecordChkpointResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__AppRecordChkpointResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__AppRecordChkpointResponse(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__AppRecordChkpointResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__AppRecordChkpointResponse(struct soap *soap, const char *tag, int id, const struct sgs__AppRecordChkpointResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__AppRecordChkpointResponse), type);
	soap_out_xsd__string(soap, "AppRecordChkpointReturn", -1, &a->_AppRecordChkpointReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__AppRecordChkpointResponse * SOAP_FMAC2 soap_get_sgs__AppRecordChkpointResponse(struct soap *soap, struct sgs__AppRecordChkpointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__AppRecordChkpointResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__AppRecordChkpointResponse * SOAP_FMAC2 soap_in_sgs__AppRecordChkpointResponse(struct soap *soap, const char *tag, struct sgs__AppRecordChkpointResponse *a, const char *type)
{
	short soap_flag__AppRecordChkpointReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__AppRecordChkpointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppRecordChkpointResponse, sizeof(struct sgs__AppRecordChkpointResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__AppRecordChkpointResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__AppRecordChkpointReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_AppRecordChkpointReturn, "xsd:string"))
				{	soap_flag__AppRecordChkpointReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__AppRecordChkpointResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppRecordChkpointResponse, sizeof(struct sgs__AppRecordChkpointResponse), 0), SOAP_TYPE_sgs__AppRecordChkpointResponse, sizeof(struct sgs__AppRecordChkpointResponse));
		if (soap->alloced)
			soap_default_sgs__AppRecordChkpointResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__RestartResponse(struct soap *soap, struct sgs__RestartResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__RestartResponse))
		soap_mark_sgs__RestartResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__RestartResponse(struct soap *soap, const struct sgs__RestartResponse *a)
{
	soap_embedded(soap, &a->_RestartReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_RestartReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__RestartResponse(struct soap *soap, struct sgs__RestartResponse *a)
{
	soap_default_xsd__string(soap, &a->_RestartReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__RestartResponse(struct soap *soap, struct sgs__RestartResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__RestartResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__RestartResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__RestartResponse(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__RestartResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__RestartResponse(struct soap *soap, const char *tag, int id, const struct sgs__RestartResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__RestartResponse), type);
	soap_out_xsd__string(soap, "RestartReturn", -1, &a->_RestartReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__RestartResponse * SOAP_FMAC2 soap_get_sgs__RestartResponse(struct soap *soap, struct sgs__RestartResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__RestartResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__RestartResponse * SOAP_FMAC2 soap_in_sgs__RestartResponse(struct soap *soap, const char *tag, struct sgs__RestartResponse *a, const char *type)
{
	short soap_flag__RestartReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__RestartResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__RestartResponse, sizeof(struct sgs__RestartResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__RestartResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__RestartReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_RestartReturn, "xsd:string"))
				{	soap_flag__RestartReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__RestartResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__RestartResponse, sizeof(struct sgs__RestartResponse), 0), SOAP_TYPE_sgs__RestartResponse, sizeof(struct sgs__RestartResponse));
		if (soap->alloced)
			soap_default_sgs__RestartResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__AppStartResponse(struct soap *soap, struct sgs__AppStartResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__AppStartResponse))
		soap_mark_sgs__AppStartResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__AppStartResponse(struct soap *soap, const struct sgs__AppStartResponse *a)
{
	soap_embedded(soap, &a->_AppStartReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_AppStartReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__AppStartResponse(struct soap *soap, struct sgs__AppStartResponse *a)
{
	soap_default_xsd__string(soap, &a->_AppStartReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__AppStartResponse(struct soap *soap, struct sgs__AppStartResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__AppStartResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__AppStartResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__AppStartResponse(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__AppStartResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__AppStartResponse(struct soap *soap, const char *tag, int id, const struct sgs__AppStartResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__AppStartResponse), type);
	soap_out_xsd__string(soap, "AppStartReturn", -1, &a->_AppStartReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__AppStartResponse * SOAP_FMAC2 soap_get_sgs__AppStartResponse(struct soap *soap, struct sgs__AppStartResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__AppStartResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__AppStartResponse * SOAP_FMAC2 soap_in_sgs__AppStartResponse(struct soap *soap, const char *tag, struct sgs__AppStartResponse *a, const char *type)
{
	short soap_flag__AppStartReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__AppStartResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppStartResponse, sizeof(struct sgs__AppStartResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__AppStartResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__AppStartReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_AppStartReturn, "xsd:string"))
				{	soap_flag__AppStartReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__AppStartResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__AppStartResponse, sizeof(struct sgs__AppStartResponse), 0), SOAP_TYPE_sgs__AppStartResponse, sizeof(struct sgs__AppStartResponse));
		if (soap->alloced)
			soap_default_sgs__AppStartResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__PauseResponse(struct soap *soap, struct sgs__PauseResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__PauseResponse))
		soap_mark_sgs__PauseResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__PauseResponse(struct soap *soap, const struct sgs__PauseResponse *a)
{
	soap_embedded(soap, &a->_PauseReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_PauseReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__PauseResponse(struct soap *soap, struct sgs__PauseResponse *a)
{
	soap_default_xsd__string(soap, &a->_PauseReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__PauseResponse(struct soap *soap, struct sgs__PauseResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__PauseResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__PauseResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__PauseResponse(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__PauseResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__PauseResponse(struct soap *soap, const char *tag, int id, const struct sgs__PauseResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__PauseResponse), type);
	soap_out_xsd__string(soap, "PauseReturn", -1, &a->_PauseReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__PauseResponse * SOAP_FMAC2 soap_get_sgs__PauseResponse(struct soap *soap, struct sgs__PauseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__PauseResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__PauseResponse * SOAP_FMAC2 soap_in_sgs__PauseResponse(struct soap *soap, const char *tag, struct sgs__PauseResponse *a, const char *type)
{
	short soap_flag__PauseReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__PauseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__PauseResponse, sizeof(struct sgs__PauseResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__PauseResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__PauseReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_PauseReturn, "xsd:string"))
				{	soap_flag__PauseReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__PauseResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__PauseResponse, sizeof(struct sgs__PauseResponse), 0), SOAP_TYPE_sgs__PauseResponse, sizeof(struct sgs__PauseResponse));
		if (soap->alloced)
			soap_default_sgs__PauseResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_sgs__GetStatusResponse(struct soap *soap, struct sgs__GetStatusResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_sgs__GetStatusResponse))
		soap_mark_sgs__GetStatusResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_sgs__GetStatusResponse(struct soap *soap, const struct sgs__GetStatusResponse *a)
{
	soap_embedded(soap, &a->_GetStatusReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_GetStatusReturn);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_sgs__GetStatusResponse(struct soap *soap, struct sgs__GetStatusResponse *a)
{
	soap_default_xsd__string(soap, &a->_GetStatusReturn);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_sgs__GetStatusResponse(struct soap *soap, struct sgs__GetStatusResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_sgs__GetStatusResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_sgs__GetStatusResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_sgs__GetStatusResponse(soap, tag, i, a, type);
		}
	else
		soap_out_sgs__GetStatusResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_sgs__GetStatusResponse(struct soap *soap, const char *tag, int id, const struct sgs__GetStatusResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sgs__GetStatusResponse), type);
	soap_out_xsd__string(soap, "GetStatusReturn", -1, &a->_GetStatusReturn, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__GetStatusResponse * SOAP_FMAC2 soap_get_sgs__GetStatusResponse(struct soap *soap, struct sgs__GetStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_sgs__GetStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__GetStatusResponse * SOAP_FMAC2 soap_in_sgs__GetStatusResponse(struct soap *soap, const char *tag, struct sgs__GetStatusResponse *a, const char *type)
{
	short soap_flag__GetStatusReturn = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct sgs__GetStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetStatusResponse, sizeof(struct sgs__GetStatusResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_sgs__GetStatusResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetStatusReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_GetStatusReturn, "xsd:string"))
				{	soap_flag__GetStatusReturn = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct sgs__GetStatusResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sgs__GetStatusResponse, sizeof(struct sgs__GetStatusResponse), 0), SOAP_TYPE_sgs__GetStatusResponse, sizeof(struct sgs__GetStatusResponse));
		if (soap->alloced)
			soap_default_sgs__GetStatusResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerToSOAP_ENV__Code))
		soap_mark_PointerToSOAP_ENV__Code(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_mark_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerToSOAP_ENV__Code, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerToSOAP_ENV__Code(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerToSOAP_ENV__Code(soap, tag, i, a, type);
		}
	else
		soap_out_PointerToSOAP_ENV__Code(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_SOAP_ENV__Code, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_SOAP_ENV__Code(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_SOAP_ENV__Code(soap, tag, i, *a, type);
			}
		else
			soap_out_SOAP_ENV__Code(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_SOAP_ENV__Code, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct SOAP_ENV__Code ** SOAP_FMAC2 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code ** SOAP_FMAC2 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	struct SOAP_ENV__Code *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct SOAP_ENV__Code **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToSOAP_ENV__Code, sizeof(struct SOAP_ENV__Code *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_SOAP_ENV__Code(soap, tag, NULL, type)))
		{	a = (struct SOAP_ENV__Code **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerToSOAP_ENV__Code, sizeof(struct SOAP_ENV__Code *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToSOAP_ENV__Code, sizeof(struct SOAP_ENV__Code *), 1), SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTorgt__addNodeResponse(struct soap *soap, struct rgt__addNodeResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTorgt__addNodeResponse))
		soap_mark_PointerTorgt__addNodeResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTorgt__addNodeResponse(struct soap *soap, struct rgt__addNodeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgt__addNodeResponse))
		soap_mark_rgt__addNodeResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTorgt__addNodeResponse(struct soap *soap, struct rgt__addNodeResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTorgt__addNodeResponse(struct soap *soap, struct rgt__addNodeResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTorgt__addNodeResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTorgt__addNodeResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTorgt__addNodeResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTorgt__addNodeResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTorgt__addNodeResponse(struct soap *soap, const char *tag, int id, struct rgt__addNodeResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTorgt__addNodeResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_rgt__addNodeResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_rgt__addNodeResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_rgt__addNodeResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_rgt__addNodeResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_rgt__addNodeResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__addNodeResponse ** SOAP_FMAC2 soap_get_PointerTorgt__addNodeResponse(struct soap *soap, struct rgt__addNodeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgt__addNodeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__addNodeResponse ** SOAP_FMAC2 soap_in_PointerTorgt__addNodeResponse(struct soap *soap, const char *tag, struct rgt__addNodeResponse **a, const char *type)
{
	struct rgt__addNodeResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct rgt__addNodeResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgt__addNodeResponse, sizeof(struct rgt__addNodeResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_rgt__addNodeResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_rgt__addNodeResponse(soap, tag, NULL, type)))
		{	a = (struct rgt__addNodeResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTorgt__addNodeResponse, sizeof(struct rgt__addNodeResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct rgt__addNodeResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgt__addNodeResponse, sizeof(struct rgt__addNodeResponse *), 1), SOAP_TYPE_rgt__addNodeResponse, sizeof(struct rgt__addNodeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTorgt__getParentNodeResponse(struct soap *soap, struct rgt__getParentNodeResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTorgt__getParentNodeResponse))
		soap_mark_PointerTorgt__getParentNodeResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTorgt__getParentNodeResponse(struct soap *soap, struct rgt__getParentNodeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgt__getParentNodeResponse))
		soap_mark_rgt__getParentNodeResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTorgt__getParentNodeResponse(struct soap *soap, struct rgt__getParentNodeResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTorgt__getParentNodeResponse(struct soap *soap, struct rgt__getParentNodeResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTorgt__getParentNodeResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTorgt__getParentNodeResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTorgt__getParentNodeResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTorgt__getParentNodeResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTorgt__getParentNodeResponse(struct soap *soap, const char *tag, int id, struct rgt__getParentNodeResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTorgt__getParentNodeResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_rgt__getParentNodeResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_rgt__getParentNodeResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_rgt__getParentNodeResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_rgt__getParentNodeResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_rgt__getParentNodeResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__getParentNodeResponse ** SOAP_FMAC2 soap_get_PointerTorgt__getParentNodeResponse(struct soap *soap, struct rgt__getParentNodeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgt__getParentNodeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__getParentNodeResponse ** SOAP_FMAC2 soap_in_PointerTorgt__getParentNodeResponse(struct soap *soap, const char *tag, struct rgt__getParentNodeResponse **a, const char *type)
{
	struct rgt__getParentNodeResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct rgt__getParentNodeResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgt__getParentNodeResponse, sizeof(struct rgt__getParentNodeResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_rgt__getParentNodeResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_rgt__getParentNodeResponse(soap, tag, NULL, type)))
		{	a = (struct rgt__getParentNodeResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTorgt__getParentNodeResponse, sizeof(struct rgt__getParentNodeResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct rgt__getParentNodeResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgt__getParentNodeResponse, sizeof(struct rgt__getParentNodeResponse *), 1), SOAP_TYPE_rgt__getParentNodeResponse, sizeof(struct rgt__getParentNodeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTorgt__getCheckPointDataResponse(struct soap *soap, struct rgt__getCheckPointDataResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTorgt__getCheckPointDataResponse))
		soap_mark_PointerTorgt__getCheckPointDataResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTorgt__getCheckPointDataResponse(struct soap *soap, struct rgt__getCheckPointDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgt__getCheckPointDataResponse))
		soap_mark_rgt__getCheckPointDataResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTorgt__getCheckPointDataResponse(struct soap *soap, struct rgt__getCheckPointDataResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTorgt__getCheckPointDataResponse(struct soap *soap, struct rgt__getCheckPointDataResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTorgt__getCheckPointDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTorgt__getCheckPointDataResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTorgt__getCheckPointDataResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTorgt__getCheckPointDataResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTorgt__getCheckPointDataResponse(struct soap *soap, const char *tag, int id, struct rgt__getCheckPointDataResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTorgt__getCheckPointDataResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_rgt__getCheckPointDataResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_rgt__getCheckPointDataResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_rgt__getCheckPointDataResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_rgt__getCheckPointDataResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_rgt__getCheckPointDataResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__getCheckPointDataResponse ** SOAP_FMAC2 soap_get_PointerTorgt__getCheckPointDataResponse(struct soap *soap, struct rgt__getCheckPointDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgt__getCheckPointDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__getCheckPointDataResponse ** SOAP_FMAC2 soap_in_PointerTorgt__getCheckPointDataResponse(struct soap *soap, const char *tag, struct rgt__getCheckPointDataResponse **a, const char *type)
{
	struct rgt__getCheckPointDataResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct rgt__getCheckPointDataResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgt__getCheckPointDataResponse, sizeof(struct rgt__getCheckPointDataResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_rgt__getCheckPointDataResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_rgt__getCheckPointDataResponse(soap, tag, NULL, type)))
		{	a = (struct rgt__getCheckPointDataResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTorgt__getCheckPointDataResponse, sizeof(struct rgt__getCheckPointDataResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct rgt__getCheckPointDataResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgt__getCheckPointDataResponse, sizeof(struct rgt__getCheckPointDataResponse *), 1), SOAP_TYPE_rgt__getCheckPointDataResponse, sizeof(struct rgt__getCheckPointDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTorgt__requestTerminationBeforeResponse(struct soap *soap, struct rgt__requestTerminationBeforeResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTorgt__requestTerminationBeforeResponse))
		soap_mark_PointerTorgt__requestTerminationBeforeResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTorgt__requestTerminationBeforeResponse(struct soap *soap, struct rgt__requestTerminationBeforeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgt__requestTerminationBeforeResponse))
		soap_mark_rgt__requestTerminationBeforeResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTorgt__requestTerminationBeforeResponse(struct soap *soap, struct rgt__requestTerminationBeforeResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTorgt__requestTerminationBeforeResponse(struct soap *soap, struct rgt__requestTerminationBeforeResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTorgt__requestTerminationBeforeResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTorgt__requestTerminationBeforeResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTorgt__requestTerminationBeforeResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTorgt__requestTerminationBeforeResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTorgt__requestTerminationBeforeResponse(struct soap *soap, const char *tag, int id, struct rgt__requestTerminationBeforeResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTorgt__requestTerminationBeforeResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_rgt__requestTerminationBeforeResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_rgt__requestTerminationBeforeResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_rgt__requestTerminationBeforeResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_rgt__requestTerminationBeforeResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_rgt__requestTerminationBeforeResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__requestTerminationBeforeResponse ** SOAP_FMAC2 soap_get_PointerTorgt__requestTerminationBeforeResponse(struct soap *soap, struct rgt__requestTerminationBeforeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgt__requestTerminationBeforeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__requestTerminationBeforeResponse ** SOAP_FMAC2 soap_in_PointerTorgt__requestTerminationBeforeResponse(struct soap *soap, const char *tag, struct rgt__requestTerminationBeforeResponse **a, const char *type)
{
	struct rgt__requestTerminationBeforeResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct rgt__requestTerminationBeforeResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgt__requestTerminationBeforeResponse, sizeof(struct rgt__requestTerminationBeforeResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_rgt__requestTerminationBeforeResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_rgt__requestTerminationBeforeResponse(soap, tag, NULL, type)))
		{	a = (struct rgt__requestTerminationBeforeResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTorgt__requestTerminationBeforeResponse, sizeof(struct rgt__requestTerminationBeforeResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct rgt__requestTerminationBeforeResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgt__requestTerminationBeforeResponse, sizeof(struct rgt__requestTerminationBeforeResponse *), 1), SOAP_TYPE_rgt__requestTerminationBeforeResponse, sizeof(struct rgt__requestTerminationBeforeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTorgt__getSteeringCommandsResponse(struct soap *soap, struct rgt__getSteeringCommandsResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTorgt__getSteeringCommandsResponse))
		soap_mark_PointerTorgt__getSteeringCommandsResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTorgt__getSteeringCommandsResponse(struct soap *soap, struct rgt__getSteeringCommandsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgt__getSteeringCommandsResponse))
		soap_mark_rgt__getSteeringCommandsResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTorgt__getSteeringCommandsResponse(struct soap *soap, struct rgt__getSteeringCommandsResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTorgt__getSteeringCommandsResponse(struct soap *soap, struct rgt__getSteeringCommandsResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTorgt__getSteeringCommandsResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTorgt__getSteeringCommandsResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTorgt__getSteeringCommandsResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTorgt__getSteeringCommandsResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTorgt__getSteeringCommandsResponse(struct soap *soap, const char *tag, int id, struct rgt__getSteeringCommandsResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTorgt__getSteeringCommandsResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_rgt__getSteeringCommandsResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_rgt__getSteeringCommandsResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_rgt__getSteeringCommandsResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_rgt__getSteeringCommandsResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_rgt__getSteeringCommandsResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__getSteeringCommandsResponse ** SOAP_FMAC2 soap_get_PointerTorgt__getSteeringCommandsResponse(struct soap *soap, struct rgt__getSteeringCommandsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgt__getSteeringCommandsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__getSteeringCommandsResponse ** SOAP_FMAC2 soap_in_PointerTorgt__getSteeringCommandsResponse(struct soap *soap, const char *tag, struct rgt__getSteeringCommandsResponse **a, const char *type)
{
	struct rgt__getSteeringCommandsResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct rgt__getSteeringCommandsResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgt__getSteeringCommandsResponse, sizeof(struct rgt__getSteeringCommandsResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_rgt__getSteeringCommandsResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_rgt__getSteeringCommandsResponse(soap, tag, NULL, type)))
		{	a = (struct rgt__getSteeringCommandsResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTorgt__getSteeringCommandsResponse, sizeof(struct rgt__getSteeringCommandsResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct rgt__getSteeringCommandsResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgt__getSteeringCommandsResponse, sizeof(struct rgt__getSteeringCommandsResponse *), 1), SOAP_TYPE_rgt__getSteeringCommandsResponse, sizeof(struct rgt__getSteeringCommandsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTorgt__destroyResponse(struct soap *soap, struct rgt__destroyResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTorgt__destroyResponse))
		soap_mark_PointerTorgt__destroyResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTorgt__destroyResponse(struct soap *soap, struct rgt__destroyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgt__destroyResponse))
		soap_mark_rgt__destroyResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTorgt__destroyResponse(struct soap *soap, struct rgt__destroyResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTorgt__destroyResponse(struct soap *soap, struct rgt__destroyResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTorgt__destroyResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTorgt__destroyResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTorgt__destroyResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTorgt__destroyResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTorgt__destroyResponse(struct soap *soap, const char *tag, int id, struct rgt__destroyResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTorgt__destroyResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_rgt__destroyResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_rgt__destroyResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_rgt__destroyResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_rgt__destroyResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_rgt__destroyResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__destroyResponse ** SOAP_FMAC2 soap_get_PointerTorgt__destroyResponse(struct soap *soap, struct rgt__destroyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgt__destroyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__destroyResponse ** SOAP_FMAC2 soap_in_PointerTorgt__destroyResponse(struct soap *soap, const char *tag, struct rgt__destroyResponse **a, const char *type)
{
	struct rgt__destroyResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct rgt__destroyResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgt__destroyResponse, sizeof(struct rgt__destroyResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_rgt__destroyResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_rgt__destroyResponse(soap, tag, NULL, type)))
		{	a = (struct rgt__destroyResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTorgt__destroyResponse, sizeof(struct rgt__destroyResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct rgt__destroyResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgt__destroyResponse, sizeof(struct rgt__destroyResponse *), 1), SOAP_TYPE_rgt__destroyResponse, sizeof(struct rgt__destroyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTorgt__setCheckPointDataResponse(struct soap *soap, struct rgt__setCheckPointDataResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTorgt__setCheckPointDataResponse))
		soap_mark_PointerTorgt__setCheckPointDataResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTorgt__setCheckPointDataResponse(struct soap *soap, struct rgt__setCheckPointDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgt__setCheckPointDataResponse))
		soap_mark_rgt__setCheckPointDataResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTorgt__setCheckPointDataResponse(struct soap *soap, struct rgt__setCheckPointDataResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTorgt__setCheckPointDataResponse(struct soap *soap, struct rgt__setCheckPointDataResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTorgt__setCheckPointDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTorgt__setCheckPointDataResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTorgt__setCheckPointDataResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTorgt__setCheckPointDataResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTorgt__setCheckPointDataResponse(struct soap *soap, const char *tag, int id, struct rgt__setCheckPointDataResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTorgt__setCheckPointDataResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_rgt__setCheckPointDataResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_rgt__setCheckPointDataResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_rgt__setCheckPointDataResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_rgt__setCheckPointDataResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_rgt__setCheckPointDataResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__setCheckPointDataResponse ** SOAP_FMAC2 soap_get_PointerTorgt__setCheckPointDataResponse(struct soap *soap, struct rgt__setCheckPointDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgt__setCheckPointDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__setCheckPointDataResponse ** SOAP_FMAC2 soap_in_PointerTorgt__setCheckPointDataResponse(struct soap *soap, const char *tag, struct rgt__setCheckPointDataResponse **a, const char *type)
{
	struct rgt__setCheckPointDataResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct rgt__setCheckPointDataResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgt__setCheckPointDataResponse, sizeof(struct rgt__setCheckPointDataResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_rgt__setCheckPointDataResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_rgt__setCheckPointDataResponse(soap, tag, NULL, type)))
		{	a = (struct rgt__setCheckPointDataResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTorgt__setCheckPointDataResponse, sizeof(struct rgt__setCheckPointDataResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct rgt__setCheckPointDataResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgt__setCheckPointDataResponse, sizeof(struct rgt__setCheckPointDataResponse *), 1), SOAP_TYPE_rgt__setCheckPointDataResponse, sizeof(struct rgt__setCheckPointDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTorgt__findServiceDataResponse(struct soap *soap, struct rgt__findServiceDataResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTorgt__findServiceDataResponse))
		soap_mark_PointerTorgt__findServiceDataResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTorgt__findServiceDataResponse(struct soap *soap, struct rgt__findServiceDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgt__findServiceDataResponse))
		soap_mark_rgt__findServiceDataResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTorgt__findServiceDataResponse(struct soap *soap, struct rgt__findServiceDataResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTorgt__findServiceDataResponse(struct soap *soap, struct rgt__findServiceDataResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTorgt__findServiceDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTorgt__findServiceDataResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTorgt__findServiceDataResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTorgt__findServiceDataResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTorgt__findServiceDataResponse(struct soap *soap, const char *tag, int id, struct rgt__findServiceDataResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTorgt__findServiceDataResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_rgt__findServiceDataResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_rgt__findServiceDataResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_rgt__findServiceDataResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_rgt__findServiceDataResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_rgt__findServiceDataResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__findServiceDataResponse ** SOAP_FMAC2 soap_get_PointerTorgt__findServiceDataResponse(struct soap *soap, struct rgt__findServiceDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgt__findServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__findServiceDataResponse ** SOAP_FMAC2 soap_in_PointerTorgt__findServiceDataResponse(struct soap *soap, const char *tag, struct rgt__findServiceDataResponse **a, const char *type)
{
	struct rgt__findServiceDataResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct rgt__findServiceDataResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgt__findServiceDataResponse, sizeof(struct rgt__findServiceDataResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_rgt__findServiceDataResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_rgt__findServiceDataResponse(soap, tag, NULL, type)))
		{	a = (struct rgt__findServiceDataResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTorgt__findServiceDataResponse, sizeof(struct rgt__findServiceDataResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct rgt__findServiceDataResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgt__findServiceDataResponse, sizeof(struct rgt__findServiceDataResponse *), 1), SOAP_TYPE_rgt__findServiceDataResponse, sizeof(struct rgt__findServiceDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTorgt__getInputFileResponse(struct soap *soap, struct rgt__getInputFileResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTorgt__getInputFileResponse))
		soap_mark_PointerTorgt__getInputFileResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTorgt__getInputFileResponse(struct soap *soap, struct rgt__getInputFileResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgt__getInputFileResponse))
		soap_mark_rgt__getInputFileResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTorgt__getInputFileResponse(struct soap *soap, struct rgt__getInputFileResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTorgt__getInputFileResponse(struct soap *soap, struct rgt__getInputFileResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTorgt__getInputFileResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTorgt__getInputFileResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTorgt__getInputFileResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTorgt__getInputFileResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTorgt__getInputFileResponse(struct soap *soap, const char *tag, int id, struct rgt__getInputFileResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTorgt__getInputFileResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_rgt__getInputFileResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_rgt__getInputFileResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_rgt__getInputFileResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_rgt__getInputFileResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_rgt__getInputFileResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__getInputFileResponse ** SOAP_FMAC2 soap_get_PointerTorgt__getInputFileResponse(struct soap *soap, struct rgt__getInputFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgt__getInputFileResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__getInputFileResponse ** SOAP_FMAC2 soap_in_PointerTorgt__getInputFileResponse(struct soap *soap, const char *tag, struct rgt__getInputFileResponse **a, const char *type)
{
	struct rgt__getInputFileResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct rgt__getInputFileResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgt__getInputFileResponse, sizeof(struct rgt__getInputFileResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_rgt__getInputFileResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_rgt__getInputFileResponse(soap, tag, NULL, type)))
		{	a = (struct rgt__getInputFileResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTorgt__getInputFileResponse, sizeof(struct rgt__getInputFileResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct rgt__getInputFileResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgt__getInputFileResponse, sizeof(struct rgt__getInputFileResponse *), 1), SOAP_TYPE_rgt__getInputFileResponse, sizeof(struct rgt__getInputFileResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTorgt__getChildNodesResponse(struct soap *soap, struct rgt__getChildNodesResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTorgt__getChildNodesResponse))
		soap_mark_PointerTorgt__getChildNodesResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTorgt__getChildNodesResponse(struct soap *soap, struct rgt__getChildNodesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgt__getChildNodesResponse))
		soap_mark_rgt__getChildNodesResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTorgt__getChildNodesResponse(struct soap *soap, struct rgt__getChildNodesResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTorgt__getChildNodesResponse(struct soap *soap, struct rgt__getChildNodesResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTorgt__getChildNodesResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTorgt__getChildNodesResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTorgt__getChildNodesResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTorgt__getChildNodesResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTorgt__getChildNodesResponse(struct soap *soap, const char *tag, int id, struct rgt__getChildNodesResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTorgt__getChildNodesResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_rgt__getChildNodesResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_rgt__getChildNodesResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_rgt__getChildNodesResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_rgt__getChildNodesResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_rgt__getChildNodesResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__getChildNodesResponse ** SOAP_FMAC2 soap_get_PointerTorgt__getChildNodesResponse(struct soap *soap, struct rgt__getChildNodesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgt__getChildNodesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__getChildNodesResponse ** SOAP_FMAC2 soap_in_PointerTorgt__getChildNodesResponse(struct soap *soap, const char *tag, struct rgt__getChildNodesResponse **a, const char *type)
{
	struct rgt__getChildNodesResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct rgt__getChildNodesResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgt__getChildNodesResponse, sizeof(struct rgt__getChildNodesResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_rgt__getChildNodesResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_rgt__getChildNodesResponse(soap, tag, NULL, type)))
		{	a = (struct rgt__getChildNodesResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTorgt__getChildNodesResponse, sizeof(struct rgt__getChildNodesResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct rgt__getChildNodesResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgt__getChildNodesResponse, sizeof(struct rgt__getChildNodesResponse *), 1), SOAP_TYPE_rgt__getChildNodesResponse, sizeof(struct rgt__getChildNodesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTorgt__requestTerminationAfterResponse(struct soap *soap, struct rgt__requestTerminationAfterResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTorgt__requestTerminationAfterResponse))
		soap_mark_PointerTorgt__requestTerminationAfterResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTorgt__requestTerminationAfterResponse(struct soap *soap, struct rgt__requestTerminationAfterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgt__requestTerminationAfterResponse))
		soap_mark_rgt__requestTerminationAfterResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTorgt__requestTerminationAfterResponse(struct soap *soap, struct rgt__requestTerminationAfterResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTorgt__requestTerminationAfterResponse(struct soap *soap, struct rgt__requestTerminationAfterResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTorgt__requestTerminationAfterResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTorgt__requestTerminationAfterResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTorgt__requestTerminationAfterResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTorgt__requestTerminationAfterResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTorgt__requestTerminationAfterResponse(struct soap *soap, const char *tag, int id, struct rgt__requestTerminationAfterResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTorgt__requestTerminationAfterResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_rgt__requestTerminationAfterResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_rgt__requestTerminationAfterResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_rgt__requestTerminationAfterResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_rgt__requestTerminationAfterResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_rgt__requestTerminationAfterResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct rgt__requestTerminationAfterResponse ** SOAP_FMAC2 soap_get_PointerTorgt__requestTerminationAfterResponse(struct soap *soap, struct rgt__requestTerminationAfterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgt__requestTerminationAfterResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgt__requestTerminationAfterResponse ** SOAP_FMAC2 soap_in_PointerTorgt__requestTerminationAfterResponse(struct soap *soap, const char *tag, struct rgt__requestTerminationAfterResponse **a, const char *type)
{
	struct rgt__requestTerminationAfterResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct rgt__requestTerminationAfterResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgt__requestTerminationAfterResponse, sizeof(struct rgt__requestTerminationAfterResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_rgt__requestTerminationAfterResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_rgt__requestTerminationAfterResponse(soap, tag, NULL, type)))
		{	a = (struct rgt__requestTerminationAfterResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTorgt__requestTerminationAfterResponse, sizeof(struct rgt__requestTerminationAfterResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct rgt__requestTerminationAfterResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgt__requestTerminationAfterResponse, sizeof(struct rgt__requestTerminationAfterResponse *), 1), SOAP_TYPE_rgt__requestTerminationAfterResponse, sizeof(struct rgt__requestTerminationAfterResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTorgtf__requestTerminationAfterResponse(struct soap *soap, struct rgtf__requestTerminationAfterResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTorgtf__requestTerminationAfterResponse))
		soap_mark_PointerTorgtf__requestTerminationAfterResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTorgtf__requestTerminationAfterResponse(struct soap *soap, struct rgtf__requestTerminationAfterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgtf__requestTerminationAfterResponse))
		soap_mark_rgtf__requestTerminationAfterResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTorgtf__requestTerminationAfterResponse(struct soap *soap, struct rgtf__requestTerminationAfterResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTorgtf__requestTerminationAfterResponse(struct soap *soap, struct rgtf__requestTerminationAfterResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTorgtf__requestTerminationAfterResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTorgtf__requestTerminationAfterResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTorgtf__requestTerminationAfterResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTorgtf__requestTerminationAfterResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTorgtf__requestTerminationAfterResponse(struct soap *soap, const char *tag, int id, struct rgtf__requestTerminationAfterResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTorgtf__requestTerminationAfterResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_rgtf__requestTerminationAfterResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_rgtf__requestTerminationAfterResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_rgtf__requestTerminationAfterResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_rgtf__requestTerminationAfterResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_rgtf__requestTerminationAfterResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct rgtf__requestTerminationAfterResponse ** SOAP_FMAC2 soap_get_PointerTorgtf__requestTerminationAfterResponse(struct soap *soap, struct rgtf__requestTerminationAfterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgtf__requestTerminationAfterResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgtf__requestTerminationAfterResponse ** SOAP_FMAC2 soap_in_PointerTorgtf__requestTerminationAfterResponse(struct soap *soap, const char *tag, struct rgtf__requestTerminationAfterResponse **a, const char *type)
{
	struct rgtf__requestTerminationAfterResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct rgtf__requestTerminationAfterResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgtf__requestTerminationAfterResponse, sizeof(struct rgtf__requestTerminationAfterResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_rgtf__requestTerminationAfterResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_rgtf__requestTerminationAfterResponse(soap, tag, NULL, type)))
		{	a = (struct rgtf__requestTerminationAfterResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTorgtf__requestTerminationAfterResponse, sizeof(struct rgtf__requestTerminationAfterResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct rgtf__requestTerminationAfterResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgtf__requestTerminationAfterResponse, sizeof(struct rgtf__requestTerminationAfterResponse *), 1), SOAP_TYPE_rgtf__requestTerminationAfterResponse, sizeof(struct rgtf__requestTerminationAfterResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTorgtf__requestTerminationBeforeResponse(struct soap *soap, struct rgtf__requestTerminationBeforeResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTorgtf__requestTerminationBeforeResponse))
		soap_mark_PointerTorgtf__requestTerminationBeforeResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTorgtf__requestTerminationBeforeResponse(struct soap *soap, struct rgtf__requestTerminationBeforeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgtf__requestTerminationBeforeResponse))
		soap_mark_rgtf__requestTerminationBeforeResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTorgtf__requestTerminationBeforeResponse(struct soap *soap, struct rgtf__requestTerminationBeforeResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTorgtf__requestTerminationBeforeResponse(struct soap *soap, struct rgtf__requestTerminationBeforeResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTorgtf__requestTerminationBeforeResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTorgtf__requestTerminationBeforeResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTorgtf__requestTerminationBeforeResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTorgtf__requestTerminationBeforeResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTorgtf__requestTerminationBeforeResponse(struct soap *soap, const char *tag, int id, struct rgtf__requestTerminationBeforeResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTorgtf__requestTerminationBeforeResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_rgtf__requestTerminationBeforeResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_rgtf__requestTerminationBeforeResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_rgtf__requestTerminationBeforeResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_rgtf__requestTerminationBeforeResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_rgtf__requestTerminationBeforeResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct rgtf__requestTerminationBeforeResponse ** SOAP_FMAC2 soap_get_PointerTorgtf__requestTerminationBeforeResponse(struct soap *soap, struct rgtf__requestTerminationBeforeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgtf__requestTerminationBeforeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgtf__requestTerminationBeforeResponse ** SOAP_FMAC2 soap_in_PointerTorgtf__requestTerminationBeforeResponse(struct soap *soap, const char *tag, struct rgtf__requestTerminationBeforeResponse **a, const char *type)
{
	struct rgtf__requestTerminationBeforeResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct rgtf__requestTerminationBeforeResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgtf__requestTerminationBeforeResponse, sizeof(struct rgtf__requestTerminationBeforeResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_rgtf__requestTerminationBeforeResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_rgtf__requestTerminationBeforeResponse(soap, tag, NULL, type)))
		{	a = (struct rgtf__requestTerminationBeforeResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTorgtf__requestTerminationBeforeResponse, sizeof(struct rgtf__requestTerminationBeforeResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct rgtf__requestTerminationBeforeResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgtf__requestTerminationBeforeResponse, sizeof(struct rgtf__requestTerminationBeforeResponse *), 1), SOAP_TYPE_rgtf__requestTerminationBeforeResponse, sizeof(struct rgtf__requestTerminationBeforeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTorgtf__getActiveTreesResponse(struct soap *soap, struct rgtf__getActiveTreesResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTorgtf__getActiveTreesResponse))
		soap_mark_PointerTorgtf__getActiveTreesResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTorgtf__getActiveTreesResponse(struct soap *soap, struct rgtf__getActiveTreesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgtf__getActiveTreesResponse))
		soap_mark_rgtf__getActiveTreesResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTorgtf__getActiveTreesResponse(struct soap *soap, struct rgtf__getActiveTreesResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTorgtf__getActiveTreesResponse(struct soap *soap, struct rgtf__getActiveTreesResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTorgtf__getActiveTreesResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTorgtf__getActiveTreesResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTorgtf__getActiveTreesResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTorgtf__getActiveTreesResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTorgtf__getActiveTreesResponse(struct soap *soap, const char *tag, int id, struct rgtf__getActiveTreesResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTorgtf__getActiveTreesResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_rgtf__getActiveTreesResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_rgtf__getActiveTreesResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_rgtf__getActiveTreesResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_rgtf__getActiveTreesResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_rgtf__getActiveTreesResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct rgtf__getActiveTreesResponse ** SOAP_FMAC2 soap_get_PointerTorgtf__getActiveTreesResponse(struct soap *soap, struct rgtf__getActiveTreesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgtf__getActiveTreesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgtf__getActiveTreesResponse ** SOAP_FMAC2 soap_in_PointerTorgtf__getActiveTreesResponse(struct soap *soap, const char *tag, struct rgtf__getActiveTreesResponse **a, const char *type)
{
	struct rgtf__getActiveTreesResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct rgtf__getActiveTreesResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgtf__getActiveTreesResponse, sizeof(struct rgtf__getActiveTreesResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_rgtf__getActiveTreesResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_rgtf__getActiveTreesResponse(soap, tag, NULL, type)))
		{	a = (struct rgtf__getActiveTreesResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTorgtf__getActiveTreesResponse, sizeof(struct rgtf__getActiveTreesResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct rgtf__getActiveTreesResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgtf__getActiveTreesResponse, sizeof(struct rgtf__getActiveTreesResponse *), 1), SOAP_TYPE_rgtf__getActiveTreesResponse, sizeof(struct rgtf__getActiveTreesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTorgtf__findServiceDataResponse(struct soap *soap, struct rgtf__findServiceDataResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTorgtf__findServiceDataResponse))
		soap_mark_PointerTorgtf__findServiceDataResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTorgtf__findServiceDataResponse(struct soap *soap, struct rgtf__findServiceDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgtf__findServiceDataResponse))
		soap_mark_rgtf__findServiceDataResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTorgtf__findServiceDataResponse(struct soap *soap, struct rgtf__findServiceDataResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTorgtf__findServiceDataResponse(struct soap *soap, struct rgtf__findServiceDataResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTorgtf__findServiceDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTorgtf__findServiceDataResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTorgtf__findServiceDataResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTorgtf__findServiceDataResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTorgtf__findServiceDataResponse(struct soap *soap, const char *tag, int id, struct rgtf__findServiceDataResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTorgtf__findServiceDataResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_rgtf__findServiceDataResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_rgtf__findServiceDataResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_rgtf__findServiceDataResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_rgtf__findServiceDataResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_rgtf__findServiceDataResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct rgtf__findServiceDataResponse ** SOAP_FMAC2 soap_get_PointerTorgtf__findServiceDataResponse(struct soap *soap, struct rgtf__findServiceDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgtf__findServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgtf__findServiceDataResponse ** SOAP_FMAC2 soap_in_PointerTorgtf__findServiceDataResponse(struct soap *soap, const char *tag, struct rgtf__findServiceDataResponse **a, const char *type)
{
	struct rgtf__findServiceDataResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct rgtf__findServiceDataResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgtf__findServiceDataResponse, sizeof(struct rgtf__findServiceDataResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_rgtf__findServiceDataResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_rgtf__findServiceDataResponse(soap, tag, NULL, type)))
		{	a = (struct rgtf__findServiceDataResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTorgtf__findServiceDataResponse, sizeof(struct rgtf__findServiceDataResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct rgtf__findServiceDataResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgtf__findServiceDataResponse, sizeof(struct rgtf__findServiceDataResponse *), 1), SOAP_TYPE_rgtf__findServiceDataResponse, sizeof(struct rgtf__findServiceDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTorgtf__destroyResponse(struct soap *soap, struct rgtf__destroyResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTorgtf__destroyResponse))
		soap_mark_PointerTorgtf__destroyResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTorgtf__destroyResponse(struct soap *soap, struct rgtf__destroyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgtf__destroyResponse))
		soap_mark_rgtf__destroyResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTorgtf__destroyResponse(struct soap *soap, struct rgtf__destroyResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTorgtf__destroyResponse(struct soap *soap, struct rgtf__destroyResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTorgtf__destroyResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTorgtf__destroyResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTorgtf__destroyResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTorgtf__destroyResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTorgtf__destroyResponse(struct soap *soap, const char *tag, int id, struct rgtf__destroyResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTorgtf__destroyResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_rgtf__destroyResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_rgtf__destroyResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_rgtf__destroyResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_rgtf__destroyResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_rgtf__destroyResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct rgtf__destroyResponse ** SOAP_FMAC2 soap_get_PointerTorgtf__destroyResponse(struct soap *soap, struct rgtf__destroyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgtf__destroyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgtf__destroyResponse ** SOAP_FMAC2 soap_in_PointerTorgtf__destroyResponse(struct soap *soap, const char *tag, struct rgtf__destroyResponse **a, const char *type)
{
	struct rgtf__destroyResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct rgtf__destroyResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgtf__destroyResponse, sizeof(struct rgtf__destroyResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_rgtf__destroyResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_rgtf__destroyResponse(soap, tag, NULL, type)))
		{	a = (struct rgtf__destroyResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTorgtf__destroyResponse, sizeof(struct rgtf__destroyResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct rgtf__destroyResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgtf__destroyResponse, sizeof(struct rgtf__destroyResponse *), 1), SOAP_TYPE_rgtf__destroyResponse, sizeof(struct rgtf__destroyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTorgtf__findByHandleResponse(struct soap *soap, struct rgtf__findByHandleResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTorgtf__findByHandleResponse))
		soap_mark_PointerTorgtf__findByHandleResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTorgtf__findByHandleResponse(struct soap *soap, struct rgtf__findByHandleResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgtf__findByHandleResponse))
		soap_mark_rgtf__findByHandleResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTorgtf__findByHandleResponse(struct soap *soap, struct rgtf__findByHandleResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTorgtf__findByHandleResponse(struct soap *soap, struct rgtf__findByHandleResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTorgtf__findByHandleResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTorgtf__findByHandleResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTorgtf__findByHandleResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTorgtf__findByHandleResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTorgtf__findByHandleResponse(struct soap *soap, const char *tag, int id, struct rgtf__findByHandleResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTorgtf__findByHandleResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_rgtf__findByHandleResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_rgtf__findByHandleResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_rgtf__findByHandleResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_rgtf__findByHandleResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_rgtf__findByHandleResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct rgtf__findByHandleResponse ** SOAP_FMAC2 soap_get_PointerTorgtf__findByHandleResponse(struct soap *soap, struct rgtf__findByHandleResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgtf__findByHandleResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgtf__findByHandleResponse ** SOAP_FMAC2 soap_in_PointerTorgtf__findByHandleResponse(struct soap *soap, const char *tag, struct rgtf__findByHandleResponse **a, const char *type)
{
	struct rgtf__findByHandleResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct rgtf__findByHandleResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgtf__findByHandleResponse, sizeof(struct rgtf__findByHandleResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_rgtf__findByHandleResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_rgtf__findByHandleResponse(soap, tag, NULL, type)))
		{	a = (struct rgtf__findByHandleResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTorgtf__findByHandleResponse, sizeof(struct rgtf__findByHandleResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct rgtf__findByHandleResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgtf__findByHandleResponse, sizeof(struct rgtf__findByHandleResponse *), 1), SOAP_TYPE_rgtf__findByHandleResponse, sizeof(struct rgtf__findByHandleResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTorgtf__createNewTreeResponse(struct soap *soap, struct rgtf__createNewTreeResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTorgtf__createNewTreeResponse))
		soap_mark_PointerTorgtf__createNewTreeResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTorgtf__createNewTreeResponse(struct soap *soap, struct rgtf__createNewTreeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rgtf__createNewTreeResponse))
		soap_mark_rgtf__createNewTreeResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTorgtf__createNewTreeResponse(struct soap *soap, struct rgtf__createNewTreeResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTorgtf__createNewTreeResponse(struct soap *soap, struct rgtf__createNewTreeResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTorgtf__createNewTreeResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTorgtf__createNewTreeResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTorgtf__createNewTreeResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTorgtf__createNewTreeResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTorgtf__createNewTreeResponse(struct soap *soap, const char *tag, int id, struct rgtf__createNewTreeResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTorgtf__createNewTreeResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_rgtf__createNewTreeResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_rgtf__createNewTreeResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_rgtf__createNewTreeResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_rgtf__createNewTreeResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_rgtf__createNewTreeResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct rgtf__createNewTreeResponse ** SOAP_FMAC2 soap_get_PointerTorgtf__createNewTreeResponse(struct soap *soap, struct rgtf__createNewTreeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorgtf__createNewTreeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct rgtf__createNewTreeResponse ** SOAP_FMAC2 soap_in_PointerTorgtf__createNewTreeResponse(struct soap *soap, const char *tag, struct rgtf__createNewTreeResponse **a, const char *type)
{
	struct rgtf__createNewTreeResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct rgtf__createNewTreeResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgtf__createNewTreeResponse, sizeof(struct rgtf__createNewTreeResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_rgtf__createNewTreeResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_rgtf__createNewTreeResponse(soap, tag, NULL, type)))
		{	a = (struct rgtf__createNewTreeResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTorgtf__createNewTreeResponse, sizeof(struct rgtf__createNewTreeResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct rgtf__createNewTreeResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTorgtf__createNewTreeResponse, sizeof(struct rgtf__createNewTreeResponse *), 1), SOAP_TYPE_rgtf__createNewTreeResponse, sizeof(struct rgtf__createNewTreeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTosgr__findServiceDataResponse(struct soap *soap, struct sgr__findServiceDataResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTosgr__findServiceDataResponse))
		soap_mark_PointerTosgr__findServiceDataResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTosgr__findServiceDataResponse(struct soap *soap, struct sgr__findServiceDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgr__findServiceDataResponse))
		soap_mark_sgr__findServiceDataResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTosgr__findServiceDataResponse(struct soap *soap, struct sgr__findServiceDataResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTosgr__findServiceDataResponse(struct soap *soap, struct sgr__findServiceDataResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTosgr__findServiceDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTosgr__findServiceDataResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTosgr__findServiceDataResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTosgr__findServiceDataResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTosgr__findServiceDataResponse(struct soap *soap, const char *tag, int id, struct sgr__findServiceDataResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTosgr__findServiceDataResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_sgr__findServiceDataResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_sgr__findServiceDataResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_sgr__findServiceDataResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_sgr__findServiceDataResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_sgr__findServiceDataResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct sgr__findServiceDataResponse ** SOAP_FMAC2 soap_get_PointerTosgr__findServiceDataResponse(struct soap *soap, struct sgr__findServiceDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgr__findServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgr__findServiceDataResponse ** SOAP_FMAC2 soap_in_PointerTosgr__findServiceDataResponse(struct soap *soap, const char *tag, struct sgr__findServiceDataResponse **a, const char *type)
{
	struct sgr__findServiceDataResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct sgr__findServiceDataResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgr__findServiceDataResponse, sizeof(struct sgr__findServiceDataResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_sgr__findServiceDataResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_sgr__findServiceDataResponse(soap, tag, NULL, type)))
		{	a = (struct sgr__findServiceDataResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTosgr__findServiceDataResponse, sizeof(struct sgr__findServiceDataResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct sgr__findServiceDataResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgr__findServiceDataResponse, sizeof(struct sgr__findServiceDataResponse *), 1), SOAP_TYPE_sgr__findServiceDataResponse, sizeof(struct sgr__findServiceDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTosgr__addResponse(struct soap *soap, struct sgr__addResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTosgr__addResponse))
		soap_mark_PointerTosgr__addResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTosgr__addResponse(struct soap *soap, struct sgr__addResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgr__addResponse))
		soap_mark_sgr__addResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTosgr__addResponse(struct soap *soap, struct sgr__addResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTosgr__addResponse(struct soap *soap, struct sgr__addResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTosgr__addResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTosgr__addResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTosgr__addResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTosgr__addResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTosgr__addResponse(struct soap *soap, const char *tag, int id, struct sgr__addResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTosgr__addResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_sgr__addResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_sgr__addResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_sgr__addResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_sgr__addResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_sgr__addResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct sgr__addResponse ** SOAP_FMAC2 soap_get_PointerTosgr__addResponse(struct soap *soap, struct sgr__addResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgr__addResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgr__addResponse ** SOAP_FMAC2 soap_in_PointerTosgr__addResponse(struct soap *soap, const char *tag, struct sgr__addResponse **a, const char *type)
{
	struct sgr__addResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct sgr__addResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgr__addResponse, sizeof(struct sgr__addResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_sgr__addResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_sgr__addResponse(soap, tag, NULL, type)))
		{	a = (struct sgr__addResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTosgr__addResponse, sizeof(struct sgr__addResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct sgr__addResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgr__addResponse, sizeof(struct sgr__addResponse *), 1), SOAP_TYPE_sgr__addResponse, sizeof(struct sgr__addResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTosgr__removeResponse(struct soap *soap, struct sgr__removeResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTosgr__removeResponse))
		soap_mark_PointerTosgr__removeResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTosgr__removeResponse(struct soap *soap, struct sgr__removeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgr__removeResponse))
		soap_mark_sgr__removeResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTosgr__removeResponse(struct soap *soap, struct sgr__removeResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTosgr__removeResponse(struct soap *soap, struct sgr__removeResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTosgr__removeResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTosgr__removeResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTosgr__removeResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTosgr__removeResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTosgr__removeResponse(struct soap *soap, const char *tag, int id, struct sgr__removeResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTosgr__removeResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_sgr__removeResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_sgr__removeResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_sgr__removeResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_sgr__removeResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_sgr__removeResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct sgr__removeResponse ** SOAP_FMAC2 soap_get_PointerTosgr__removeResponse(struct soap *soap, struct sgr__removeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgr__removeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgr__removeResponse ** SOAP_FMAC2 soap_in_PointerTosgr__removeResponse(struct soap *soap, const char *tag, struct sgr__removeResponse **a, const char *type)
{
	struct sgr__removeResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct sgr__removeResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgr__removeResponse, sizeof(struct sgr__removeResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_sgr__removeResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_sgr__removeResponse(soap, tag, NULL, type)))
		{	a = (struct sgr__removeResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTosgr__removeResponse, sizeof(struct sgr__removeResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct sgr__removeResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgr__removeResponse, sizeof(struct sgr__removeResponse *), 1), SOAP_TYPE_sgr__removeResponse, sizeof(struct sgr__removeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerToxsd__string(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerToxsd__string))
		soap_mark_PointerToxsd__string(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerToxsd__string(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__string))
		soap_mark_xsd__string(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerToxsd__string(struct soap *soap, char ***a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerToxsd__string(struct soap *soap, char ***a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerToxsd__string, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerToxsd__string(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerToxsd__string(soap, tag, i, a, type);
		}
	else
		soap_out_PointerToxsd__string(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerToxsd__string(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerToxsd__string);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_xsd__string, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_xsd__string(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_xsd__string(soap, tag, i, *a, type);
			}
		else
			soap_out_xsd__string(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_xsd__string, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 char *** SOAP_FMAC2 soap_get_PointerToxsd__string(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char *** SOAP_FMAC2 soap_in_PointerToxsd__string(struct soap *soap, const char *tag, char ***a, const char *type)
{
	char **p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (char ***)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToxsd__string, sizeof(char **), 2);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_xsd__string(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_xsd__string(soap, tag, NULL, type)))
		{	a = (char ***)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerToxsd__string, sizeof(char **), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToxsd__string, sizeof(char **), 2), SOAP_TYPE_xsd__string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerToArrayOf_USCORE_xsd_USCORE_string(struct soap *soap, struct ArrayOf_USCORE_xsd_USCORE_string *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerToArrayOf_USCORE_xsd_USCORE_string))
		soap_mark_PointerToArrayOf_USCORE_xsd_USCORE_string(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerToArrayOf_USCORE_xsd_USCORE_string(struct soap *soap, struct ArrayOf_USCORE_xsd_USCORE_string *const*a)
{
	if (*a && !soap_array_reference(soap, *a, (struct soap_array*)&(*a)->__ptr, (*a)->__size, SOAP_TYPE_ArrayOf_USCORE_xsd_USCORE_string))
		soap_mark_ArrayOf_USCORE_xsd_USCORE_string(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerToArrayOf_USCORE_xsd_USCORE_string(struct soap *soap, struct ArrayOf_USCORE_xsd_USCORE_string **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerToArrayOf_USCORE_xsd_USCORE_string(struct soap *soap, struct ArrayOf_USCORE_xsd_USCORE_string **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerToArrayOf_USCORE_xsd_USCORE_string, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerToArrayOf_USCORE_xsd_USCORE_string(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerToArrayOf_USCORE_xsd_USCORE_string(soap, tag, i, a, type);
		}
	else
		soap_out_PointerToArrayOf_USCORE_xsd_USCORE_string(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerToArrayOf_USCORE_xsd_USCORE_string(struct soap *soap, const char *tag, int id, struct ArrayOf_USCORE_xsd_USCORE_string *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerToArrayOf_USCORE_xsd_USCORE_string);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_array_pointer_lookup(soap, *a, (struct soap_array*)&(*a)->__ptr, (*a)->__size, SOAP_TYPE_ArrayOf_USCORE_xsd_USCORE_string, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_ArrayOf_USCORE_xsd_USCORE_string(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_ArrayOf_USCORE_xsd_USCORE_string(soap, tag, i, *a, type);
			}
		else
			soap_out_ArrayOf_USCORE_xsd_USCORE_string(soap, tag, soap_array_pointer_enter(soap, *a, (struct soap_array*)&(*a)->__ptr, SOAP_TYPE_ArrayOf_USCORE_xsd_USCORE_string, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct ArrayOf_USCORE_xsd_USCORE_string ** SOAP_FMAC2 soap_get_PointerToArrayOf_USCORE_xsd_USCORE_string(struct soap *soap, struct ArrayOf_USCORE_xsd_USCORE_string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOf_USCORE_xsd_USCORE_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct ArrayOf_USCORE_xsd_USCORE_string ** SOAP_FMAC2 soap_in_PointerToArrayOf_USCORE_xsd_USCORE_string(struct soap *soap, const char *tag, struct ArrayOf_USCORE_xsd_USCORE_string **a, const char *type)
{
	struct ArrayOf_USCORE_xsd_USCORE_string *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct ArrayOf_USCORE_xsd_USCORE_string **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToArrayOf_USCORE_xsd_USCORE_string, sizeof(struct ArrayOf_USCORE_xsd_USCORE_string *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_ArrayOf_USCORE_xsd_USCORE_string(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_ArrayOf_USCORE_xsd_USCORE_string(soap, tag, NULL, type)))
		{	a = (struct ArrayOf_USCORE_xsd_USCORE_string **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerToArrayOf_USCORE_xsd_USCORE_string, sizeof(struct ArrayOf_USCORE_xsd_USCORE_string *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct ArrayOf_USCORE_xsd_USCORE_string **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToArrayOf_USCORE_xsd_USCORE_string, sizeof(struct ArrayOf_USCORE_xsd_USCORE_string *), 1), SOAP_TYPE_ArrayOf_USCORE_xsd_USCORE_string, sizeof(struct ArrayOf_USCORE_xsd_USCORE_string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTosgs__ClearStatusMsgQueueResponse(struct soap *soap, struct sgs__ClearStatusMsgQueueResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTosgs__ClearStatusMsgQueueResponse))
		soap_mark_PointerTosgs__ClearStatusMsgQueueResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTosgs__ClearStatusMsgQueueResponse(struct soap *soap, struct sgs__ClearStatusMsgQueueResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__ClearStatusMsgQueueResponse))
		soap_mark_sgs__ClearStatusMsgQueueResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTosgs__ClearStatusMsgQueueResponse(struct soap *soap, struct sgs__ClearStatusMsgQueueResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTosgs__ClearStatusMsgQueueResponse(struct soap *soap, struct sgs__ClearStatusMsgQueueResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTosgs__ClearStatusMsgQueueResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTosgs__ClearStatusMsgQueueResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTosgs__ClearStatusMsgQueueResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTosgs__ClearStatusMsgQueueResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTosgs__ClearStatusMsgQueueResponse(struct soap *soap, const char *tag, int id, struct sgs__ClearStatusMsgQueueResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTosgs__ClearStatusMsgQueueResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_sgs__ClearStatusMsgQueueResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_sgs__ClearStatusMsgQueueResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_sgs__ClearStatusMsgQueueResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_sgs__ClearStatusMsgQueueResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_sgs__ClearStatusMsgQueueResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__ClearStatusMsgQueueResponse ** SOAP_FMAC2 soap_get_PointerTosgs__ClearStatusMsgQueueResponse(struct soap *soap, struct sgs__ClearStatusMsgQueueResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__ClearStatusMsgQueueResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__ClearStatusMsgQueueResponse ** SOAP_FMAC2 soap_in_PointerTosgs__ClearStatusMsgQueueResponse(struct soap *soap, const char *tag, struct sgs__ClearStatusMsgQueueResponse **a, const char *type)
{
	struct sgs__ClearStatusMsgQueueResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct sgs__ClearStatusMsgQueueResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__ClearStatusMsgQueueResponse, sizeof(struct sgs__ClearStatusMsgQueueResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_sgs__ClearStatusMsgQueueResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_sgs__ClearStatusMsgQueueResponse(soap, tag, NULL, type)))
		{	a = (struct sgs__ClearStatusMsgQueueResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTosgs__ClearStatusMsgQueueResponse, sizeof(struct sgs__ClearStatusMsgQueueResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct sgs__ClearStatusMsgQueueResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__ClearStatusMsgQueueResponse, sizeof(struct sgs__ClearStatusMsgQueueResponse *), 1), SOAP_TYPE_sgs__ClearStatusMsgQueueResponse, sizeof(struct sgs__ClearStatusMsgQueueResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTosgs__ResumeResponse(struct soap *soap, struct sgs__ResumeResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTosgs__ResumeResponse))
		soap_mark_PointerTosgs__ResumeResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTosgs__ResumeResponse(struct soap *soap, struct sgs__ResumeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__ResumeResponse))
		soap_mark_sgs__ResumeResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTosgs__ResumeResponse(struct soap *soap, struct sgs__ResumeResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTosgs__ResumeResponse(struct soap *soap, struct sgs__ResumeResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTosgs__ResumeResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTosgs__ResumeResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTosgs__ResumeResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTosgs__ResumeResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTosgs__ResumeResponse(struct soap *soap, const char *tag, int id, struct sgs__ResumeResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTosgs__ResumeResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_sgs__ResumeResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_sgs__ResumeResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_sgs__ResumeResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_sgs__ResumeResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_sgs__ResumeResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__ResumeResponse ** SOAP_FMAC2 soap_get_PointerTosgs__ResumeResponse(struct soap *soap, struct sgs__ResumeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__ResumeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__ResumeResponse ** SOAP_FMAC2 soap_in_PointerTosgs__ResumeResponse(struct soap *soap, const char *tag, struct sgs__ResumeResponse **a, const char *type)
{
	struct sgs__ResumeResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct sgs__ResumeResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__ResumeResponse, sizeof(struct sgs__ResumeResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_sgs__ResumeResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_sgs__ResumeResponse(soap, tag, NULL, type)))
		{	a = (struct sgs__ResumeResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTosgs__ResumeResponse, sizeof(struct sgs__ResumeResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct sgs__ResumeResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__ResumeResponse, sizeof(struct sgs__ResumeResponse *), 1), SOAP_TYPE_sgs__ResumeResponse, sizeof(struct sgs__ResumeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTosgs__AppStartResponse(struct soap *soap, struct sgs__AppStartResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTosgs__AppStartResponse))
		soap_mark_PointerTosgs__AppStartResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTosgs__AppStartResponse(struct soap *soap, struct sgs__AppStartResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__AppStartResponse))
		soap_mark_sgs__AppStartResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTosgs__AppStartResponse(struct soap *soap, struct sgs__AppStartResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTosgs__AppStartResponse(struct soap *soap, struct sgs__AppStartResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTosgs__AppStartResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTosgs__AppStartResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTosgs__AppStartResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTosgs__AppStartResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTosgs__AppStartResponse(struct soap *soap, const char *tag, int id, struct sgs__AppStartResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTosgs__AppStartResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_sgs__AppStartResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_sgs__AppStartResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_sgs__AppStartResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_sgs__AppStartResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_sgs__AppStartResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__AppStartResponse ** SOAP_FMAC2 soap_get_PointerTosgs__AppStartResponse(struct soap *soap, struct sgs__AppStartResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__AppStartResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__AppStartResponse ** SOAP_FMAC2 soap_in_PointerTosgs__AppStartResponse(struct soap *soap, const char *tag, struct sgs__AppStartResponse **a, const char *type)
{
	struct sgs__AppStartResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct sgs__AppStartResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__AppStartResponse, sizeof(struct sgs__AppStartResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_sgs__AppStartResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_sgs__AppStartResponse(soap, tag, NULL, type)))
		{	a = (struct sgs__AppStartResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTosgs__AppStartResponse, sizeof(struct sgs__AppStartResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct sgs__AppStartResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__AppStartResponse, sizeof(struct sgs__AppStartResponse *), 1), SOAP_TYPE_sgs__AppStartResponse, sizeof(struct sgs__AppStartResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTosgs__GetNotificationsResponse(struct soap *soap, struct sgs__GetNotificationsResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTosgs__GetNotificationsResponse))
		soap_mark_PointerTosgs__GetNotificationsResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTosgs__GetNotificationsResponse(struct soap *soap, struct sgs__GetNotificationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__GetNotificationsResponse))
		soap_mark_sgs__GetNotificationsResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTosgs__GetNotificationsResponse(struct soap *soap, struct sgs__GetNotificationsResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTosgs__GetNotificationsResponse(struct soap *soap, struct sgs__GetNotificationsResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTosgs__GetNotificationsResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTosgs__GetNotificationsResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTosgs__GetNotificationsResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTosgs__GetNotificationsResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTosgs__GetNotificationsResponse(struct soap *soap, const char *tag, int id, struct sgs__GetNotificationsResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTosgs__GetNotificationsResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_sgs__GetNotificationsResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_sgs__GetNotificationsResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_sgs__GetNotificationsResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_sgs__GetNotificationsResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_sgs__GetNotificationsResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__GetNotificationsResponse ** SOAP_FMAC2 soap_get_PointerTosgs__GetNotificationsResponse(struct soap *soap, struct sgs__GetNotificationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__GetNotificationsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__GetNotificationsResponse ** SOAP_FMAC2 soap_in_PointerTosgs__GetNotificationsResponse(struct soap *soap, const char *tag, struct sgs__GetNotificationsResponse **a, const char *type)
{
	struct sgs__GetNotificationsResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct sgs__GetNotificationsResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__GetNotificationsResponse, sizeof(struct sgs__GetNotificationsResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_sgs__GetNotificationsResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_sgs__GetNotificationsResponse(soap, tag, NULL, type)))
		{	a = (struct sgs__GetNotificationsResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTosgs__GetNotificationsResponse, sizeof(struct sgs__GetNotificationsResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct sgs__GetNotificationsResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__GetNotificationsResponse, sizeof(struct sgs__GetNotificationsResponse *), 1), SOAP_TYPE_sgs__GetNotificationsResponse, sizeof(struct sgs__GetNotificationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTosgs__PauseResponse(struct soap *soap, struct sgs__PauseResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTosgs__PauseResponse))
		soap_mark_PointerTosgs__PauseResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTosgs__PauseResponse(struct soap *soap, struct sgs__PauseResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__PauseResponse))
		soap_mark_sgs__PauseResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTosgs__PauseResponse(struct soap *soap, struct sgs__PauseResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTosgs__PauseResponse(struct soap *soap, struct sgs__PauseResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTosgs__PauseResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTosgs__PauseResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTosgs__PauseResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTosgs__PauseResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTosgs__PauseResponse(struct soap *soap, const char *tag, int id, struct sgs__PauseResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTosgs__PauseResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_sgs__PauseResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_sgs__PauseResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_sgs__PauseResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_sgs__PauseResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_sgs__PauseResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__PauseResponse ** SOAP_FMAC2 soap_get_PointerTosgs__PauseResponse(struct soap *soap, struct sgs__PauseResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__PauseResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__PauseResponse ** SOAP_FMAC2 soap_in_PointerTosgs__PauseResponse(struct soap *soap, const char *tag, struct sgs__PauseResponse **a, const char *type)
{
	struct sgs__PauseResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct sgs__PauseResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__PauseResponse, sizeof(struct sgs__PauseResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_sgs__PauseResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_sgs__PauseResponse(soap, tag, NULL, type)))
		{	a = (struct sgs__PauseResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTosgs__PauseResponse, sizeof(struct sgs__PauseResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct sgs__PauseResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__PauseResponse, sizeof(struct sgs__PauseResponse *), 1), SOAP_TYPE_sgs__PauseResponse, sizeof(struct sgs__PauseResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTosgs__AppRecordChkpointResponse(struct soap *soap, struct sgs__AppRecordChkpointResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTosgs__AppRecordChkpointResponse))
		soap_mark_PointerTosgs__AppRecordChkpointResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTosgs__AppRecordChkpointResponse(struct soap *soap, struct sgs__AppRecordChkpointResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__AppRecordChkpointResponse))
		soap_mark_sgs__AppRecordChkpointResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTosgs__AppRecordChkpointResponse(struct soap *soap, struct sgs__AppRecordChkpointResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTosgs__AppRecordChkpointResponse(struct soap *soap, struct sgs__AppRecordChkpointResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTosgs__AppRecordChkpointResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTosgs__AppRecordChkpointResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTosgs__AppRecordChkpointResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTosgs__AppRecordChkpointResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTosgs__AppRecordChkpointResponse(struct soap *soap, const char *tag, int id, struct sgs__AppRecordChkpointResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTosgs__AppRecordChkpointResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_sgs__AppRecordChkpointResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_sgs__AppRecordChkpointResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_sgs__AppRecordChkpointResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_sgs__AppRecordChkpointResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_sgs__AppRecordChkpointResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__AppRecordChkpointResponse ** SOAP_FMAC2 soap_get_PointerTosgs__AppRecordChkpointResponse(struct soap *soap, struct sgs__AppRecordChkpointResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__AppRecordChkpointResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__AppRecordChkpointResponse ** SOAP_FMAC2 soap_in_PointerTosgs__AppRecordChkpointResponse(struct soap *soap, const char *tag, struct sgs__AppRecordChkpointResponse **a, const char *type)
{
	struct sgs__AppRecordChkpointResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct sgs__AppRecordChkpointResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__AppRecordChkpointResponse, sizeof(struct sgs__AppRecordChkpointResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_sgs__AppRecordChkpointResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_sgs__AppRecordChkpointResponse(soap, tag, NULL, type)))
		{	a = (struct sgs__AppRecordChkpointResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTosgs__AppRecordChkpointResponse, sizeof(struct sgs__AppRecordChkpointResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct sgs__AppRecordChkpointResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__AppRecordChkpointResponse, sizeof(struct sgs__AppRecordChkpointResponse *), 1), SOAP_TYPE_sgs__AppRecordChkpointResponse, sizeof(struct sgs__AppRecordChkpointResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTosgs__findServiceDataResponse(struct soap *soap, struct sgs__findServiceDataResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTosgs__findServiceDataResponse))
		soap_mark_PointerTosgs__findServiceDataResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTosgs__findServiceDataResponse(struct soap *soap, struct sgs__findServiceDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__findServiceDataResponse))
		soap_mark_sgs__findServiceDataResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTosgs__findServiceDataResponse(struct soap *soap, struct sgs__findServiceDataResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTosgs__findServiceDataResponse(struct soap *soap, struct sgs__findServiceDataResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTosgs__findServiceDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTosgs__findServiceDataResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTosgs__findServiceDataResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTosgs__findServiceDataResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTosgs__findServiceDataResponse(struct soap *soap, const char *tag, int id, struct sgs__findServiceDataResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTosgs__findServiceDataResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_sgs__findServiceDataResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_sgs__findServiceDataResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_sgs__findServiceDataResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_sgs__findServiceDataResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_sgs__findServiceDataResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__findServiceDataResponse ** SOAP_FMAC2 soap_get_PointerTosgs__findServiceDataResponse(struct soap *soap, struct sgs__findServiceDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__findServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__findServiceDataResponse ** SOAP_FMAC2 soap_in_PointerTosgs__findServiceDataResponse(struct soap *soap, const char *tag, struct sgs__findServiceDataResponse **a, const char *type)
{
	struct sgs__findServiceDataResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct sgs__findServiceDataResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__findServiceDataResponse, sizeof(struct sgs__findServiceDataResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_sgs__findServiceDataResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_sgs__findServiceDataResponse(soap, tag, NULL, type)))
		{	a = (struct sgs__findServiceDataResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTosgs__findServiceDataResponse, sizeof(struct sgs__findServiceDataResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct sgs__findServiceDataResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__findServiceDataResponse, sizeof(struct sgs__findServiceDataResponse *), 1), SOAP_TYPE_sgs__findServiceDataResponse, sizeof(struct sgs__findServiceDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTosgs__PutControlResponse(struct soap *soap, struct sgs__PutControlResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTosgs__PutControlResponse))
		soap_mark_PointerTosgs__PutControlResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTosgs__PutControlResponse(struct soap *soap, struct sgs__PutControlResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__PutControlResponse))
		soap_mark_sgs__PutControlResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTosgs__PutControlResponse(struct soap *soap, struct sgs__PutControlResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTosgs__PutControlResponse(struct soap *soap, struct sgs__PutControlResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTosgs__PutControlResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTosgs__PutControlResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTosgs__PutControlResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTosgs__PutControlResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTosgs__PutControlResponse(struct soap *soap, const char *tag, int id, struct sgs__PutControlResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTosgs__PutControlResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_sgs__PutControlResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_sgs__PutControlResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_sgs__PutControlResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_sgs__PutControlResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_sgs__PutControlResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__PutControlResponse ** SOAP_FMAC2 soap_get_PointerTosgs__PutControlResponse(struct soap *soap, struct sgs__PutControlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__PutControlResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__PutControlResponse ** SOAP_FMAC2 soap_in_PointerTosgs__PutControlResponse(struct soap *soap, const char *tag, struct sgs__PutControlResponse **a, const char *type)
{
	struct sgs__PutControlResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct sgs__PutControlResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__PutControlResponse, sizeof(struct sgs__PutControlResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_sgs__PutControlResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_sgs__PutControlResponse(soap, tag, NULL, type)))
		{	a = (struct sgs__PutControlResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTosgs__PutControlResponse, sizeof(struct sgs__PutControlResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct sgs__PutControlResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__PutControlResponse, sizeof(struct sgs__PutControlResponse *), 1), SOAP_TYPE_sgs__PutControlResponse, sizeof(struct sgs__PutControlResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTosgs__DetachResponse(struct soap *soap, struct sgs__DetachResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTosgs__DetachResponse))
		soap_mark_PointerTosgs__DetachResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTosgs__DetachResponse(struct soap *soap, struct sgs__DetachResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__DetachResponse))
		soap_mark_sgs__DetachResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTosgs__DetachResponse(struct soap *soap, struct sgs__DetachResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTosgs__DetachResponse(struct soap *soap, struct sgs__DetachResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTosgs__DetachResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTosgs__DetachResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTosgs__DetachResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTosgs__DetachResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTosgs__DetachResponse(struct soap *soap, const char *tag, int id, struct sgs__DetachResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTosgs__DetachResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_sgs__DetachResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_sgs__DetachResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_sgs__DetachResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_sgs__DetachResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_sgs__DetachResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__DetachResponse ** SOAP_FMAC2 soap_get_PointerTosgs__DetachResponse(struct soap *soap, struct sgs__DetachResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__DetachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__DetachResponse ** SOAP_FMAC2 soap_in_PointerTosgs__DetachResponse(struct soap *soap, const char *tag, struct sgs__DetachResponse **a, const char *type)
{
	struct sgs__DetachResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct sgs__DetachResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__DetachResponse, sizeof(struct sgs__DetachResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_sgs__DetachResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_sgs__DetachResponse(soap, tag, NULL, type)))
		{	a = (struct sgs__DetachResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTosgs__DetachResponse, sizeof(struct sgs__DetachResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct sgs__DetachResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__DetachResponse, sizeof(struct sgs__DetachResponse *), 1), SOAP_TYPE_sgs__DetachResponse, sizeof(struct sgs__DetachResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTosgs__StopResponse(struct soap *soap, struct sgs__StopResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTosgs__StopResponse))
		soap_mark_PointerTosgs__StopResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTosgs__StopResponse(struct soap *soap, struct sgs__StopResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__StopResponse))
		soap_mark_sgs__StopResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTosgs__StopResponse(struct soap *soap, struct sgs__StopResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTosgs__StopResponse(struct soap *soap, struct sgs__StopResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTosgs__StopResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTosgs__StopResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTosgs__StopResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTosgs__StopResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTosgs__StopResponse(struct soap *soap, const char *tag, int id, struct sgs__StopResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTosgs__StopResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_sgs__StopResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_sgs__StopResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_sgs__StopResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_sgs__StopResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_sgs__StopResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__StopResponse ** SOAP_FMAC2 soap_get_PointerTosgs__StopResponse(struct soap *soap, struct sgs__StopResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__StopResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__StopResponse ** SOAP_FMAC2 soap_in_PointerTosgs__StopResponse(struct soap *soap, const char *tag, struct sgs__StopResponse **a, const char *type)
{
	struct sgs__StopResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct sgs__StopResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__StopResponse, sizeof(struct sgs__StopResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_sgs__StopResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_sgs__StopResponse(soap, tag, NULL, type)))
		{	a = (struct sgs__StopResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTosgs__StopResponse, sizeof(struct sgs__StopResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct sgs__StopResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__StopResponse, sizeof(struct sgs__StopResponse *), 1), SOAP_TYPE_sgs__StopResponse, sizeof(struct sgs__StopResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTosgs__GetNthDataSourceResponse(struct soap *soap, struct sgs__GetNthDataSourceResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTosgs__GetNthDataSourceResponse))
		soap_mark_PointerTosgs__GetNthDataSourceResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTosgs__GetNthDataSourceResponse(struct soap *soap, struct sgs__GetNthDataSourceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__GetNthDataSourceResponse))
		soap_mark_sgs__GetNthDataSourceResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTosgs__GetNthDataSourceResponse(struct soap *soap, struct sgs__GetNthDataSourceResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTosgs__GetNthDataSourceResponse(struct soap *soap, struct sgs__GetNthDataSourceResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTosgs__GetNthDataSourceResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTosgs__GetNthDataSourceResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTosgs__GetNthDataSourceResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTosgs__GetNthDataSourceResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTosgs__GetNthDataSourceResponse(struct soap *soap, const char *tag, int id, struct sgs__GetNthDataSourceResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTosgs__GetNthDataSourceResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_sgs__GetNthDataSourceResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_sgs__GetNthDataSourceResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_sgs__GetNthDataSourceResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_sgs__GetNthDataSourceResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_sgs__GetNthDataSourceResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__GetNthDataSourceResponse ** SOAP_FMAC2 soap_get_PointerTosgs__GetNthDataSourceResponse(struct soap *soap, struct sgs__GetNthDataSourceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__GetNthDataSourceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__GetNthDataSourceResponse ** SOAP_FMAC2 soap_in_PointerTosgs__GetNthDataSourceResponse(struct soap *soap, const char *tag, struct sgs__GetNthDataSourceResponse **a, const char *type)
{
	struct sgs__GetNthDataSourceResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct sgs__GetNthDataSourceResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__GetNthDataSourceResponse, sizeof(struct sgs__GetNthDataSourceResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_sgs__GetNthDataSourceResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_sgs__GetNthDataSourceResponse(soap, tag, NULL, type)))
		{	a = (struct sgs__GetNthDataSourceResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTosgs__GetNthDataSourceResponse, sizeof(struct sgs__GetNthDataSourceResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct sgs__GetNthDataSourceResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__GetNthDataSourceResponse, sizeof(struct sgs__GetNthDataSourceResponse *), 1), SOAP_TYPE_sgs__GetNthDataSourceResponse, sizeof(struct sgs__GetNthDataSourceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTosgs__AttachResponse(struct soap *soap, struct sgs__AttachResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTosgs__AttachResponse))
		soap_mark_PointerTosgs__AttachResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTosgs__AttachResponse(struct soap *soap, struct sgs__AttachResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__AttachResponse))
		soap_mark_sgs__AttachResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTosgs__AttachResponse(struct soap *soap, struct sgs__AttachResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTosgs__AttachResponse(struct soap *soap, struct sgs__AttachResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTosgs__AttachResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTosgs__AttachResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTosgs__AttachResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTosgs__AttachResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTosgs__AttachResponse(struct soap *soap, const char *tag, int id, struct sgs__AttachResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTosgs__AttachResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_sgs__AttachResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_sgs__AttachResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_sgs__AttachResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_sgs__AttachResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_sgs__AttachResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__AttachResponse ** SOAP_FMAC2 soap_get_PointerTosgs__AttachResponse(struct soap *soap, struct sgs__AttachResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__AttachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__AttachResponse ** SOAP_FMAC2 soap_in_PointerTosgs__AttachResponse(struct soap *soap, const char *tag, struct sgs__AttachResponse **a, const char *type)
{
	struct sgs__AttachResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct sgs__AttachResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__AttachResponse, sizeof(struct sgs__AttachResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_sgs__AttachResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_sgs__AttachResponse(soap, tag, NULL, type)))
		{	a = (struct sgs__AttachResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTosgs__AttachResponse, sizeof(struct sgs__AttachResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct sgs__AttachResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__AttachResponse, sizeof(struct sgs__AttachResponse *), 1), SOAP_TYPE_sgs__AttachResponse, sizeof(struct sgs__AttachResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTosgs__RestartResponse(struct soap *soap, struct sgs__RestartResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTosgs__RestartResponse))
		soap_mark_PointerTosgs__RestartResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTosgs__RestartResponse(struct soap *soap, struct sgs__RestartResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__RestartResponse))
		soap_mark_sgs__RestartResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTosgs__RestartResponse(struct soap *soap, struct sgs__RestartResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTosgs__RestartResponse(struct soap *soap, struct sgs__RestartResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTosgs__RestartResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTosgs__RestartResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTosgs__RestartResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTosgs__RestartResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTosgs__RestartResponse(struct soap *soap, const char *tag, int id, struct sgs__RestartResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTosgs__RestartResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_sgs__RestartResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_sgs__RestartResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_sgs__RestartResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_sgs__RestartResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_sgs__RestartResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__RestartResponse ** SOAP_FMAC2 soap_get_PointerTosgs__RestartResponse(struct soap *soap, struct sgs__RestartResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__RestartResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__RestartResponse ** SOAP_FMAC2 soap_in_PointerTosgs__RestartResponse(struct soap *soap, const char *tag, struct sgs__RestartResponse **a, const char *type)
{
	struct sgs__RestartResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct sgs__RestartResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__RestartResponse, sizeof(struct sgs__RestartResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_sgs__RestartResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_sgs__RestartResponse(soap, tag, NULL, type)))
		{	a = (struct sgs__RestartResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTosgs__RestartResponse, sizeof(struct sgs__RestartResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct sgs__RestartResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__RestartResponse, sizeof(struct sgs__RestartResponse *), 1), SOAP_TYPE_sgs__RestartResponse, sizeof(struct sgs__RestartResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTosgs__GetStatusResponse(struct soap *soap, struct sgs__GetStatusResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTosgs__GetStatusResponse))
		soap_mark_PointerTosgs__GetStatusResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTosgs__GetStatusResponse(struct soap *soap, struct sgs__GetStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__GetStatusResponse))
		soap_mark_sgs__GetStatusResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTosgs__GetStatusResponse(struct soap *soap, struct sgs__GetStatusResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTosgs__GetStatusResponse(struct soap *soap, struct sgs__GetStatusResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTosgs__GetStatusResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTosgs__GetStatusResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTosgs__GetStatusResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTosgs__GetStatusResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTosgs__GetStatusResponse(struct soap *soap, const char *tag, int id, struct sgs__GetStatusResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTosgs__GetStatusResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_sgs__GetStatusResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_sgs__GetStatusResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_sgs__GetStatusResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_sgs__GetStatusResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_sgs__GetStatusResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__GetStatusResponse ** SOAP_FMAC2 soap_get_PointerTosgs__GetStatusResponse(struct soap *soap, struct sgs__GetStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__GetStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__GetStatusResponse ** SOAP_FMAC2 soap_in_PointerTosgs__GetStatusResponse(struct soap *soap, const char *tag, struct sgs__GetStatusResponse **a, const char *type)
{
	struct sgs__GetStatusResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct sgs__GetStatusResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__GetStatusResponse, sizeof(struct sgs__GetStatusResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_sgs__GetStatusResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_sgs__GetStatusResponse(soap, tag, NULL, type)))
		{	a = (struct sgs__GetStatusResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTosgs__GetStatusResponse, sizeof(struct sgs__GetStatusResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct sgs__GetStatusResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__GetStatusResponse, sizeof(struct sgs__GetStatusResponse *), 1), SOAP_TYPE_sgs__GetStatusResponse, sizeof(struct sgs__GetStatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTosgs__GetControlResponse(struct soap *soap, struct sgs__GetControlResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTosgs__GetControlResponse))
		soap_mark_PointerTosgs__GetControlResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTosgs__GetControlResponse(struct soap *soap, struct sgs__GetControlResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__GetControlResponse))
		soap_mark_sgs__GetControlResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTosgs__GetControlResponse(struct soap *soap, struct sgs__GetControlResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTosgs__GetControlResponse(struct soap *soap, struct sgs__GetControlResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTosgs__GetControlResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTosgs__GetControlResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTosgs__GetControlResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTosgs__GetControlResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTosgs__GetControlResponse(struct soap *soap, const char *tag, int id, struct sgs__GetControlResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTosgs__GetControlResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_sgs__GetControlResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_sgs__GetControlResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_sgs__GetControlResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_sgs__GetControlResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_sgs__GetControlResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__GetControlResponse ** SOAP_FMAC2 soap_get_PointerTosgs__GetControlResponse(struct soap *soap, struct sgs__GetControlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__GetControlResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__GetControlResponse ** SOAP_FMAC2 soap_in_PointerTosgs__GetControlResponse(struct soap *soap, const char *tag, struct sgs__GetControlResponse **a, const char *type)
{
	struct sgs__GetControlResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct sgs__GetControlResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__GetControlResponse, sizeof(struct sgs__GetControlResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_sgs__GetControlResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_sgs__GetControlResponse(soap, tag, NULL, type)))
		{	a = (struct sgs__GetControlResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTosgs__GetControlResponse, sizeof(struct sgs__GetControlResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct sgs__GetControlResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__GetControlResponse, sizeof(struct sgs__GetControlResponse *), 1), SOAP_TYPE_sgs__GetControlResponse, sizeof(struct sgs__GetControlResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTosgs__AppStopResponse(struct soap *soap, struct sgs__AppStopResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTosgs__AppStopResponse))
		soap_mark_PointerTosgs__AppStopResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTosgs__AppStopResponse(struct soap *soap, struct sgs__AppStopResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__AppStopResponse))
		soap_mark_sgs__AppStopResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTosgs__AppStopResponse(struct soap *soap, struct sgs__AppStopResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTosgs__AppStopResponse(struct soap *soap, struct sgs__AppStopResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTosgs__AppStopResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTosgs__AppStopResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTosgs__AppStopResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTosgs__AppStopResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTosgs__AppStopResponse(struct soap *soap, const char *tag, int id, struct sgs__AppStopResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTosgs__AppStopResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_sgs__AppStopResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_sgs__AppStopResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_sgs__AppStopResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_sgs__AppStopResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_sgs__AppStopResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__AppStopResponse ** SOAP_FMAC2 soap_get_PointerTosgs__AppStopResponse(struct soap *soap, struct sgs__AppStopResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__AppStopResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__AppStopResponse ** SOAP_FMAC2 soap_in_PointerTosgs__AppStopResponse(struct soap *soap, const char *tag, struct sgs__AppStopResponse **a, const char *type)
{
	struct sgs__AppStopResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct sgs__AppStopResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__AppStopResponse, sizeof(struct sgs__AppStopResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_sgs__AppStopResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_sgs__AppStopResponse(soap, tag, NULL, type)))
		{	a = (struct sgs__AppStopResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTosgs__AppStopResponse, sizeof(struct sgs__AppStopResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct sgs__AppStopResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__AppStopResponse, sizeof(struct sgs__AppStopResponse *), 1), SOAP_TYPE_sgs__AppStopResponse, sizeof(struct sgs__AppStopResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTosgs__PutStatusResponse(struct soap *soap, struct sgs__PutStatusResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTosgs__PutStatusResponse))
		soap_mark_PointerTosgs__PutStatusResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTosgs__PutStatusResponse(struct soap *soap, struct sgs__PutStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__PutStatusResponse))
		soap_mark_sgs__PutStatusResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTosgs__PutStatusResponse(struct soap *soap, struct sgs__PutStatusResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTosgs__PutStatusResponse(struct soap *soap, struct sgs__PutStatusResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTosgs__PutStatusResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTosgs__PutStatusResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTosgs__PutStatusResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTosgs__PutStatusResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTosgs__PutStatusResponse(struct soap *soap, const char *tag, int id, struct sgs__PutStatusResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTosgs__PutStatusResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_sgs__PutStatusResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_sgs__PutStatusResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_sgs__PutStatusResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_sgs__PutStatusResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_sgs__PutStatusResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__PutStatusResponse ** SOAP_FMAC2 soap_get_PointerTosgs__PutStatusResponse(struct soap *soap, struct sgs__PutStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__PutStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__PutStatusResponse ** SOAP_FMAC2 soap_in_PointerTosgs__PutStatusResponse(struct soap *soap, const char *tag, struct sgs__PutStatusResponse **a, const char *type)
{
	struct sgs__PutStatusResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct sgs__PutStatusResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__PutStatusResponse, sizeof(struct sgs__PutStatusResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_sgs__PutStatusResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_sgs__PutStatusResponse(soap, tag, NULL, type)))
		{	a = (struct sgs__PutStatusResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTosgs__PutStatusResponse, sizeof(struct sgs__PutStatusResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct sgs__PutStatusResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__PutStatusResponse, sizeof(struct sgs__PutStatusResponse *), 1), SOAP_TYPE_sgs__PutStatusResponse, sizeof(struct sgs__PutStatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTosgs__AppDetachResponse(struct soap *soap, struct sgs__AppDetachResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTosgs__AppDetachResponse))
		soap_mark_PointerTosgs__AppDetachResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTosgs__AppDetachResponse(struct soap *soap, struct sgs__AppDetachResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__AppDetachResponse))
		soap_mark_sgs__AppDetachResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTosgs__AppDetachResponse(struct soap *soap, struct sgs__AppDetachResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTosgs__AppDetachResponse(struct soap *soap, struct sgs__AppDetachResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTosgs__AppDetachResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTosgs__AppDetachResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTosgs__AppDetachResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTosgs__AppDetachResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTosgs__AppDetachResponse(struct soap *soap, const char *tag, int id, struct sgs__AppDetachResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTosgs__AppDetachResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_sgs__AppDetachResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_sgs__AppDetachResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_sgs__AppDetachResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_sgs__AppDetachResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_sgs__AppDetachResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__AppDetachResponse ** SOAP_FMAC2 soap_get_PointerTosgs__AppDetachResponse(struct soap *soap, struct sgs__AppDetachResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__AppDetachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__AppDetachResponse ** SOAP_FMAC2 soap_in_PointerTosgs__AppDetachResponse(struct soap *soap, const char *tag, struct sgs__AppDetachResponse **a, const char *type)
{
	struct sgs__AppDetachResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct sgs__AppDetachResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__AppDetachResponse, sizeof(struct sgs__AppDetachResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_sgs__AppDetachResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_sgs__AppDetachResponse(soap, tag, NULL, type)))
		{	a = (struct sgs__AppDetachResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTosgs__AppDetachResponse, sizeof(struct sgs__AppDetachResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct sgs__AppDetachResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__AppDetachResponse, sizeof(struct sgs__AppDetachResponse *), 1), SOAP_TYPE_sgs__AppDetachResponse, sizeof(struct sgs__AppDetachResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTosgs__destroyResponse(struct soap *soap, struct sgs__destroyResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTosgs__destroyResponse))
		soap_mark_PointerTosgs__destroyResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTosgs__destroyResponse(struct soap *soap, struct sgs__destroyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__destroyResponse))
		soap_mark_sgs__destroyResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTosgs__destroyResponse(struct soap *soap, struct sgs__destroyResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTosgs__destroyResponse(struct soap *soap, struct sgs__destroyResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTosgs__destroyResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTosgs__destroyResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTosgs__destroyResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTosgs__destroyResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTosgs__destroyResponse(struct soap *soap, const char *tag, int id, struct sgs__destroyResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTosgs__destroyResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_sgs__destroyResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_sgs__destroyResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_sgs__destroyResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_sgs__destroyResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_sgs__destroyResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__destroyResponse ** SOAP_FMAC2 soap_get_PointerTosgs__destroyResponse(struct soap *soap, struct sgs__destroyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__destroyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__destroyResponse ** SOAP_FMAC2 soap_in_PointerTosgs__destroyResponse(struct soap *soap, const char *tag, struct sgs__destroyResponse **a, const char *type)
{
	struct sgs__destroyResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct sgs__destroyResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__destroyResponse, sizeof(struct sgs__destroyResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_sgs__destroyResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_sgs__destroyResponse(soap, tag, NULL, type)))
		{	a = (struct sgs__destroyResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTosgs__destroyResponse, sizeof(struct sgs__destroyResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct sgs__destroyResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__destroyResponse, sizeof(struct sgs__destroyResponse *), 1), SOAP_TYPE_sgs__destroyResponse, sizeof(struct sgs__destroyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTosgs__setServiceDataResponse(struct soap *soap, struct sgs__setServiceDataResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTosgs__setServiceDataResponse))
		soap_mark_PointerTosgs__setServiceDataResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTosgs__setServiceDataResponse(struct soap *soap, struct sgs__setServiceDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_sgs__setServiceDataResponse))
		soap_mark_sgs__setServiceDataResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTosgs__setServiceDataResponse(struct soap *soap, struct sgs__setServiceDataResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTosgs__setServiceDataResponse(struct soap *soap, struct sgs__setServiceDataResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTosgs__setServiceDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTosgs__setServiceDataResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTosgs__setServiceDataResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTosgs__setServiceDataResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTosgs__setServiceDataResponse(struct soap *soap, const char *tag, int id, struct sgs__setServiceDataResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTosgs__setServiceDataResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_sgs__setServiceDataResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_sgs__setServiceDataResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_sgs__setServiceDataResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_sgs__setServiceDataResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_sgs__setServiceDataResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct sgs__setServiceDataResponse ** SOAP_FMAC2 soap_get_PointerTosgs__setServiceDataResponse(struct soap *soap, struct sgs__setServiceDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosgs__setServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct sgs__setServiceDataResponse ** SOAP_FMAC2 soap_in_PointerTosgs__setServiceDataResponse(struct soap *soap, const char *tag, struct sgs__setServiceDataResponse **a, const char *type)
{
	struct sgs__setServiceDataResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct sgs__setServiceDataResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__setServiceDataResponse, sizeof(struct sgs__setServiceDataResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_sgs__setServiceDataResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_sgs__setServiceDataResponse(soap, tag, NULL, type)))
		{	a = (struct sgs__setServiceDataResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTosgs__setServiceDataResponse, sizeof(struct sgs__setServiceDataResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct sgs__setServiceDataResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTosgs__setServiceDataResponse, sizeof(struct sgs__setServiceDataResponse *), 1), SOAP_TYPE_sgs__setServiceDataResponse, sizeof(struct sgs__setServiceDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsd__string(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsd__string
	*a = SOAP_DEFAULT_xsd__string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsd__string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__string);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsd__string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__string);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsd__string(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsd__string, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsd__string(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsd__string(soap, tag, i, a, type);
		}
	else
		soap_out_xsd__string(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsd__string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__string);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsd__string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsd__string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__string, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_string(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_string(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_string, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_string(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_string(soap, tag, i, a, type);
		}
	else
		soap_out_string(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1);
}
#ifdef __cplusplus
}
#endif

/* end of soapC.c */
