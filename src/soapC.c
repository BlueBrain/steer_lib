/* soapC.c
   Generated by gSOAP 2.1.10d from SGS.h
   Copyright (C) 2001-2002 Robert A. van Engelen, Florida State University.
   All Rights Reserved.
*/
#include "soapH.h"
#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.1.10d 2003-05-02 15:15:17 GMT")


SOAP_FMAC1 void SOAP_FMAC2 soap_serializeheader(struct soap *soap)
{
	soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->is_in_header = 1;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->is_in_header = 0;
	}
}

SOAP_FMAC1 int SOAP_FMAC2 soap_getheader(struct soap *soap)
{
	soap->is_in_header = 1;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->is_in_header = 0;
	return soap->header == NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serializefault(struct soap *soap)
{
	soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_putfault(struct soap *soap)
{
	soap_out_SOAP_ENV__Fault(soap, "SOAP-ENV:Fault", 0, soap->fault, NULL);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_in_SOAP_ENV__Fault(soap, "SOAP-ENV:Fault", NULL, NULL)) == NULL;
}

SOAP_FMAC1 const char ** SOAP_FMAC2 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC1 const char ** SOAP_FMAC2 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC1 const char ** SOAP_FMAC2 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Detail;
	return (const char**)&soap->fault->detail;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_getindependent(struct soap *soap)
{
	for (;;)
	{	if (soap_peek_element(soap))
			break;
		switch (soap_lookup_type(soap, soap->id))
		{
		case SOAP_byte:
			soap_in_byte(soap, NULL, NULL, "");
			break;
		case SOAP_int:
			soap_in_int(soap, NULL, NULL, "");
			break;
		case SOAP_SOAP_ENV__Fault:
			soap_in_SOAP_ENV__Fault(soap, NULL, NULL, "");
			break;
		case SOAP_SOAP_ENV__Code:
			soap_in_SOAP_ENV__Code(soap, NULL, NULL, "");
			break;
		case SOAP_SOAP_ENV__Header:
			soap_in_SOAP_ENV__Header(soap, NULL, NULL, "");
			break;
		case SOAP_tns__GetControl:
			soap_in_tns__GetControl(soap, NULL, NULL, "tns:GetControl");
			break;
		case SOAP_tns__AppAttach:
			soap_in_tns__AppAttach(soap, NULL, NULL, "tns:AppAttach");
			break;
		case SOAP_tns__Attach:
			soap_in_tns__Attach(soap, NULL, NULL, "tns:Attach");
			break;
		case SOAP_tns__FindServiceData:
			soap_in_tns__FindServiceData(soap, NULL, NULL, "tns:FindServiceData");
			break;
		case SOAP_tns__SetTerminationTime:
			soap_in_tns__SetTerminationTime(soap, NULL, NULL, "tns:SetTerminationTime");
			break;
		case SOAP_tns__Destroy:
			soap_in_tns__Destroy(soap, NULL, NULL, "tns:Destroy");
			break;
		case SOAP_tns__PutControl:
			soap_in_tns__PutControl(soap, NULL, NULL, "tns:PutControl");
			break;
		case SOAP_tns__Resume:
			soap_in_tns__Resume(soap, NULL, NULL, "tns:Resume");
			break;
		case SOAP_tns__GetStatus:
			soap_in_tns__GetStatus(soap, NULL, NULL, "tns:GetStatus");
			break;
		case SOAP_tns__PutStatus:
			soap_in_tns__PutStatus(soap, NULL, NULL, "tns:PutStatus");
			break;
		case SOAP_tns__Stop:
			soap_in_tns__Stop(soap, NULL, NULL, "tns:Stop");
			break;
		case SOAP_tns__Pause:
			soap_in_tns__Pause(soap, NULL, NULL, "tns:Pause");
			break;
		case SOAP_tns__SetServiceData:
			soap_in_tns__SetServiceData(soap, NULL, NULL, "tns:SetServiceData");
			break;
		case SOAP_tns__GetNotifications:
			soap_in_tns__GetNotifications(soap, NULL, NULL, "tns:GetNotifications");
			break;
		case SOAP_tns__Detach:
			soap_in_tns__Detach(soap, NULL, NULL, "tns:Detach");
			break;
		case SOAP_tns__AppDetach:
			soap_in_tns__AppDetach(soap, NULL, NULL, "tns:AppDetach");
			break;
		case SOAP_tns__AttachResponse:
			soap_in_tns__AttachResponse(soap, NULL, NULL, "tns:AttachResponse");
			break;
		case SOAP_tns__GetNotificationsResponse:
			soap_in_tns__GetNotificationsResponse(soap, NULL, NULL, "tns:GetNotificationsResponse");
			break;
		case SOAP_tns__AppDetachResponse:
			soap_in_tns__AppDetachResponse(soap, NULL, NULL, "tns:AppDetachResponse");
			break;
		case SOAP_tns__FindServiceDataResponse:
			soap_in_tns__FindServiceDataResponse(soap, NULL, NULL, "tns:FindServiceDataResponse");
			break;
		case SOAP_tns__PutControlResponse:
			soap_in_tns__PutControlResponse(soap, NULL, NULL, "tns:PutControlResponse");
			break;
		case SOAP_tns__DetachResponse:
			soap_in_tns__DetachResponse(soap, NULL, NULL, "tns:DetachResponse");
			break;
		case SOAP_tns__SetTerminationTimeResponse:
			soap_in_tns__SetTerminationTimeResponse(soap, NULL, NULL, "tns:SetTerminationTimeResponse");
			break;
		case SOAP_tns__SetServiceDataResponse:
			soap_in_tns__SetServiceDataResponse(soap, NULL, NULL, "tns:SetServiceDataResponse");
			break;
		case SOAP_tns__DestroyResponse:
			soap_in_tns__DestroyResponse(soap, NULL, NULL, "tns:DestroyResponse");
			break;
		case SOAP_tns__AppAttachResponse:
			soap_in_tns__AppAttachResponse(soap, NULL, NULL, "tns:AppAttachResponse");
			break;
		case SOAP_tns__PutStatusResponse:
			soap_in_tns__PutStatusResponse(soap, NULL, NULL, "tns:PutStatusResponse");
			break;
		case SOAP_tns__ResumeResponse:
			soap_in_tns__ResumeResponse(soap, NULL, NULL, "tns:ResumeResponse");
			break;
		case SOAP_tns__StopResponse:
			soap_in_tns__StopResponse(soap, NULL, NULL, "tns:StopResponse");
			break;
		case SOAP_tns__PauseResponse:
			soap_in_tns__PauseResponse(soap, NULL, NULL, "tns:PauseResponse");
			break;
		case SOAP_tns__GetStatusResponse:
			soap_in_tns__GetStatusResponse(soap, NULL, NULL, "tns:GetStatusResponse");
			break;
		case SOAP_tns__GetControlResponse:
			soap_in_tns__GetControlResponse(soap, NULL, NULL, "tns:GetControlResponse");
			break;
		case SOAP_PointerToSOAP_ENV__Code:
			soap_in_PointerToSOAP_ENV__Code(soap, NULL, NULL, "");
			break;
		case SOAP_PointerTotns__GetControlResponse:
			soap_in_PointerTotns__GetControlResponse(soap, NULL, NULL, "tns:GetControlResponse");
			break;
		case SOAP_PointerTotns__AppAttachResponse:
			soap_in_PointerTotns__AppAttachResponse(soap, NULL, NULL, "tns:AppAttachResponse");
			break;
		case SOAP_PointerTotns__AttachResponse:
			soap_in_PointerTotns__AttachResponse(soap, NULL, NULL, "tns:AttachResponse");
			break;
		case SOAP_PointerTotns__FindServiceDataResponse:
			soap_in_PointerTotns__FindServiceDataResponse(soap, NULL, NULL, "tns:FindServiceDataResponse");
			break;
		case SOAP_PointerTotns__SetTerminationTimeResponse:
			soap_in_PointerTotns__SetTerminationTimeResponse(soap, NULL, NULL, "tns:SetTerminationTimeResponse");
			break;
		case SOAP_PointerTotns__DestroyResponse:
			soap_in_PointerTotns__DestroyResponse(soap, NULL, NULL, "tns:DestroyResponse");
			break;
		case SOAP_PointerTotns__PutControlResponse:
			soap_in_PointerTotns__PutControlResponse(soap, NULL, NULL, "tns:PutControlResponse");
			break;
		case SOAP_PointerTotns__ResumeResponse:
			soap_in_PointerTotns__ResumeResponse(soap, NULL, NULL, "tns:ResumeResponse");
			break;
		case SOAP_PointerTotns__GetStatusResponse:
			soap_in_PointerTotns__GetStatusResponse(soap, NULL, NULL, "tns:GetStatusResponse");
			break;
		case SOAP_PointerTotns__PutStatusResponse:
			soap_in_PointerTotns__PutStatusResponse(soap, NULL, NULL, "tns:PutStatusResponse");
			break;
		case SOAP_PointerTotns__StopResponse:
			soap_in_PointerTotns__StopResponse(soap, NULL, NULL, "tns:StopResponse");
			break;
		case SOAP_PointerTotns__PauseResponse:
			soap_in_PointerTotns__PauseResponse(soap, NULL, NULL, "tns:PauseResponse");
			break;
		case SOAP_PointerTotns__SetServiceDataResponse:
			soap_in_PointerTotns__SetServiceDataResponse(soap, NULL, NULL, "tns:SetServiceDataResponse");
			break;
		case SOAP_PointerTotns__GetNotificationsResponse:
			soap_in_PointerTotns__GetNotificationsResponse(soap, NULL, NULL, "tns:GetNotificationsResponse");
			break;
		case SOAP_PointerTotns__DetachResponse:
			soap_in_PointerTotns__DetachResponse(soap, NULL, NULL, "tns:DetachResponse");
			break;
		case SOAP_PointerTotns__AppDetachResponse:
			soap_in_PointerTotns__AppDetachResponse(soap, NULL, NULL, "tns:AppDetachResponse");
			break;
		case SOAP_xsd__string:
			soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
			break;
		case SOAP_string:
			soap_in_string(soap, NULL, NULL, "");
			break;
		default:
			if (!*soap->id)
			{	if (soap_ignore_element(soap))
					break;
				else
					continue;
			}
			soap_in_byte(soap, NULL, NULL, "xsd:byte");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_int(soap, NULL, NULL, "xsd:int");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_SOAP_ENV__Fault(soap, NULL, NULL, "SOAP-ENV:Fault");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_SOAP_ENV__Code(soap, NULL, NULL, "SOAP-ENV:Code");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_SOAP_ENV__Header(soap, NULL, NULL, "SOAP-ENV:Header");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__GetControl(soap, NULL, NULL, "tns:GetControl");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__AppAttach(soap, NULL, NULL, "tns:AppAttach");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__Attach(soap, NULL, NULL, "tns:Attach");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__FindServiceData(soap, NULL, NULL, "tns:FindServiceData");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__SetTerminationTime(soap, NULL, NULL, "tns:SetTerminationTime");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__Destroy(soap, NULL, NULL, "tns:Destroy");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__PutControl(soap, NULL, NULL, "tns:PutControl");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__Resume(soap, NULL, NULL, "tns:Resume");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__GetStatus(soap, NULL, NULL, "tns:GetStatus");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__PutStatus(soap, NULL, NULL, "tns:PutStatus");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__Stop(soap, NULL, NULL, "tns:Stop");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__Pause(soap, NULL, NULL, "tns:Pause");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__SetServiceData(soap, NULL, NULL, "tns:SetServiceData");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__GetNotifications(soap, NULL, NULL, "tns:GetNotifications");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__Detach(soap, NULL, NULL, "tns:Detach");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__AppDetach(soap, NULL, NULL, "tns:AppDetach");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__AttachResponse(soap, NULL, NULL, "tns:AttachResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__GetNotificationsResponse(soap, NULL, NULL, "tns:GetNotificationsResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__AppDetachResponse(soap, NULL, NULL, "tns:AppDetachResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__FindServiceDataResponse(soap, NULL, NULL, "tns:FindServiceDataResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__PutControlResponse(soap, NULL, NULL, "tns:PutControlResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__DetachResponse(soap, NULL, NULL, "tns:DetachResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__SetTerminationTimeResponse(soap, NULL, NULL, "tns:SetTerminationTimeResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__SetServiceDataResponse(soap, NULL, NULL, "tns:SetServiceDataResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__DestroyResponse(soap, NULL, NULL, "tns:DestroyResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__AppAttachResponse(soap, NULL, NULL, "tns:AppAttachResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__PutStatusResponse(soap, NULL, NULL, "tns:PutStatusResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__ResumeResponse(soap, NULL, NULL, "tns:ResumeResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__StopResponse(soap, NULL, NULL, "tns:StopResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__PauseResponse(soap, NULL, NULL, "tns:PauseResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__GetStatusResponse(soap, NULL, NULL, "tns:GetStatusResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__GetControlResponse(soap, NULL, NULL, "tns:GetControlResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_string(soap, NULL, NULL, "xsd:string");
			if (soap->error)
			{	soap->peeked = 1;
				soap_ignore_element(soap);
			}
		}
		if (soap->error)
			break;
	}
	if (soap->error == SOAP_NO_TAG)
		soap->error = SOAP_OK;
	return soap->error;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->enable_embedding || soap->disable_href)
		return;
	for (i = 0; i < SOAP_PTRHASH; i++)
		for (pp = soap->pht[i]; pp; pp = pp->next)
			if (soap->counting ? pp->mark1 == 2 : pp->mark2 == 2)
				switch (pp->type)
				{
				case SOAP_byte:
					soap_out_byte(soap, "id", pp->id, (const char *)pp->ptr, "xsd:byte");
					break;
				case SOAP_int:
					soap_out_int(soap, "id", pp->id, (const int *)pp->ptr, "xsd:int");
					break;
				case SOAP_SOAP_ENV__Fault:
					soap_out_SOAP_ENV__Fault(soap, "id", pp->id, (const struct SOAP_ENV__Fault *)pp->ptr, "SOAP-ENV:Fault");
					break;
				case SOAP_SOAP_ENV__Code:
					soap_out_SOAP_ENV__Code(soap, "id", pp->id, (const struct SOAP_ENV__Code *)pp->ptr, "SOAP-ENV:Code");
					break;
				case SOAP_SOAP_ENV__Header:
					soap_out_SOAP_ENV__Header(soap, "id", pp->id, (const struct SOAP_ENV__Header *)pp->ptr, "SOAP-ENV:Header");
					break;
				case SOAP_tns__GetControl:
					soap_out_tns__GetControl(soap, "id", pp->id, (const struct tns__GetControl *)pp->ptr, "tns:GetControl");
					break;
				case SOAP_tns__AppAttach:
					soap_out_tns__AppAttach(soap, "id", pp->id, (const struct tns__AppAttach *)pp->ptr, "tns:AppAttach");
					break;
				case SOAP_tns__Attach:
					soap_out_tns__Attach(soap, "id", pp->id, (const struct tns__Attach *)pp->ptr, "tns:Attach");
					break;
				case SOAP_tns__FindServiceData:
					soap_out_tns__FindServiceData(soap, "id", pp->id, (const struct tns__FindServiceData *)pp->ptr, "tns:FindServiceData");
					break;
				case SOAP_tns__SetTerminationTime:
					soap_out_tns__SetTerminationTime(soap, "id", pp->id, (const struct tns__SetTerminationTime *)pp->ptr, "tns:SetTerminationTime");
					break;
				case SOAP_tns__Destroy:
					soap_out_tns__Destroy(soap, "id", pp->id, (const struct tns__Destroy *)pp->ptr, "tns:Destroy");
					break;
				case SOAP_tns__PutControl:
					soap_out_tns__PutControl(soap, "id", pp->id, (const struct tns__PutControl *)pp->ptr, "tns:PutControl");
					break;
				case SOAP_tns__Resume:
					soap_out_tns__Resume(soap, "id", pp->id, (const struct tns__Resume *)pp->ptr, "tns:Resume");
					break;
				case SOAP_tns__GetStatus:
					soap_out_tns__GetStatus(soap, "id", pp->id, (const struct tns__GetStatus *)pp->ptr, "tns:GetStatus");
					break;
				case SOAP_tns__PutStatus:
					soap_out_tns__PutStatus(soap, "id", pp->id, (const struct tns__PutStatus *)pp->ptr, "tns:PutStatus");
					break;
				case SOAP_tns__Stop:
					soap_out_tns__Stop(soap, "id", pp->id, (const struct tns__Stop *)pp->ptr, "tns:Stop");
					break;
				case SOAP_tns__Pause:
					soap_out_tns__Pause(soap, "id", pp->id, (const struct tns__Pause *)pp->ptr, "tns:Pause");
					break;
				case SOAP_tns__SetServiceData:
					soap_out_tns__SetServiceData(soap, "id", pp->id, (const struct tns__SetServiceData *)pp->ptr, "tns:SetServiceData");
					break;
				case SOAP_tns__GetNotifications:
					soap_out_tns__GetNotifications(soap, "id", pp->id, (const struct tns__GetNotifications *)pp->ptr, "tns:GetNotifications");
					break;
				case SOAP_tns__Detach:
					soap_out_tns__Detach(soap, "id", pp->id, (const struct tns__Detach *)pp->ptr, "tns:Detach");
					break;
				case SOAP_tns__AppDetach:
					soap_out_tns__AppDetach(soap, "id", pp->id, (const struct tns__AppDetach *)pp->ptr, "tns:AppDetach");
					break;
				case SOAP_tns__AttachResponse:
					soap_out_tns__AttachResponse(soap, "id", pp->id, (const struct tns__AttachResponse *)pp->ptr, "tns:AttachResponse");
					break;
				case SOAP_tns__GetNotificationsResponse:
					soap_out_tns__GetNotificationsResponse(soap, "id", pp->id, (const struct tns__GetNotificationsResponse *)pp->ptr, "tns:GetNotificationsResponse");
					break;
				case SOAP_tns__AppDetachResponse:
					soap_out_tns__AppDetachResponse(soap, "id", pp->id, (const struct tns__AppDetachResponse *)pp->ptr, "tns:AppDetachResponse");
					break;
				case SOAP_tns__FindServiceDataResponse:
					soap_out_tns__FindServiceDataResponse(soap, "id", pp->id, (const struct tns__FindServiceDataResponse *)pp->ptr, "tns:FindServiceDataResponse");
					break;
				case SOAP_tns__PutControlResponse:
					soap_out_tns__PutControlResponse(soap, "id", pp->id, (const struct tns__PutControlResponse *)pp->ptr, "tns:PutControlResponse");
					break;
				case SOAP_tns__DetachResponse:
					soap_out_tns__DetachResponse(soap, "id", pp->id, (const struct tns__DetachResponse *)pp->ptr, "tns:DetachResponse");
					break;
				case SOAP_tns__SetTerminationTimeResponse:
					soap_out_tns__SetTerminationTimeResponse(soap, "id", pp->id, (const struct tns__SetTerminationTimeResponse *)pp->ptr, "tns:SetTerminationTimeResponse");
					break;
				case SOAP_tns__SetServiceDataResponse:
					soap_out_tns__SetServiceDataResponse(soap, "id", pp->id, (const struct tns__SetServiceDataResponse *)pp->ptr, "tns:SetServiceDataResponse");
					break;
				case SOAP_tns__DestroyResponse:
					soap_out_tns__DestroyResponse(soap, "id", pp->id, (const struct tns__DestroyResponse *)pp->ptr, "tns:DestroyResponse");
					break;
				case SOAP_tns__AppAttachResponse:
					soap_out_tns__AppAttachResponse(soap, "id", pp->id, (const struct tns__AppAttachResponse *)pp->ptr, "tns:AppAttachResponse");
					break;
				case SOAP_tns__PutStatusResponse:
					soap_out_tns__PutStatusResponse(soap, "id", pp->id, (const struct tns__PutStatusResponse *)pp->ptr, "tns:PutStatusResponse");
					break;
				case SOAP_tns__ResumeResponse:
					soap_out_tns__ResumeResponse(soap, "id", pp->id, (const struct tns__ResumeResponse *)pp->ptr, "tns:ResumeResponse");
					break;
				case SOAP_tns__StopResponse:
					soap_out_tns__StopResponse(soap, "id", pp->id, (const struct tns__StopResponse *)pp->ptr, "tns:StopResponse");
					break;
				case SOAP_tns__PauseResponse:
					soap_out_tns__PauseResponse(soap, "id", pp->id, (const struct tns__PauseResponse *)pp->ptr, "tns:PauseResponse");
					break;
				case SOAP_tns__GetStatusResponse:
					soap_out_tns__GetStatusResponse(soap, "id", pp->id, (const struct tns__GetStatusResponse *)pp->ptr, "tns:GetStatusResponse");
					break;
				case SOAP_tns__GetControlResponse:
					soap_out_tns__GetControlResponse(soap, "id", pp->id, (const struct tns__GetControlResponse *)pp->ptr, "tns:GetControlResponse");
					break;
				case SOAP_xsd__string:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsd:string");
					break;
				case SOAP_string:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsd:string");
					break;
				}
		
	
}

SOAP_FMAC1 int SOAP_FMAC2 soap_getattachments(struct soap *soap)
{
	if (!soap->dime)
		return SOAP_OK;
	while (soap->dime_flags&SOAP_DIME_CF)
	{	if (soap_getdimehdr(soap))
			return soap->error;
		if (soap_move(soap, soap->dime_size))
			return soap->error = SOAP_EOF;
	}
	if (soap_move(soap, ((soap->dime_size+3)&-4)-soap_tell(soap)))
		return soap->error = SOAP_EOF;
	for (;;)
	{	if (soap_getdime(soap) || !soap->dime_id)
			break;
		switch (soap_lookup_type(soap, soap->dime_id))
		{
		case SOAP_xsd__string:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_xsd__string, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_string:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_string, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		default:
			soap->error = SOAP_DIME_ERROR;
		}
		if (soap->error)
			break;
	}
	if (soap->error == SOAP_EOD)
		soap->error = SOAP_OK;
	return soap->error;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_putattachments(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (!soap->dime)
		return;
	soap_send_raw(soap, "\0\0\0", -(int)soap->count&3);
	for (i = 0; i < SOAP_PTRHASH; i++)
		for (pp = soap->pht[i]; pp; pp = pp->next)
			if (pp->mark2 == 3)
				switch (pp->type)
				{
				}
		
	
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_byte(struct soap *soap, char *a)
{
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_byte(struct soap *soap, char const*a)
{
	soap_reference(soap, a, SOAP_byte);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_byte(struct soap *soap, char *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_byte, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_byte(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_byte(soap, tag, i, a, type);
		}
	else
		soap_out_byte(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	soap_outbyte(soap, tag, id, a, type, SOAP_byte);
}

SOAP_FMAC1 char * SOAP_FMAC2 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * SOAP_FMAC2 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_byte);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_int(struct soap *soap, int *a)
{
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_int(struct soap *soap, int const*a)
{
	soap_reference(soap, a, SOAP_int);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_int(struct soap *soap, int *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_int, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_int(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_int(soap, tag, i, a, type);
		}
	else
		soap_out_int(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	soap_outint(soap, tag, id, a, type, SOAP_int);
}

SOAP_FMAC1 int * SOAP_FMAC2 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 int * SOAP_FMAC2 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_int);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault const*a)
{
	if (!soap_reference(soap, a, SOAP_SOAP_ENV__Fault))
		soap_mark_SOAP_ENV__Fault(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	soap_embedded(soap, &a->faultcode, SOAP_string);
	soap_mark_string(soap, &a->faultcode);
	soap_embedded(soap, &a->faultstring, SOAP_string);
	soap_mark_string(soap, &a->faultstring);
	soap_embedded(soap, &a->faultactor, SOAP_string);
	soap_mark_string(soap, &a->faultactor);
	soap_embedded(soap, &a->detail, SOAP_string);
	soap_mark_string(soap, &a->detail);
	soap_embedded(soap, &a->SOAP_ENV__Code, SOAP_PointerToSOAP_ENV__Code);
	soap_mark_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_embedded(soap, &a->SOAP_ENV__Reason, SOAP_string);
	soap_mark_string(soap, &a->SOAP_ENV__Reason);
	soap_embedded(soap, &a->SOAP_ENV__Detail, SOAP_string);
	soap_mark_string(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	soap_default_string(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	soap_default_string(soap, &a->detail);
	soap_default_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_default_string(soap, &a->SOAP_ENV__Reason);
	soap_default_string(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_SOAP_ENV__Fault, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_SOAP_ENV__Fault(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_SOAP_ENV__Fault(soap, tag, i, a, type);
		}
	else
		soap_out_SOAP_ENV__Fault(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_SOAP_ENV__Fault), type);
	soap_out_string(soap, "faultcode", -1, &a->faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_string(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_string(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_string(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Fault(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode = 0;
					continue;
				}
			if (soap_flag_faultstring && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultstring", &a->faultstring, ""))
				{	soap_flag_faultstring = 0;
					continue;
				}
			if (soap_flag_faultactor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultactor", &a->faultactor, ""))
				{	soap_flag_faultactor = 0;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "detail", &a->detail, ""))
				{	soap_flag_detail = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0), SOAP_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault));
		if (soap->alloced)
			soap_default_SOAP_ENV__Fault(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code const*a)
{
	if (!soap_reference(soap, a, SOAP_SOAP_ENV__Code))
		soap_mark_SOAP_ENV__Code(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	soap_embedded(soap, &a->SOAP_ENV__Value, SOAP_string);
	soap_mark_string(soap, &a->SOAP_ENV__Value);
	soap_embedded(soap, &a->SOAP_ENV__Node, SOAP_string);
	soap_mark_string(soap, &a->SOAP_ENV__Node);
	soap_embedded(soap, &a->SOAP_ENV__Role, SOAP_string);
	soap_mark_string(soap, &a->SOAP_ENV__Role);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	soap_default_string(soap, &a->SOAP_ENV__Value);
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_SOAP_ENV__Code, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_SOAP_ENV__Code(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_SOAP_ENV__Code(soap, tag, i, a, type);
		}
	else
		soap_out_SOAP_ENV__Code(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_SOAP_ENV__Code), type);
	soap_out_string(soap, "SOAP-ENV:Value", -1, &a->SOAP_ENV__Value, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Code(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, ""))
				{	soap_flag_SOAP_ENV__Node = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, ""))
				{	soap_flag_SOAP_ENV__Role = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0), SOAP_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code));
		if (soap->alloced)
			soap_default_SOAP_ENV__Code(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header const*a)
{
	if (!soap_reference(soap, a, SOAP_SOAP_ENV__Header))
		soap_mark_SOAP_ENV__Header(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	/* transient dummy skipped */
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	/* transient dummy skipped */
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_SOAP_ENV__Header, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_SOAP_ENV__Header(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_SOAP_ENV__Header(soap, tag, i, a, type);
		}
	else
		soap_out_SOAP_ENV__Header(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_SOAP_ENV__Header), type);
	/* transient dummy skipped */
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Header(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient dummy skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0), SOAP_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header));
		if (soap->alloced)
			soap_default_SOAP_ENV__Header(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__GetControl(struct soap *soap, struct tns__GetControl const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__GetControl))
		soap_mark_tns__GetControl(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__GetControl(struct soap *soap, const struct tns__GetControl *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__GetControl(struct soap *soap, struct tns__GetControl *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__GetControl(struct soap *soap, struct tns__GetControl *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__GetControl, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__GetControl(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__GetControl(soap, tag, i, a, type);
		}
	else
		soap_out_tns__GetControl(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__GetControl(struct soap *soap, const char *tag, int id, const struct tns__GetControl *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__GetControl), type);
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__GetControl * SOAP_FMAC2 soap_get_tns__GetControl(struct soap *soap, struct tns__GetControl *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__GetControl(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__GetControl * SOAP_FMAC2 soap_in_tns__GetControl(struct soap *soap, const char *tag, struct tns__GetControl *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__GetControl *)soap_id_enter(soap, soap->id, a, SOAP_tns__GetControl, sizeof(struct tns__GetControl), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__GetControl(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__GetControl *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__GetControl, sizeof(struct tns__GetControl), 0), SOAP_tns__GetControl, sizeof(struct tns__GetControl));
		if (soap->alloced)
			soap_default_tns__GetControl(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__AppAttach(struct soap *soap, struct tns__AppAttach const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__AppAttach))
		soap_mark_tns__AppAttach(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__AppAttach(struct soap *soap, const struct tns__AppAttach *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__AppAttach(struct soap *soap, struct tns__AppAttach *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__AppAttach(struct soap *soap, struct tns__AppAttach *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__AppAttach, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__AppAttach(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__AppAttach(soap, tag, i, a, type);
		}
	else
		soap_out_tns__AppAttach(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__AppAttach(struct soap *soap, const char *tag, int id, const struct tns__AppAttach *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__AppAttach), type);
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__AppAttach * SOAP_FMAC2 soap_get_tns__AppAttach(struct soap *soap, struct tns__AppAttach *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__AppAttach(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__AppAttach * SOAP_FMAC2 soap_in_tns__AppAttach(struct soap *soap, const char *tag, struct tns__AppAttach *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__AppAttach *)soap_id_enter(soap, soap->id, a, SOAP_tns__AppAttach, sizeof(struct tns__AppAttach), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__AppAttach(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__AppAttach *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__AppAttach, sizeof(struct tns__AppAttach), 0), SOAP_tns__AppAttach, sizeof(struct tns__AppAttach));
		if (soap->alloced)
			soap_default_tns__AppAttach(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__Attach(struct soap *soap, struct tns__Attach const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__Attach))
		soap_mark_tns__Attach(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__Attach(struct soap *soap, const struct tns__Attach *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__Attach(struct soap *soap, struct tns__Attach *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__Attach(struct soap *soap, struct tns__Attach *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__Attach, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__Attach(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__Attach(soap, tag, i, a, type);
		}
	else
		soap_out_tns__Attach(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__Attach(struct soap *soap, const char *tag, int id, const struct tns__Attach *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__Attach), type);
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__Attach * SOAP_FMAC2 soap_get_tns__Attach(struct soap *soap, struct tns__Attach *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__Attach(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__Attach * SOAP_FMAC2 soap_in_tns__Attach(struct soap *soap, const char *tag, struct tns__Attach *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__Attach *)soap_id_enter(soap, soap->id, a, SOAP_tns__Attach, sizeof(struct tns__Attach), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__Attach(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__Attach *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__Attach, sizeof(struct tns__Attach), 0), SOAP_tns__Attach, sizeof(struct tns__Attach));
		if (soap->alloced)
			soap_default_tns__Attach(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__FindServiceData(struct soap *soap, struct tns__FindServiceData const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__FindServiceData))
		soap_mark_tns__FindServiceData(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__FindServiceData(struct soap *soap, const struct tns__FindServiceData *a)
{
	soap_embedded(soap, &a->input, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &a->input);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__FindServiceData(struct soap *soap, struct tns__FindServiceData *a)
{
	soap_default_xsd__string(soap, &a->input);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__FindServiceData(struct soap *soap, struct tns__FindServiceData *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__FindServiceData, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__FindServiceData(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__FindServiceData(soap, tag, i, a, type);
		}
	else
		soap_out_tns__FindServiceData(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__FindServiceData(struct soap *soap, const char *tag, int id, const struct tns__FindServiceData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__FindServiceData), type);
	soap_out_xsd__string(soap, "input", -1, &a->input, "xsd:string");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__FindServiceData * SOAP_FMAC2 soap_get_tns__FindServiceData(struct soap *soap, struct tns__FindServiceData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__FindServiceData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__FindServiceData * SOAP_FMAC2 soap_in_tns__FindServiceData(struct soap *soap, const char *tag, struct tns__FindServiceData *a, const char *type)
{
	short soap_flag_input = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__FindServiceData *)soap_id_enter(soap, soap->id, a, SOAP_tns__FindServiceData, sizeof(struct tns__FindServiceData), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__FindServiceData(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_input && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "input", &a->input, "xsd:string"))
				{	soap_flag_input = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__FindServiceData *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__FindServiceData, sizeof(struct tns__FindServiceData), 0), SOAP_tns__FindServiceData, sizeof(struct tns__FindServiceData));
		if (soap->alloced)
			soap_default_tns__FindServiceData(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__SetTerminationTime(struct soap *soap, struct tns__SetTerminationTime const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__SetTerminationTime))
		soap_mark_tns__SetTerminationTime(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__SetTerminationTime(struct soap *soap, const struct tns__SetTerminationTime *a)
{
	soap_embedded(soap, &a->input, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &a->input);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__SetTerminationTime(struct soap *soap, struct tns__SetTerminationTime *a)
{
	soap_default_xsd__string(soap, &a->input);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__SetTerminationTime(struct soap *soap, struct tns__SetTerminationTime *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__SetTerminationTime, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__SetTerminationTime(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__SetTerminationTime(soap, tag, i, a, type);
		}
	else
		soap_out_tns__SetTerminationTime(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__SetTerminationTime(struct soap *soap, const char *tag, int id, const struct tns__SetTerminationTime *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__SetTerminationTime), type);
	soap_out_xsd__string(soap, "input", -1, &a->input, "xsd:string");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__SetTerminationTime * SOAP_FMAC2 soap_get_tns__SetTerminationTime(struct soap *soap, struct tns__SetTerminationTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__SetTerminationTime(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__SetTerminationTime * SOAP_FMAC2 soap_in_tns__SetTerminationTime(struct soap *soap, const char *tag, struct tns__SetTerminationTime *a, const char *type)
{
	short soap_flag_input = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__SetTerminationTime *)soap_id_enter(soap, soap->id, a, SOAP_tns__SetTerminationTime, sizeof(struct tns__SetTerminationTime), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__SetTerminationTime(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_input && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "input", &a->input, "xsd:string"))
				{	soap_flag_input = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__SetTerminationTime *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__SetTerminationTime, sizeof(struct tns__SetTerminationTime), 0), SOAP_tns__SetTerminationTime, sizeof(struct tns__SetTerminationTime));
		if (soap->alloced)
			soap_default_tns__SetTerminationTime(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__Destroy(struct soap *soap, struct tns__Destroy const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__Destroy))
		soap_mark_tns__Destroy(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__Destroy(struct soap *soap, const struct tns__Destroy *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__Destroy(struct soap *soap, struct tns__Destroy *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__Destroy(struct soap *soap, struct tns__Destroy *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__Destroy, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__Destroy(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__Destroy(soap, tag, i, a, type);
		}
	else
		soap_out_tns__Destroy(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__Destroy(struct soap *soap, const char *tag, int id, const struct tns__Destroy *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__Destroy), type);
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__Destroy * SOAP_FMAC2 soap_get_tns__Destroy(struct soap *soap, struct tns__Destroy *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__Destroy(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__Destroy * SOAP_FMAC2 soap_in_tns__Destroy(struct soap *soap, const char *tag, struct tns__Destroy *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__Destroy *)soap_id_enter(soap, soap->id, a, SOAP_tns__Destroy, sizeof(struct tns__Destroy), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__Destroy(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__Destroy *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__Destroy, sizeof(struct tns__Destroy), 0), SOAP_tns__Destroy, sizeof(struct tns__Destroy));
		if (soap->alloced)
			soap_default_tns__Destroy(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__PutControl(struct soap *soap, struct tns__PutControl const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__PutControl))
		soap_mark_tns__PutControl(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__PutControl(struct soap *soap, const struct tns__PutControl *a)
{
	soap_embedded(soap, &a->input, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &a->input);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__PutControl(struct soap *soap, struct tns__PutControl *a)
{
	soap_default_xsd__string(soap, &a->input);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__PutControl(struct soap *soap, struct tns__PutControl *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__PutControl, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__PutControl(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__PutControl(soap, tag, i, a, type);
		}
	else
		soap_out_tns__PutControl(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__PutControl(struct soap *soap, const char *tag, int id, const struct tns__PutControl *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__PutControl), type);
	soap_out_xsd__string(soap, "input", -1, &a->input, "xsd:string");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__PutControl * SOAP_FMAC2 soap_get_tns__PutControl(struct soap *soap, struct tns__PutControl *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__PutControl(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__PutControl * SOAP_FMAC2 soap_in_tns__PutControl(struct soap *soap, const char *tag, struct tns__PutControl *a, const char *type)
{
	short soap_flag_input = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__PutControl *)soap_id_enter(soap, soap->id, a, SOAP_tns__PutControl, sizeof(struct tns__PutControl), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__PutControl(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_input && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "input", &a->input, "xsd:string"))
				{	soap_flag_input = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__PutControl *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__PutControl, sizeof(struct tns__PutControl), 0), SOAP_tns__PutControl, sizeof(struct tns__PutControl));
		if (soap->alloced)
			soap_default_tns__PutControl(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__Resume(struct soap *soap, struct tns__Resume const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__Resume))
		soap_mark_tns__Resume(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__Resume(struct soap *soap, const struct tns__Resume *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__Resume(struct soap *soap, struct tns__Resume *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__Resume(struct soap *soap, struct tns__Resume *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__Resume, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__Resume(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__Resume(soap, tag, i, a, type);
		}
	else
		soap_out_tns__Resume(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__Resume(struct soap *soap, const char *tag, int id, const struct tns__Resume *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__Resume), type);
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__Resume * SOAP_FMAC2 soap_get_tns__Resume(struct soap *soap, struct tns__Resume *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__Resume(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__Resume * SOAP_FMAC2 soap_in_tns__Resume(struct soap *soap, const char *tag, struct tns__Resume *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__Resume *)soap_id_enter(soap, soap->id, a, SOAP_tns__Resume, sizeof(struct tns__Resume), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__Resume(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__Resume *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__Resume, sizeof(struct tns__Resume), 0), SOAP_tns__Resume, sizeof(struct tns__Resume));
		if (soap->alloced)
			soap_default_tns__Resume(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__GetStatus(struct soap *soap, struct tns__GetStatus const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__GetStatus))
		soap_mark_tns__GetStatus(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__GetStatus(struct soap *soap, const struct tns__GetStatus *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__GetStatus(struct soap *soap, struct tns__GetStatus *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__GetStatus(struct soap *soap, struct tns__GetStatus *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__GetStatus, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__GetStatus(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__GetStatus(soap, tag, i, a, type);
		}
	else
		soap_out_tns__GetStatus(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__GetStatus(struct soap *soap, const char *tag, int id, const struct tns__GetStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__GetStatus), type);
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__GetStatus * SOAP_FMAC2 soap_get_tns__GetStatus(struct soap *soap, struct tns__GetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__GetStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__GetStatus * SOAP_FMAC2 soap_in_tns__GetStatus(struct soap *soap, const char *tag, struct tns__GetStatus *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__GetStatus *)soap_id_enter(soap, soap->id, a, SOAP_tns__GetStatus, sizeof(struct tns__GetStatus), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__GetStatus(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__GetStatus *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__GetStatus, sizeof(struct tns__GetStatus), 0), SOAP_tns__GetStatus, sizeof(struct tns__GetStatus));
		if (soap->alloced)
			soap_default_tns__GetStatus(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__PutStatus(struct soap *soap, struct tns__PutStatus const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__PutStatus))
		soap_mark_tns__PutStatus(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__PutStatus(struct soap *soap, const struct tns__PutStatus *a)
{
	soap_embedded(soap, &a->input, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &a->input);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__PutStatus(struct soap *soap, struct tns__PutStatus *a)
{
	soap_default_xsd__string(soap, &a->input);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__PutStatus(struct soap *soap, struct tns__PutStatus *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__PutStatus, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__PutStatus(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__PutStatus(soap, tag, i, a, type);
		}
	else
		soap_out_tns__PutStatus(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__PutStatus(struct soap *soap, const char *tag, int id, const struct tns__PutStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__PutStatus), type);
	soap_out_xsd__string(soap, "input", -1, &a->input, "xsd:string");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__PutStatus * SOAP_FMAC2 soap_get_tns__PutStatus(struct soap *soap, struct tns__PutStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__PutStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__PutStatus * SOAP_FMAC2 soap_in_tns__PutStatus(struct soap *soap, const char *tag, struct tns__PutStatus *a, const char *type)
{
	short soap_flag_input = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__PutStatus *)soap_id_enter(soap, soap->id, a, SOAP_tns__PutStatus, sizeof(struct tns__PutStatus), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__PutStatus(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_input && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "input", &a->input, "xsd:string"))
				{	soap_flag_input = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__PutStatus *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__PutStatus, sizeof(struct tns__PutStatus), 0), SOAP_tns__PutStatus, sizeof(struct tns__PutStatus));
		if (soap->alloced)
			soap_default_tns__PutStatus(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__Stop(struct soap *soap, struct tns__Stop const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__Stop))
		soap_mark_tns__Stop(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__Stop(struct soap *soap, const struct tns__Stop *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__Stop(struct soap *soap, struct tns__Stop *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__Stop(struct soap *soap, struct tns__Stop *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__Stop, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__Stop(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__Stop(soap, tag, i, a, type);
		}
	else
		soap_out_tns__Stop(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__Stop(struct soap *soap, const char *tag, int id, const struct tns__Stop *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__Stop), type);
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__Stop * SOAP_FMAC2 soap_get_tns__Stop(struct soap *soap, struct tns__Stop *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__Stop(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__Stop * SOAP_FMAC2 soap_in_tns__Stop(struct soap *soap, const char *tag, struct tns__Stop *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__Stop *)soap_id_enter(soap, soap->id, a, SOAP_tns__Stop, sizeof(struct tns__Stop), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__Stop(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__Stop *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__Stop, sizeof(struct tns__Stop), 0), SOAP_tns__Stop, sizeof(struct tns__Stop));
		if (soap->alloced)
			soap_default_tns__Stop(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__Pause(struct soap *soap, struct tns__Pause const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__Pause))
		soap_mark_tns__Pause(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__Pause(struct soap *soap, const struct tns__Pause *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__Pause(struct soap *soap, struct tns__Pause *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__Pause(struct soap *soap, struct tns__Pause *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__Pause, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__Pause(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__Pause(soap, tag, i, a, type);
		}
	else
		soap_out_tns__Pause(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__Pause(struct soap *soap, const char *tag, int id, const struct tns__Pause *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__Pause), type);
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__Pause * SOAP_FMAC2 soap_get_tns__Pause(struct soap *soap, struct tns__Pause *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__Pause(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__Pause * SOAP_FMAC2 soap_in_tns__Pause(struct soap *soap, const char *tag, struct tns__Pause *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__Pause *)soap_id_enter(soap, soap->id, a, SOAP_tns__Pause, sizeof(struct tns__Pause), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__Pause(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__Pause *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__Pause, sizeof(struct tns__Pause), 0), SOAP_tns__Pause, sizeof(struct tns__Pause));
		if (soap->alloced)
			soap_default_tns__Pause(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__SetServiceData(struct soap *soap, struct tns__SetServiceData const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__SetServiceData))
		soap_mark_tns__SetServiceData(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__SetServiceData(struct soap *soap, const struct tns__SetServiceData *a)
{
	soap_embedded(soap, &a->input, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &a->input);
	soap_embedded(soap, &a->sde_USCORE_value, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &a->sde_USCORE_value);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__SetServiceData(struct soap *soap, struct tns__SetServiceData *a)
{
	soap_default_xsd__string(soap, &a->input);
	soap_default_xsd__string(soap, &a->sde_USCORE_value);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__SetServiceData(struct soap *soap, struct tns__SetServiceData *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__SetServiceData, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__SetServiceData(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__SetServiceData(soap, tag, i, a, type);
		}
	else
		soap_out_tns__SetServiceData(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__SetServiceData(struct soap *soap, const char *tag, int id, const struct tns__SetServiceData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__SetServiceData), type);
	soap_out_xsd__string(soap, "input", -1, &a->input, "xsd:string");
	soap_out_xsd__string(soap, "sde_value", -1, &a->sde_USCORE_value, "xsd:string");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__SetServiceData * SOAP_FMAC2 soap_get_tns__SetServiceData(struct soap *soap, struct tns__SetServiceData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__SetServiceData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__SetServiceData * SOAP_FMAC2 soap_in_tns__SetServiceData(struct soap *soap, const char *tag, struct tns__SetServiceData *a, const char *type)
{
	short soap_flag_input = 1, soap_flag_sde_USCORE_value = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__SetServiceData *)soap_id_enter(soap, soap->id, a, SOAP_tns__SetServiceData, sizeof(struct tns__SetServiceData), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__SetServiceData(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_input && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "input", &a->input, "xsd:string"))
				{	soap_flag_input = 0;
					continue;
				}
			if (soap_flag_sde_USCORE_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "sde_value", &a->sde_USCORE_value, "xsd:string"))
				{	soap_flag_sde_USCORE_value = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__SetServiceData *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__SetServiceData, sizeof(struct tns__SetServiceData), 0), SOAP_tns__SetServiceData, sizeof(struct tns__SetServiceData));
		if (soap->alloced)
			soap_default_tns__SetServiceData(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__GetNotifications(struct soap *soap, struct tns__GetNotifications const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__GetNotifications))
		soap_mark_tns__GetNotifications(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__GetNotifications(struct soap *soap, const struct tns__GetNotifications *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__GetNotifications(struct soap *soap, struct tns__GetNotifications *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__GetNotifications(struct soap *soap, struct tns__GetNotifications *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__GetNotifications, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__GetNotifications(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__GetNotifications(soap, tag, i, a, type);
		}
	else
		soap_out_tns__GetNotifications(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__GetNotifications(struct soap *soap, const char *tag, int id, const struct tns__GetNotifications *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__GetNotifications), type);
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__GetNotifications * SOAP_FMAC2 soap_get_tns__GetNotifications(struct soap *soap, struct tns__GetNotifications *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__GetNotifications(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__GetNotifications * SOAP_FMAC2 soap_in_tns__GetNotifications(struct soap *soap, const char *tag, struct tns__GetNotifications *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__GetNotifications *)soap_id_enter(soap, soap->id, a, SOAP_tns__GetNotifications, sizeof(struct tns__GetNotifications), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__GetNotifications(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__GetNotifications *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__GetNotifications, sizeof(struct tns__GetNotifications), 0), SOAP_tns__GetNotifications, sizeof(struct tns__GetNotifications));
		if (soap->alloced)
			soap_default_tns__GetNotifications(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__Detach(struct soap *soap, struct tns__Detach const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__Detach))
		soap_mark_tns__Detach(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__Detach(struct soap *soap, const struct tns__Detach *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__Detach(struct soap *soap, struct tns__Detach *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__Detach(struct soap *soap, struct tns__Detach *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__Detach, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__Detach(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__Detach(soap, tag, i, a, type);
		}
	else
		soap_out_tns__Detach(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__Detach(struct soap *soap, const char *tag, int id, const struct tns__Detach *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__Detach), type);
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__Detach * SOAP_FMAC2 soap_get_tns__Detach(struct soap *soap, struct tns__Detach *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__Detach(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__Detach * SOAP_FMAC2 soap_in_tns__Detach(struct soap *soap, const char *tag, struct tns__Detach *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__Detach *)soap_id_enter(soap, soap->id, a, SOAP_tns__Detach, sizeof(struct tns__Detach), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__Detach(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__Detach *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__Detach, sizeof(struct tns__Detach), 0), SOAP_tns__Detach, sizeof(struct tns__Detach));
		if (soap->alloced)
			soap_default_tns__Detach(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__AppDetach(struct soap *soap, struct tns__AppDetach const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__AppDetach))
		soap_mark_tns__AppDetach(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__AppDetach(struct soap *soap, const struct tns__AppDetach *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__AppDetach(struct soap *soap, struct tns__AppDetach *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__AppDetach(struct soap *soap, struct tns__AppDetach *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__AppDetach, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__AppDetach(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__AppDetach(soap, tag, i, a, type);
		}
	else
		soap_out_tns__AppDetach(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__AppDetach(struct soap *soap, const char *tag, int id, const struct tns__AppDetach *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__AppDetach), type);
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__AppDetach * SOAP_FMAC2 soap_get_tns__AppDetach(struct soap *soap, struct tns__AppDetach *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__AppDetach(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__AppDetach * SOAP_FMAC2 soap_in_tns__AppDetach(struct soap *soap, const char *tag, struct tns__AppDetach *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__AppDetach *)soap_id_enter(soap, soap->id, a, SOAP_tns__AppDetach, sizeof(struct tns__AppDetach), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__AppDetach(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__AppDetach *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__AppDetach, sizeof(struct tns__AppDetach), 0), SOAP_tns__AppDetach, sizeof(struct tns__AppDetach));
		if (soap->alloced)
			soap_default_tns__AppDetach(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__AttachResponse(struct soap *soap, struct tns__AttachResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__AttachResponse))
		soap_mark_tns__AttachResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__AttachResponse(struct soap *soap, const struct tns__AttachResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__AttachResponse(struct soap *soap, struct tns__AttachResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__AttachResponse(struct soap *soap, struct tns__AttachResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__AttachResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__AttachResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__AttachResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__AttachResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__AttachResponse(struct soap *soap, const char *tag, int id, const struct tns__AttachResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__AttachResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__AttachResponse * SOAP_FMAC2 soap_get_tns__AttachResponse(struct soap *soap, struct tns__AttachResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__AttachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__AttachResponse * SOAP_FMAC2 soap_in_tns__AttachResponse(struct soap *soap, const char *tag, struct tns__AttachResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__AttachResponse *)soap_id_enter(soap, soap->id, a, SOAP_tns__AttachResponse, sizeof(struct tns__AttachResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__AttachResponse(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__AttachResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__AttachResponse, sizeof(struct tns__AttachResponse), 0), SOAP_tns__AttachResponse, sizeof(struct tns__AttachResponse));
		if (soap->alloced)
			soap_default_tns__AttachResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__GetNotificationsResponse(struct soap *soap, struct tns__GetNotificationsResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__GetNotificationsResponse))
		soap_mark_tns__GetNotificationsResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__GetNotificationsResponse(struct soap *soap, const struct tns__GetNotificationsResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__GetNotificationsResponse(struct soap *soap, struct tns__GetNotificationsResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__GetNotificationsResponse(struct soap *soap, struct tns__GetNotificationsResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__GetNotificationsResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__GetNotificationsResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__GetNotificationsResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__GetNotificationsResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__GetNotificationsResponse(struct soap *soap, const char *tag, int id, const struct tns__GetNotificationsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__GetNotificationsResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__GetNotificationsResponse * SOAP_FMAC2 soap_get_tns__GetNotificationsResponse(struct soap *soap, struct tns__GetNotificationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__GetNotificationsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__GetNotificationsResponse * SOAP_FMAC2 soap_in_tns__GetNotificationsResponse(struct soap *soap, const char *tag, struct tns__GetNotificationsResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__GetNotificationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_tns__GetNotificationsResponse, sizeof(struct tns__GetNotificationsResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__GetNotificationsResponse(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__GetNotificationsResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__GetNotificationsResponse, sizeof(struct tns__GetNotificationsResponse), 0), SOAP_tns__GetNotificationsResponse, sizeof(struct tns__GetNotificationsResponse));
		if (soap->alloced)
			soap_default_tns__GetNotificationsResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__AppDetachResponse(struct soap *soap, struct tns__AppDetachResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__AppDetachResponse))
		soap_mark_tns__AppDetachResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__AppDetachResponse(struct soap *soap, const struct tns__AppDetachResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__AppDetachResponse(struct soap *soap, struct tns__AppDetachResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__AppDetachResponse(struct soap *soap, struct tns__AppDetachResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__AppDetachResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__AppDetachResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__AppDetachResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__AppDetachResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__AppDetachResponse(struct soap *soap, const char *tag, int id, const struct tns__AppDetachResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__AppDetachResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__AppDetachResponse * SOAP_FMAC2 soap_get_tns__AppDetachResponse(struct soap *soap, struct tns__AppDetachResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__AppDetachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__AppDetachResponse * SOAP_FMAC2 soap_in_tns__AppDetachResponse(struct soap *soap, const char *tag, struct tns__AppDetachResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__AppDetachResponse *)soap_id_enter(soap, soap->id, a, SOAP_tns__AppDetachResponse, sizeof(struct tns__AppDetachResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__AppDetachResponse(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__AppDetachResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__AppDetachResponse, sizeof(struct tns__AppDetachResponse), 0), SOAP_tns__AppDetachResponse, sizeof(struct tns__AppDetachResponse));
		if (soap->alloced)
			soap_default_tns__AppDetachResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__FindServiceDataResponse(struct soap *soap, struct tns__FindServiceDataResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__FindServiceDataResponse))
		soap_mark_tns__FindServiceDataResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__FindServiceDataResponse(struct soap *soap, const struct tns__FindServiceDataResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__FindServiceDataResponse(struct soap *soap, struct tns__FindServiceDataResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__FindServiceDataResponse(struct soap *soap, struct tns__FindServiceDataResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__FindServiceDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__FindServiceDataResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__FindServiceDataResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__FindServiceDataResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__FindServiceDataResponse(struct soap *soap, const char *tag, int id, const struct tns__FindServiceDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__FindServiceDataResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__FindServiceDataResponse * SOAP_FMAC2 soap_get_tns__FindServiceDataResponse(struct soap *soap, struct tns__FindServiceDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__FindServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__FindServiceDataResponse * SOAP_FMAC2 soap_in_tns__FindServiceDataResponse(struct soap *soap, const char *tag, struct tns__FindServiceDataResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__FindServiceDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_tns__FindServiceDataResponse, sizeof(struct tns__FindServiceDataResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__FindServiceDataResponse(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__FindServiceDataResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__FindServiceDataResponse, sizeof(struct tns__FindServiceDataResponse), 0), SOAP_tns__FindServiceDataResponse, sizeof(struct tns__FindServiceDataResponse));
		if (soap->alloced)
			soap_default_tns__FindServiceDataResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__PutControlResponse(struct soap *soap, struct tns__PutControlResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__PutControlResponse))
		soap_mark_tns__PutControlResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__PutControlResponse(struct soap *soap, const struct tns__PutControlResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__PutControlResponse(struct soap *soap, struct tns__PutControlResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__PutControlResponse(struct soap *soap, struct tns__PutControlResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__PutControlResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__PutControlResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__PutControlResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__PutControlResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__PutControlResponse(struct soap *soap, const char *tag, int id, const struct tns__PutControlResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__PutControlResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__PutControlResponse * SOAP_FMAC2 soap_get_tns__PutControlResponse(struct soap *soap, struct tns__PutControlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__PutControlResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__PutControlResponse * SOAP_FMAC2 soap_in_tns__PutControlResponse(struct soap *soap, const char *tag, struct tns__PutControlResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__PutControlResponse *)soap_id_enter(soap, soap->id, a, SOAP_tns__PutControlResponse, sizeof(struct tns__PutControlResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__PutControlResponse(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__PutControlResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__PutControlResponse, sizeof(struct tns__PutControlResponse), 0), SOAP_tns__PutControlResponse, sizeof(struct tns__PutControlResponse));
		if (soap->alloced)
			soap_default_tns__PutControlResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__DetachResponse(struct soap *soap, struct tns__DetachResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__DetachResponse))
		soap_mark_tns__DetachResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__DetachResponse(struct soap *soap, const struct tns__DetachResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__DetachResponse(struct soap *soap, struct tns__DetachResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__DetachResponse(struct soap *soap, struct tns__DetachResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__DetachResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__DetachResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__DetachResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__DetachResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__DetachResponse(struct soap *soap, const char *tag, int id, const struct tns__DetachResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__DetachResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__DetachResponse * SOAP_FMAC2 soap_get_tns__DetachResponse(struct soap *soap, struct tns__DetachResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__DetachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__DetachResponse * SOAP_FMAC2 soap_in_tns__DetachResponse(struct soap *soap, const char *tag, struct tns__DetachResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__DetachResponse *)soap_id_enter(soap, soap->id, a, SOAP_tns__DetachResponse, sizeof(struct tns__DetachResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__DetachResponse(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__DetachResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__DetachResponse, sizeof(struct tns__DetachResponse), 0), SOAP_tns__DetachResponse, sizeof(struct tns__DetachResponse));
		if (soap->alloced)
			soap_default_tns__DetachResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__SetTerminationTimeResponse(struct soap *soap, struct tns__SetTerminationTimeResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__SetTerminationTimeResponse))
		soap_mark_tns__SetTerminationTimeResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__SetTerminationTimeResponse(struct soap *soap, const struct tns__SetTerminationTimeResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__SetTerminationTimeResponse(struct soap *soap, struct tns__SetTerminationTimeResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__SetTerminationTimeResponse(struct soap *soap, struct tns__SetTerminationTimeResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__SetTerminationTimeResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__SetTerminationTimeResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__SetTerminationTimeResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__SetTerminationTimeResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__SetTerminationTimeResponse(struct soap *soap, const char *tag, int id, const struct tns__SetTerminationTimeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__SetTerminationTimeResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__SetTerminationTimeResponse * SOAP_FMAC2 soap_get_tns__SetTerminationTimeResponse(struct soap *soap, struct tns__SetTerminationTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__SetTerminationTimeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__SetTerminationTimeResponse * SOAP_FMAC2 soap_in_tns__SetTerminationTimeResponse(struct soap *soap, const char *tag, struct tns__SetTerminationTimeResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__SetTerminationTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_tns__SetTerminationTimeResponse, sizeof(struct tns__SetTerminationTimeResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__SetTerminationTimeResponse(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__SetTerminationTimeResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__SetTerminationTimeResponse, sizeof(struct tns__SetTerminationTimeResponse), 0), SOAP_tns__SetTerminationTimeResponse, sizeof(struct tns__SetTerminationTimeResponse));
		if (soap->alloced)
			soap_default_tns__SetTerminationTimeResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__SetServiceDataResponse(struct soap *soap, struct tns__SetServiceDataResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__SetServiceDataResponse))
		soap_mark_tns__SetServiceDataResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__SetServiceDataResponse(struct soap *soap, const struct tns__SetServiceDataResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__SetServiceDataResponse(struct soap *soap, struct tns__SetServiceDataResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__SetServiceDataResponse(struct soap *soap, struct tns__SetServiceDataResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__SetServiceDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__SetServiceDataResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__SetServiceDataResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__SetServiceDataResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__SetServiceDataResponse(struct soap *soap, const char *tag, int id, const struct tns__SetServiceDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__SetServiceDataResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__SetServiceDataResponse * SOAP_FMAC2 soap_get_tns__SetServiceDataResponse(struct soap *soap, struct tns__SetServiceDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__SetServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__SetServiceDataResponse * SOAP_FMAC2 soap_in_tns__SetServiceDataResponse(struct soap *soap, const char *tag, struct tns__SetServiceDataResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__SetServiceDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_tns__SetServiceDataResponse, sizeof(struct tns__SetServiceDataResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__SetServiceDataResponse(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__SetServiceDataResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__SetServiceDataResponse, sizeof(struct tns__SetServiceDataResponse), 0), SOAP_tns__SetServiceDataResponse, sizeof(struct tns__SetServiceDataResponse));
		if (soap->alloced)
			soap_default_tns__SetServiceDataResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__DestroyResponse(struct soap *soap, struct tns__DestroyResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__DestroyResponse))
		soap_mark_tns__DestroyResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__DestroyResponse(struct soap *soap, const struct tns__DestroyResponse *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__DestroyResponse(struct soap *soap, struct tns__DestroyResponse *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__DestroyResponse(struct soap *soap, struct tns__DestroyResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__DestroyResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__DestroyResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__DestroyResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__DestroyResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__DestroyResponse(struct soap *soap, const char *tag, int id, const struct tns__DestroyResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__DestroyResponse), type);
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__DestroyResponse * SOAP_FMAC2 soap_get_tns__DestroyResponse(struct soap *soap, struct tns__DestroyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__DestroyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__DestroyResponse * SOAP_FMAC2 soap_in_tns__DestroyResponse(struct soap *soap, const char *tag, struct tns__DestroyResponse *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__DestroyResponse *)soap_id_enter(soap, soap->id, a, SOAP_tns__DestroyResponse, sizeof(struct tns__DestroyResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__DestroyResponse(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__DestroyResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__DestroyResponse, sizeof(struct tns__DestroyResponse), 0), SOAP_tns__DestroyResponse, sizeof(struct tns__DestroyResponse));
		if (soap->alloced)
			soap_default_tns__DestroyResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__AppAttachResponse(struct soap *soap, struct tns__AppAttachResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__AppAttachResponse))
		soap_mark_tns__AppAttachResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__AppAttachResponse(struct soap *soap, const struct tns__AppAttachResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__AppAttachResponse(struct soap *soap, struct tns__AppAttachResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__AppAttachResponse(struct soap *soap, struct tns__AppAttachResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__AppAttachResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__AppAttachResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__AppAttachResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__AppAttachResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__AppAttachResponse(struct soap *soap, const char *tag, int id, const struct tns__AppAttachResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__AppAttachResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__AppAttachResponse * SOAP_FMAC2 soap_get_tns__AppAttachResponse(struct soap *soap, struct tns__AppAttachResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__AppAttachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__AppAttachResponse * SOAP_FMAC2 soap_in_tns__AppAttachResponse(struct soap *soap, const char *tag, struct tns__AppAttachResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__AppAttachResponse *)soap_id_enter(soap, soap->id, a, SOAP_tns__AppAttachResponse, sizeof(struct tns__AppAttachResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__AppAttachResponse(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__AppAttachResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__AppAttachResponse, sizeof(struct tns__AppAttachResponse), 0), SOAP_tns__AppAttachResponse, sizeof(struct tns__AppAttachResponse));
		if (soap->alloced)
			soap_default_tns__AppAttachResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__PutStatusResponse(struct soap *soap, struct tns__PutStatusResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__PutStatusResponse))
		soap_mark_tns__PutStatusResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__PutStatusResponse(struct soap *soap, const struct tns__PutStatusResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__PutStatusResponse(struct soap *soap, struct tns__PutStatusResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__PutStatusResponse(struct soap *soap, struct tns__PutStatusResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__PutStatusResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__PutStatusResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__PutStatusResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__PutStatusResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__PutStatusResponse(struct soap *soap, const char *tag, int id, const struct tns__PutStatusResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__PutStatusResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__PutStatusResponse * SOAP_FMAC2 soap_get_tns__PutStatusResponse(struct soap *soap, struct tns__PutStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__PutStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__PutStatusResponse * SOAP_FMAC2 soap_in_tns__PutStatusResponse(struct soap *soap, const char *tag, struct tns__PutStatusResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__PutStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_tns__PutStatusResponse, sizeof(struct tns__PutStatusResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__PutStatusResponse(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__PutStatusResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__PutStatusResponse, sizeof(struct tns__PutStatusResponse), 0), SOAP_tns__PutStatusResponse, sizeof(struct tns__PutStatusResponse));
		if (soap->alloced)
			soap_default_tns__PutStatusResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__ResumeResponse(struct soap *soap, struct tns__ResumeResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__ResumeResponse))
		soap_mark_tns__ResumeResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__ResumeResponse(struct soap *soap, const struct tns__ResumeResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__ResumeResponse(struct soap *soap, struct tns__ResumeResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__ResumeResponse(struct soap *soap, struct tns__ResumeResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__ResumeResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__ResumeResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__ResumeResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__ResumeResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__ResumeResponse(struct soap *soap, const char *tag, int id, const struct tns__ResumeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__ResumeResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__ResumeResponse * SOAP_FMAC2 soap_get_tns__ResumeResponse(struct soap *soap, struct tns__ResumeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__ResumeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__ResumeResponse * SOAP_FMAC2 soap_in_tns__ResumeResponse(struct soap *soap, const char *tag, struct tns__ResumeResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__ResumeResponse *)soap_id_enter(soap, soap->id, a, SOAP_tns__ResumeResponse, sizeof(struct tns__ResumeResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__ResumeResponse(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__ResumeResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__ResumeResponse, sizeof(struct tns__ResumeResponse), 0), SOAP_tns__ResumeResponse, sizeof(struct tns__ResumeResponse));
		if (soap->alloced)
			soap_default_tns__ResumeResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__StopResponse(struct soap *soap, struct tns__StopResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__StopResponse))
		soap_mark_tns__StopResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__StopResponse(struct soap *soap, const struct tns__StopResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__StopResponse(struct soap *soap, struct tns__StopResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__StopResponse(struct soap *soap, struct tns__StopResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__StopResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__StopResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__StopResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__StopResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__StopResponse(struct soap *soap, const char *tag, int id, const struct tns__StopResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__StopResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__StopResponse * SOAP_FMAC2 soap_get_tns__StopResponse(struct soap *soap, struct tns__StopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__StopResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__StopResponse * SOAP_FMAC2 soap_in_tns__StopResponse(struct soap *soap, const char *tag, struct tns__StopResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__StopResponse *)soap_id_enter(soap, soap->id, a, SOAP_tns__StopResponse, sizeof(struct tns__StopResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__StopResponse(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__StopResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__StopResponse, sizeof(struct tns__StopResponse), 0), SOAP_tns__StopResponse, sizeof(struct tns__StopResponse));
		if (soap->alloced)
			soap_default_tns__StopResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__PauseResponse(struct soap *soap, struct tns__PauseResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__PauseResponse))
		soap_mark_tns__PauseResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__PauseResponse(struct soap *soap, const struct tns__PauseResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__PauseResponse(struct soap *soap, struct tns__PauseResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__PauseResponse(struct soap *soap, struct tns__PauseResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__PauseResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__PauseResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__PauseResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__PauseResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__PauseResponse(struct soap *soap, const char *tag, int id, const struct tns__PauseResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__PauseResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__PauseResponse * SOAP_FMAC2 soap_get_tns__PauseResponse(struct soap *soap, struct tns__PauseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__PauseResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__PauseResponse * SOAP_FMAC2 soap_in_tns__PauseResponse(struct soap *soap, const char *tag, struct tns__PauseResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__PauseResponse *)soap_id_enter(soap, soap->id, a, SOAP_tns__PauseResponse, sizeof(struct tns__PauseResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__PauseResponse(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__PauseResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__PauseResponse, sizeof(struct tns__PauseResponse), 0), SOAP_tns__PauseResponse, sizeof(struct tns__PauseResponse));
		if (soap->alloced)
			soap_default_tns__PauseResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__GetStatusResponse(struct soap *soap, struct tns__GetStatusResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__GetStatusResponse))
		soap_mark_tns__GetStatusResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__GetStatusResponse(struct soap *soap, const struct tns__GetStatusResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__GetStatusResponse(struct soap *soap, struct tns__GetStatusResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__GetStatusResponse(struct soap *soap, struct tns__GetStatusResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__GetStatusResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__GetStatusResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__GetStatusResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__GetStatusResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__GetStatusResponse(struct soap *soap, const char *tag, int id, const struct tns__GetStatusResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__GetStatusResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__GetStatusResponse * SOAP_FMAC2 soap_get_tns__GetStatusResponse(struct soap *soap, struct tns__GetStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__GetStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__GetStatusResponse * SOAP_FMAC2 soap_in_tns__GetStatusResponse(struct soap *soap, const char *tag, struct tns__GetStatusResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__GetStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_tns__GetStatusResponse, sizeof(struct tns__GetStatusResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__GetStatusResponse(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__GetStatusResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__GetStatusResponse, sizeof(struct tns__GetStatusResponse), 0), SOAP_tns__GetStatusResponse, sizeof(struct tns__GetStatusResponse));
		if (soap->alloced)
			soap_default_tns__GetStatusResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__GetControlResponse(struct soap *soap, struct tns__GetControlResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_tns__GetControlResponse))
		soap_mark_tns__GetControlResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__GetControlResponse(struct soap *soap, const struct tns__GetControlResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__GetControlResponse(struct soap *soap, struct tns__GetControlResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_tns__GetControlResponse(struct soap *soap, struct tns__GetControlResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_tns__GetControlResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__GetControlResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__GetControlResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__GetControlResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_tns__GetControlResponse(struct soap *soap, const char *tag, int id, const struct tns__GetControlResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_tns__GetControlResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct tns__GetControlResponse * SOAP_FMAC2 soap_get_tns__GetControlResponse(struct soap *soap, struct tns__GetControlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__GetControlResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__GetControlResponse * SOAP_FMAC2 soap_in_tns__GetControlResponse(struct soap *soap, const char *tag, struct tns__GetControlResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct tns__GetControlResponse *)soap_id_enter(soap, soap->id, a, SOAP_tns__GetControlResponse, sizeof(struct tns__GetControlResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__GetControlResponse(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tns__GetControlResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_tns__GetControlResponse, sizeof(struct tns__GetControlResponse), 0), SOAP_tns__GetControlResponse, sizeof(struct tns__GetControlResponse));
		if (soap->alloced)
			soap_default_tns__GetControlResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerToSOAP_ENV__Code))
		soap_mark_PointerToSOAP_ENV__Code(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_SOAP_ENV__Code))
		soap_mark_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerToSOAP_ENV__Code, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerToSOAP_ENV__Code(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerToSOAP_ENV__Code(soap, tag, i, a, type);
		}
	else
		soap_out_PointerToSOAP_ENV__Code(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerToSOAP_ENV__Code);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_SOAP_ENV__Code, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           soap_out_SOAP_ENV__Code(soap, tag, 0, *a, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       soap_out_SOAP_ENV__Code(soap, tag, i, *a, type);
	                   }
	                   else   soap_out_SOAP_ENV__Code(soap, tag, soap_pointer_enter(soap, *a, SOAP_SOAP_ENV__Code, &pp), *a, type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if(soap_is_single(soap, pp))
	                             soap_out_SOAP_ENV__Code(soap, tag, 0, *a, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          soap_out_SOAP_ENV__Code(soap, tag, i, *a, type);
	                     }
	              else    soap_out_SOAP_ENV__Code(soap, tag, soap_pointer_enter(soap, *a, SOAP_SOAP_ENV__Code, &pp),*a, type);
	}
}

SOAP_FMAC1 struct SOAP_ENV__Code ** SOAP_FMAC2 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code ** SOAP_FMAC2 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	struct SOAP_ENV__Code *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct SOAP_ENV__Code **)soap_id_enter(soap, soap->id, a, SOAP_PointerToSOAP_ENV__Code, sizeof(struct SOAP_ENV__Code *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_SOAP_ENV__Code(soap, tag, NULL, type)))
		{	a = (struct SOAP_ENV__Code **)soap_id_enter(soap, "", NULL, SOAP_PointerToSOAP_ENV__Code, sizeof(struct SOAP_ENV__Code *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerToSOAP_ENV__Code, sizeof(struct SOAP_ENV__Code *), 1), SOAP_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__GetControlResponse(struct soap *soap, struct tns__GetControlResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTotns__GetControlResponse))
		soap_mark_PointerTotns__GetControlResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__GetControlResponse(struct soap *soap, struct tns__GetControlResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_tns__GetControlResponse))
		soap_mark_tns__GetControlResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__GetControlResponse(struct soap *soap, struct tns__GetControlResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTotns__GetControlResponse(struct soap *soap, struct tns__GetControlResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTotns__GetControlResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__GetControlResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__GetControlResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__GetControlResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTotns__GetControlResponse(struct soap *soap, const char *tag, int id, struct tns__GetControlResponse *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTotns__GetControlResponse);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_tns__GetControlResponse, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           soap_out_tns__GetControlResponse(soap, tag, 0, *a, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       soap_out_tns__GetControlResponse(soap, tag, i, *a, type);
	                   }
	                   else   soap_out_tns__GetControlResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__GetControlResponse, &pp), *a, type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if(soap_is_single(soap, pp))
	                             soap_out_tns__GetControlResponse(soap, tag, 0, *a, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          soap_out_tns__GetControlResponse(soap, tag, i, *a, type);
	                     }
	              else    soap_out_tns__GetControlResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__GetControlResponse, &pp),*a, type);
	}
}

SOAP_FMAC1 struct tns__GetControlResponse ** SOAP_FMAC2 soap_get_PointerTotns__GetControlResponse(struct soap *soap, struct tns__GetControlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__GetControlResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__GetControlResponse ** SOAP_FMAC2 soap_in_PointerTotns__GetControlResponse(struct soap *soap, const char *tag, struct tns__GetControlResponse **a, const char *type)
{
	struct tns__GetControlResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__GetControlResponse **)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__GetControlResponse, sizeof(struct tns__GetControlResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__GetControlResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__GetControlResponse(soap, tag, NULL, type)))
		{	a = (struct tns__GetControlResponse **)soap_id_enter(soap, "", NULL, SOAP_PointerTotns__GetControlResponse, sizeof(struct tns__GetControlResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__GetControlResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__GetControlResponse, sizeof(struct tns__GetControlResponse *), 1), SOAP_tns__GetControlResponse, sizeof(struct tns__GetControlResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__AppAttachResponse(struct soap *soap, struct tns__AppAttachResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTotns__AppAttachResponse))
		soap_mark_PointerTotns__AppAttachResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__AppAttachResponse(struct soap *soap, struct tns__AppAttachResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_tns__AppAttachResponse))
		soap_mark_tns__AppAttachResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__AppAttachResponse(struct soap *soap, struct tns__AppAttachResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTotns__AppAttachResponse(struct soap *soap, struct tns__AppAttachResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTotns__AppAttachResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__AppAttachResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__AppAttachResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__AppAttachResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTotns__AppAttachResponse(struct soap *soap, const char *tag, int id, struct tns__AppAttachResponse *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTotns__AppAttachResponse);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_tns__AppAttachResponse, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           soap_out_tns__AppAttachResponse(soap, tag, 0, *a, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       soap_out_tns__AppAttachResponse(soap, tag, i, *a, type);
	                   }
	                   else   soap_out_tns__AppAttachResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__AppAttachResponse, &pp), *a, type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if(soap_is_single(soap, pp))
	                             soap_out_tns__AppAttachResponse(soap, tag, 0, *a, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          soap_out_tns__AppAttachResponse(soap, tag, i, *a, type);
	                     }
	              else    soap_out_tns__AppAttachResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__AppAttachResponse, &pp),*a, type);
	}
}

SOAP_FMAC1 struct tns__AppAttachResponse ** SOAP_FMAC2 soap_get_PointerTotns__AppAttachResponse(struct soap *soap, struct tns__AppAttachResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__AppAttachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__AppAttachResponse ** SOAP_FMAC2 soap_in_PointerTotns__AppAttachResponse(struct soap *soap, const char *tag, struct tns__AppAttachResponse **a, const char *type)
{
	struct tns__AppAttachResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__AppAttachResponse **)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__AppAttachResponse, sizeof(struct tns__AppAttachResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__AppAttachResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__AppAttachResponse(soap, tag, NULL, type)))
		{	a = (struct tns__AppAttachResponse **)soap_id_enter(soap, "", NULL, SOAP_PointerTotns__AppAttachResponse, sizeof(struct tns__AppAttachResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__AppAttachResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__AppAttachResponse, sizeof(struct tns__AppAttachResponse *), 1), SOAP_tns__AppAttachResponse, sizeof(struct tns__AppAttachResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__AttachResponse(struct soap *soap, struct tns__AttachResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTotns__AttachResponse))
		soap_mark_PointerTotns__AttachResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__AttachResponse(struct soap *soap, struct tns__AttachResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_tns__AttachResponse))
		soap_mark_tns__AttachResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__AttachResponse(struct soap *soap, struct tns__AttachResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTotns__AttachResponse(struct soap *soap, struct tns__AttachResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTotns__AttachResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__AttachResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__AttachResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__AttachResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTotns__AttachResponse(struct soap *soap, const char *tag, int id, struct tns__AttachResponse *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTotns__AttachResponse);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_tns__AttachResponse, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           soap_out_tns__AttachResponse(soap, tag, 0, *a, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       soap_out_tns__AttachResponse(soap, tag, i, *a, type);
	                   }
	                   else   soap_out_tns__AttachResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__AttachResponse, &pp), *a, type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if(soap_is_single(soap, pp))
	                             soap_out_tns__AttachResponse(soap, tag, 0, *a, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          soap_out_tns__AttachResponse(soap, tag, i, *a, type);
	                     }
	              else    soap_out_tns__AttachResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__AttachResponse, &pp),*a, type);
	}
}

SOAP_FMAC1 struct tns__AttachResponse ** SOAP_FMAC2 soap_get_PointerTotns__AttachResponse(struct soap *soap, struct tns__AttachResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__AttachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__AttachResponse ** SOAP_FMAC2 soap_in_PointerTotns__AttachResponse(struct soap *soap, const char *tag, struct tns__AttachResponse **a, const char *type)
{
	struct tns__AttachResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__AttachResponse **)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__AttachResponse, sizeof(struct tns__AttachResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__AttachResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__AttachResponse(soap, tag, NULL, type)))
		{	a = (struct tns__AttachResponse **)soap_id_enter(soap, "", NULL, SOAP_PointerTotns__AttachResponse, sizeof(struct tns__AttachResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__AttachResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__AttachResponse, sizeof(struct tns__AttachResponse *), 1), SOAP_tns__AttachResponse, sizeof(struct tns__AttachResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__FindServiceDataResponse(struct soap *soap, struct tns__FindServiceDataResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTotns__FindServiceDataResponse))
		soap_mark_PointerTotns__FindServiceDataResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__FindServiceDataResponse(struct soap *soap, struct tns__FindServiceDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_tns__FindServiceDataResponse))
		soap_mark_tns__FindServiceDataResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__FindServiceDataResponse(struct soap *soap, struct tns__FindServiceDataResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTotns__FindServiceDataResponse(struct soap *soap, struct tns__FindServiceDataResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTotns__FindServiceDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__FindServiceDataResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__FindServiceDataResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__FindServiceDataResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTotns__FindServiceDataResponse(struct soap *soap, const char *tag, int id, struct tns__FindServiceDataResponse *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTotns__FindServiceDataResponse);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_tns__FindServiceDataResponse, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           soap_out_tns__FindServiceDataResponse(soap, tag, 0, *a, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       soap_out_tns__FindServiceDataResponse(soap, tag, i, *a, type);
	                   }
	                   else   soap_out_tns__FindServiceDataResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__FindServiceDataResponse, &pp), *a, type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if(soap_is_single(soap, pp))
	                             soap_out_tns__FindServiceDataResponse(soap, tag, 0, *a, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          soap_out_tns__FindServiceDataResponse(soap, tag, i, *a, type);
	                     }
	              else    soap_out_tns__FindServiceDataResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__FindServiceDataResponse, &pp),*a, type);
	}
}

SOAP_FMAC1 struct tns__FindServiceDataResponse ** SOAP_FMAC2 soap_get_PointerTotns__FindServiceDataResponse(struct soap *soap, struct tns__FindServiceDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__FindServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__FindServiceDataResponse ** SOAP_FMAC2 soap_in_PointerTotns__FindServiceDataResponse(struct soap *soap, const char *tag, struct tns__FindServiceDataResponse **a, const char *type)
{
	struct tns__FindServiceDataResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__FindServiceDataResponse **)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__FindServiceDataResponse, sizeof(struct tns__FindServiceDataResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__FindServiceDataResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__FindServiceDataResponse(soap, tag, NULL, type)))
		{	a = (struct tns__FindServiceDataResponse **)soap_id_enter(soap, "", NULL, SOAP_PointerTotns__FindServiceDataResponse, sizeof(struct tns__FindServiceDataResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__FindServiceDataResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__FindServiceDataResponse, sizeof(struct tns__FindServiceDataResponse *), 1), SOAP_tns__FindServiceDataResponse, sizeof(struct tns__FindServiceDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__SetTerminationTimeResponse(struct soap *soap, struct tns__SetTerminationTimeResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTotns__SetTerminationTimeResponse))
		soap_mark_PointerTotns__SetTerminationTimeResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__SetTerminationTimeResponse(struct soap *soap, struct tns__SetTerminationTimeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_tns__SetTerminationTimeResponse))
		soap_mark_tns__SetTerminationTimeResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__SetTerminationTimeResponse(struct soap *soap, struct tns__SetTerminationTimeResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTotns__SetTerminationTimeResponse(struct soap *soap, struct tns__SetTerminationTimeResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTotns__SetTerminationTimeResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__SetTerminationTimeResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__SetTerminationTimeResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__SetTerminationTimeResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTotns__SetTerminationTimeResponse(struct soap *soap, const char *tag, int id, struct tns__SetTerminationTimeResponse *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTotns__SetTerminationTimeResponse);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_tns__SetTerminationTimeResponse, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           soap_out_tns__SetTerminationTimeResponse(soap, tag, 0, *a, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       soap_out_tns__SetTerminationTimeResponse(soap, tag, i, *a, type);
	                   }
	                   else   soap_out_tns__SetTerminationTimeResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__SetTerminationTimeResponse, &pp), *a, type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if(soap_is_single(soap, pp))
	                             soap_out_tns__SetTerminationTimeResponse(soap, tag, 0, *a, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          soap_out_tns__SetTerminationTimeResponse(soap, tag, i, *a, type);
	                     }
	              else    soap_out_tns__SetTerminationTimeResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__SetTerminationTimeResponse, &pp),*a, type);
	}
}

SOAP_FMAC1 struct tns__SetTerminationTimeResponse ** SOAP_FMAC2 soap_get_PointerTotns__SetTerminationTimeResponse(struct soap *soap, struct tns__SetTerminationTimeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__SetTerminationTimeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__SetTerminationTimeResponse ** SOAP_FMAC2 soap_in_PointerTotns__SetTerminationTimeResponse(struct soap *soap, const char *tag, struct tns__SetTerminationTimeResponse **a, const char *type)
{
	struct tns__SetTerminationTimeResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__SetTerminationTimeResponse **)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__SetTerminationTimeResponse, sizeof(struct tns__SetTerminationTimeResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__SetTerminationTimeResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__SetTerminationTimeResponse(soap, tag, NULL, type)))
		{	a = (struct tns__SetTerminationTimeResponse **)soap_id_enter(soap, "", NULL, SOAP_PointerTotns__SetTerminationTimeResponse, sizeof(struct tns__SetTerminationTimeResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__SetTerminationTimeResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__SetTerminationTimeResponse, sizeof(struct tns__SetTerminationTimeResponse *), 1), SOAP_tns__SetTerminationTimeResponse, sizeof(struct tns__SetTerminationTimeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__DestroyResponse(struct soap *soap, struct tns__DestroyResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTotns__DestroyResponse))
		soap_mark_PointerTotns__DestroyResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__DestroyResponse(struct soap *soap, struct tns__DestroyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_tns__DestroyResponse))
		soap_mark_tns__DestroyResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__DestroyResponse(struct soap *soap, struct tns__DestroyResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTotns__DestroyResponse(struct soap *soap, struct tns__DestroyResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTotns__DestroyResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__DestroyResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__DestroyResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__DestroyResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTotns__DestroyResponse(struct soap *soap, const char *tag, int id, struct tns__DestroyResponse *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTotns__DestroyResponse);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_tns__DestroyResponse, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           soap_out_tns__DestroyResponse(soap, tag, 0, *a, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       soap_out_tns__DestroyResponse(soap, tag, i, *a, type);
	                   }
	                   else   soap_out_tns__DestroyResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__DestroyResponse, &pp), *a, type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if(soap_is_single(soap, pp))
	                             soap_out_tns__DestroyResponse(soap, tag, 0, *a, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          soap_out_tns__DestroyResponse(soap, tag, i, *a, type);
	                     }
	              else    soap_out_tns__DestroyResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__DestroyResponse, &pp),*a, type);
	}
}

SOAP_FMAC1 struct tns__DestroyResponse ** SOAP_FMAC2 soap_get_PointerTotns__DestroyResponse(struct soap *soap, struct tns__DestroyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__DestroyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__DestroyResponse ** SOAP_FMAC2 soap_in_PointerTotns__DestroyResponse(struct soap *soap, const char *tag, struct tns__DestroyResponse **a, const char *type)
{
	struct tns__DestroyResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__DestroyResponse **)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__DestroyResponse, sizeof(struct tns__DestroyResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__DestroyResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__DestroyResponse(soap, tag, NULL, type)))
		{	a = (struct tns__DestroyResponse **)soap_id_enter(soap, "", NULL, SOAP_PointerTotns__DestroyResponse, sizeof(struct tns__DestroyResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__DestroyResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__DestroyResponse, sizeof(struct tns__DestroyResponse *), 1), SOAP_tns__DestroyResponse, sizeof(struct tns__DestroyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__PutControlResponse(struct soap *soap, struct tns__PutControlResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTotns__PutControlResponse))
		soap_mark_PointerTotns__PutControlResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__PutControlResponse(struct soap *soap, struct tns__PutControlResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_tns__PutControlResponse))
		soap_mark_tns__PutControlResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__PutControlResponse(struct soap *soap, struct tns__PutControlResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTotns__PutControlResponse(struct soap *soap, struct tns__PutControlResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTotns__PutControlResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__PutControlResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__PutControlResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__PutControlResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTotns__PutControlResponse(struct soap *soap, const char *tag, int id, struct tns__PutControlResponse *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTotns__PutControlResponse);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_tns__PutControlResponse, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           soap_out_tns__PutControlResponse(soap, tag, 0, *a, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       soap_out_tns__PutControlResponse(soap, tag, i, *a, type);
	                   }
	                   else   soap_out_tns__PutControlResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__PutControlResponse, &pp), *a, type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if(soap_is_single(soap, pp))
	                             soap_out_tns__PutControlResponse(soap, tag, 0, *a, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          soap_out_tns__PutControlResponse(soap, tag, i, *a, type);
	                     }
	              else    soap_out_tns__PutControlResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__PutControlResponse, &pp),*a, type);
	}
}

SOAP_FMAC1 struct tns__PutControlResponse ** SOAP_FMAC2 soap_get_PointerTotns__PutControlResponse(struct soap *soap, struct tns__PutControlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__PutControlResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__PutControlResponse ** SOAP_FMAC2 soap_in_PointerTotns__PutControlResponse(struct soap *soap, const char *tag, struct tns__PutControlResponse **a, const char *type)
{
	struct tns__PutControlResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__PutControlResponse **)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__PutControlResponse, sizeof(struct tns__PutControlResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__PutControlResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__PutControlResponse(soap, tag, NULL, type)))
		{	a = (struct tns__PutControlResponse **)soap_id_enter(soap, "", NULL, SOAP_PointerTotns__PutControlResponse, sizeof(struct tns__PutControlResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__PutControlResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__PutControlResponse, sizeof(struct tns__PutControlResponse *), 1), SOAP_tns__PutControlResponse, sizeof(struct tns__PutControlResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__ResumeResponse(struct soap *soap, struct tns__ResumeResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTotns__ResumeResponse))
		soap_mark_PointerTotns__ResumeResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__ResumeResponse(struct soap *soap, struct tns__ResumeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_tns__ResumeResponse))
		soap_mark_tns__ResumeResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__ResumeResponse(struct soap *soap, struct tns__ResumeResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTotns__ResumeResponse(struct soap *soap, struct tns__ResumeResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTotns__ResumeResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__ResumeResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__ResumeResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__ResumeResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTotns__ResumeResponse(struct soap *soap, const char *tag, int id, struct tns__ResumeResponse *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTotns__ResumeResponse);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_tns__ResumeResponse, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           soap_out_tns__ResumeResponse(soap, tag, 0, *a, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       soap_out_tns__ResumeResponse(soap, tag, i, *a, type);
	                   }
	                   else   soap_out_tns__ResumeResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__ResumeResponse, &pp), *a, type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if(soap_is_single(soap, pp))
	                             soap_out_tns__ResumeResponse(soap, tag, 0, *a, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          soap_out_tns__ResumeResponse(soap, tag, i, *a, type);
	                     }
	              else    soap_out_tns__ResumeResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__ResumeResponse, &pp),*a, type);
	}
}

SOAP_FMAC1 struct tns__ResumeResponse ** SOAP_FMAC2 soap_get_PointerTotns__ResumeResponse(struct soap *soap, struct tns__ResumeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__ResumeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__ResumeResponse ** SOAP_FMAC2 soap_in_PointerTotns__ResumeResponse(struct soap *soap, const char *tag, struct tns__ResumeResponse **a, const char *type)
{
	struct tns__ResumeResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__ResumeResponse **)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__ResumeResponse, sizeof(struct tns__ResumeResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__ResumeResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__ResumeResponse(soap, tag, NULL, type)))
		{	a = (struct tns__ResumeResponse **)soap_id_enter(soap, "", NULL, SOAP_PointerTotns__ResumeResponse, sizeof(struct tns__ResumeResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__ResumeResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__ResumeResponse, sizeof(struct tns__ResumeResponse *), 1), SOAP_tns__ResumeResponse, sizeof(struct tns__ResumeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__GetStatusResponse(struct soap *soap, struct tns__GetStatusResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTotns__GetStatusResponse))
		soap_mark_PointerTotns__GetStatusResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__GetStatusResponse(struct soap *soap, struct tns__GetStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_tns__GetStatusResponse))
		soap_mark_tns__GetStatusResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__GetStatusResponse(struct soap *soap, struct tns__GetStatusResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTotns__GetStatusResponse(struct soap *soap, struct tns__GetStatusResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTotns__GetStatusResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__GetStatusResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__GetStatusResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__GetStatusResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTotns__GetStatusResponse(struct soap *soap, const char *tag, int id, struct tns__GetStatusResponse *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTotns__GetStatusResponse);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_tns__GetStatusResponse, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           soap_out_tns__GetStatusResponse(soap, tag, 0, *a, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       soap_out_tns__GetStatusResponse(soap, tag, i, *a, type);
	                   }
	                   else   soap_out_tns__GetStatusResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__GetStatusResponse, &pp), *a, type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if(soap_is_single(soap, pp))
	                             soap_out_tns__GetStatusResponse(soap, tag, 0, *a, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          soap_out_tns__GetStatusResponse(soap, tag, i, *a, type);
	                     }
	              else    soap_out_tns__GetStatusResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__GetStatusResponse, &pp),*a, type);
	}
}

SOAP_FMAC1 struct tns__GetStatusResponse ** SOAP_FMAC2 soap_get_PointerTotns__GetStatusResponse(struct soap *soap, struct tns__GetStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__GetStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__GetStatusResponse ** SOAP_FMAC2 soap_in_PointerTotns__GetStatusResponse(struct soap *soap, const char *tag, struct tns__GetStatusResponse **a, const char *type)
{
	struct tns__GetStatusResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__GetStatusResponse **)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__GetStatusResponse, sizeof(struct tns__GetStatusResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__GetStatusResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__GetStatusResponse(soap, tag, NULL, type)))
		{	a = (struct tns__GetStatusResponse **)soap_id_enter(soap, "", NULL, SOAP_PointerTotns__GetStatusResponse, sizeof(struct tns__GetStatusResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__GetStatusResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__GetStatusResponse, sizeof(struct tns__GetStatusResponse *), 1), SOAP_tns__GetStatusResponse, sizeof(struct tns__GetStatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__PutStatusResponse(struct soap *soap, struct tns__PutStatusResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTotns__PutStatusResponse))
		soap_mark_PointerTotns__PutStatusResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__PutStatusResponse(struct soap *soap, struct tns__PutStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_tns__PutStatusResponse))
		soap_mark_tns__PutStatusResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__PutStatusResponse(struct soap *soap, struct tns__PutStatusResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTotns__PutStatusResponse(struct soap *soap, struct tns__PutStatusResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTotns__PutStatusResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__PutStatusResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__PutStatusResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__PutStatusResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTotns__PutStatusResponse(struct soap *soap, const char *tag, int id, struct tns__PutStatusResponse *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTotns__PutStatusResponse);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_tns__PutStatusResponse, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           soap_out_tns__PutStatusResponse(soap, tag, 0, *a, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       soap_out_tns__PutStatusResponse(soap, tag, i, *a, type);
	                   }
	                   else   soap_out_tns__PutStatusResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__PutStatusResponse, &pp), *a, type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if(soap_is_single(soap, pp))
	                             soap_out_tns__PutStatusResponse(soap, tag, 0, *a, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          soap_out_tns__PutStatusResponse(soap, tag, i, *a, type);
	                     }
	              else    soap_out_tns__PutStatusResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__PutStatusResponse, &pp),*a, type);
	}
}

SOAP_FMAC1 struct tns__PutStatusResponse ** SOAP_FMAC2 soap_get_PointerTotns__PutStatusResponse(struct soap *soap, struct tns__PutStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__PutStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__PutStatusResponse ** SOAP_FMAC2 soap_in_PointerTotns__PutStatusResponse(struct soap *soap, const char *tag, struct tns__PutStatusResponse **a, const char *type)
{
	struct tns__PutStatusResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__PutStatusResponse **)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__PutStatusResponse, sizeof(struct tns__PutStatusResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__PutStatusResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__PutStatusResponse(soap, tag, NULL, type)))
		{	a = (struct tns__PutStatusResponse **)soap_id_enter(soap, "", NULL, SOAP_PointerTotns__PutStatusResponse, sizeof(struct tns__PutStatusResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__PutStatusResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__PutStatusResponse, sizeof(struct tns__PutStatusResponse *), 1), SOAP_tns__PutStatusResponse, sizeof(struct tns__PutStatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__StopResponse(struct soap *soap, struct tns__StopResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTotns__StopResponse))
		soap_mark_PointerTotns__StopResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__StopResponse(struct soap *soap, struct tns__StopResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_tns__StopResponse))
		soap_mark_tns__StopResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__StopResponse(struct soap *soap, struct tns__StopResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTotns__StopResponse(struct soap *soap, struct tns__StopResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTotns__StopResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__StopResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__StopResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__StopResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTotns__StopResponse(struct soap *soap, const char *tag, int id, struct tns__StopResponse *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTotns__StopResponse);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_tns__StopResponse, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           soap_out_tns__StopResponse(soap, tag, 0, *a, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       soap_out_tns__StopResponse(soap, tag, i, *a, type);
	                   }
	                   else   soap_out_tns__StopResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__StopResponse, &pp), *a, type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if(soap_is_single(soap, pp))
	                             soap_out_tns__StopResponse(soap, tag, 0, *a, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          soap_out_tns__StopResponse(soap, tag, i, *a, type);
	                     }
	              else    soap_out_tns__StopResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__StopResponse, &pp),*a, type);
	}
}

SOAP_FMAC1 struct tns__StopResponse ** SOAP_FMAC2 soap_get_PointerTotns__StopResponse(struct soap *soap, struct tns__StopResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__StopResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__StopResponse ** SOAP_FMAC2 soap_in_PointerTotns__StopResponse(struct soap *soap, const char *tag, struct tns__StopResponse **a, const char *type)
{
	struct tns__StopResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__StopResponse **)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__StopResponse, sizeof(struct tns__StopResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__StopResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__StopResponse(soap, tag, NULL, type)))
		{	a = (struct tns__StopResponse **)soap_id_enter(soap, "", NULL, SOAP_PointerTotns__StopResponse, sizeof(struct tns__StopResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__StopResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__StopResponse, sizeof(struct tns__StopResponse *), 1), SOAP_tns__StopResponse, sizeof(struct tns__StopResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__PauseResponse(struct soap *soap, struct tns__PauseResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTotns__PauseResponse))
		soap_mark_PointerTotns__PauseResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__PauseResponse(struct soap *soap, struct tns__PauseResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_tns__PauseResponse))
		soap_mark_tns__PauseResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__PauseResponse(struct soap *soap, struct tns__PauseResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTotns__PauseResponse(struct soap *soap, struct tns__PauseResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTotns__PauseResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__PauseResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__PauseResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__PauseResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTotns__PauseResponse(struct soap *soap, const char *tag, int id, struct tns__PauseResponse *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTotns__PauseResponse);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_tns__PauseResponse, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           soap_out_tns__PauseResponse(soap, tag, 0, *a, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       soap_out_tns__PauseResponse(soap, tag, i, *a, type);
	                   }
	                   else   soap_out_tns__PauseResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__PauseResponse, &pp), *a, type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if(soap_is_single(soap, pp))
	                             soap_out_tns__PauseResponse(soap, tag, 0, *a, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          soap_out_tns__PauseResponse(soap, tag, i, *a, type);
	                     }
	              else    soap_out_tns__PauseResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__PauseResponse, &pp),*a, type);
	}
}

SOAP_FMAC1 struct tns__PauseResponse ** SOAP_FMAC2 soap_get_PointerTotns__PauseResponse(struct soap *soap, struct tns__PauseResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__PauseResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__PauseResponse ** SOAP_FMAC2 soap_in_PointerTotns__PauseResponse(struct soap *soap, const char *tag, struct tns__PauseResponse **a, const char *type)
{
	struct tns__PauseResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__PauseResponse **)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__PauseResponse, sizeof(struct tns__PauseResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__PauseResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__PauseResponse(soap, tag, NULL, type)))
		{	a = (struct tns__PauseResponse **)soap_id_enter(soap, "", NULL, SOAP_PointerTotns__PauseResponse, sizeof(struct tns__PauseResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__PauseResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__PauseResponse, sizeof(struct tns__PauseResponse *), 1), SOAP_tns__PauseResponse, sizeof(struct tns__PauseResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__SetServiceDataResponse(struct soap *soap, struct tns__SetServiceDataResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTotns__SetServiceDataResponse))
		soap_mark_PointerTotns__SetServiceDataResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__SetServiceDataResponse(struct soap *soap, struct tns__SetServiceDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_tns__SetServiceDataResponse))
		soap_mark_tns__SetServiceDataResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__SetServiceDataResponse(struct soap *soap, struct tns__SetServiceDataResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTotns__SetServiceDataResponse(struct soap *soap, struct tns__SetServiceDataResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTotns__SetServiceDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__SetServiceDataResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__SetServiceDataResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__SetServiceDataResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTotns__SetServiceDataResponse(struct soap *soap, const char *tag, int id, struct tns__SetServiceDataResponse *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTotns__SetServiceDataResponse);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_tns__SetServiceDataResponse, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           soap_out_tns__SetServiceDataResponse(soap, tag, 0, *a, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       soap_out_tns__SetServiceDataResponse(soap, tag, i, *a, type);
	                   }
	                   else   soap_out_tns__SetServiceDataResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__SetServiceDataResponse, &pp), *a, type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if(soap_is_single(soap, pp))
	                             soap_out_tns__SetServiceDataResponse(soap, tag, 0, *a, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          soap_out_tns__SetServiceDataResponse(soap, tag, i, *a, type);
	                     }
	              else    soap_out_tns__SetServiceDataResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__SetServiceDataResponse, &pp),*a, type);
	}
}

SOAP_FMAC1 struct tns__SetServiceDataResponse ** SOAP_FMAC2 soap_get_PointerTotns__SetServiceDataResponse(struct soap *soap, struct tns__SetServiceDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__SetServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__SetServiceDataResponse ** SOAP_FMAC2 soap_in_PointerTotns__SetServiceDataResponse(struct soap *soap, const char *tag, struct tns__SetServiceDataResponse **a, const char *type)
{
	struct tns__SetServiceDataResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__SetServiceDataResponse **)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__SetServiceDataResponse, sizeof(struct tns__SetServiceDataResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__SetServiceDataResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__SetServiceDataResponse(soap, tag, NULL, type)))
		{	a = (struct tns__SetServiceDataResponse **)soap_id_enter(soap, "", NULL, SOAP_PointerTotns__SetServiceDataResponse, sizeof(struct tns__SetServiceDataResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__SetServiceDataResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__SetServiceDataResponse, sizeof(struct tns__SetServiceDataResponse *), 1), SOAP_tns__SetServiceDataResponse, sizeof(struct tns__SetServiceDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__GetNotificationsResponse(struct soap *soap, struct tns__GetNotificationsResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTotns__GetNotificationsResponse))
		soap_mark_PointerTotns__GetNotificationsResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__GetNotificationsResponse(struct soap *soap, struct tns__GetNotificationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_tns__GetNotificationsResponse))
		soap_mark_tns__GetNotificationsResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__GetNotificationsResponse(struct soap *soap, struct tns__GetNotificationsResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTotns__GetNotificationsResponse(struct soap *soap, struct tns__GetNotificationsResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTotns__GetNotificationsResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__GetNotificationsResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__GetNotificationsResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__GetNotificationsResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTotns__GetNotificationsResponse(struct soap *soap, const char *tag, int id, struct tns__GetNotificationsResponse *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTotns__GetNotificationsResponse);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_tns__GetNotificationsResponse, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           soap_out_tns__GetNotificationsResponse(soap, tag, 0, *a, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       soap_out_tns__GetNotificationsResponse(soap, tag, i, *a, type);
	                   }
	                   else   soap_out_tns__GetNotificationsResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__GetNotificationsResponse, &pp), *a, type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if(soap_is_single(soap, pp))
	                             soap_out_tns__GetNotificationsResponse(soap, tag, 0, *a, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          soap_out_tns__GetNotificationsResponse(soap, tag, i, *a, type);
	                     }
	              else    soap_out_tns__GetNotificationsResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__GetNotificationsResponse, &pp),*a, type);
	}
}

SOAP_FMAC1 struct tns__GetNotificationsResponse ** SOAP_FMAC2 soap_get_PointerTotns__GetNotificationsResponse(struct soap *soap, struct tns__GetNotificationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__GetNotificationsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__GetNotificationsResponse ** SOAP_FMAC2 soap_in_PointerTotns__GetNotificationsResponse(struct soap *soap, const char *tag, struct tns__GetNotificationsResponse **a, const char *type)
{
	struct tns__GetNotificationsResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__GetNotificationsResponse **)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__GetNotificationsResponse, sizeof(struct tns__GetNotificationsResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__GetNotificationsResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__GetNotificationsResponse(soap, tag, NULL, type)))
		{	a = (struct tns__GetNotificationsResponse **)soap_id_enter(soap, "", NULL, SOAP_PointerTotns__GetNotificationsResponse, sizeof(struct tns__GetNotificationsResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__GetNotificationsResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__GetNotificationsResponse, sizeof(struct tns__GetNotificationsResponse *), 1), SOAP_tns__GetNotificationsResponse, sizeof(struct tns__GetNotificationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__DetachResponse(struct soap *soap, struct tns__DetachResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTotns__DetachResponse))
		soap_mark_PointerTotns__DetachResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__DetachResponse(struct soap *soap, struct tns__DetachResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_tns__DetachResponse))
		soap_mark_tns__DetachResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__DetachResponse(struct soap *soap, struct tns__DetachResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTotns__DetachResponse(struct soap *soap, struct tns__DetachResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTotns__DetachResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__DetachResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__DetachResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__DetachResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTotns__DetachResponse(struct soap *soap, const char *tag, int id, struct tns__DetachResponse *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTotns__DetachResponse);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_tns__DetachResponse, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           soap_out_tns__DetachResponse(soap, tag, 0, *a, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       soap_out_tns__DetachResponse(soap, tag, i, *a, type);
	                   }
	                   else   soap_out_tns__DetachResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__DetachResponse, &pp), *a, type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if(soap_is_single(soap, pp))
	                             soap_out_tns__DetachResponse(soap, tag, 0, *a, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          soap_out_tns__DetachResponse(soap, tag, i, *a, type);
	                     }
	              else    soap_out_tns__DetachResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__DetachResponse, &pp),*a, type);
	}
}

SOAP_FMAC1 struct tns__DetachResponse ** SOAP_FMAC2 soap_get_PointerTotns__DetachResponse(struct soap *soap, struct tns__DetachResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__DetachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__DetachResponse ** SOAP_FMAC2 soap_in_PointerTotns__DetachResponse(struct soap *soap, const char *tag, struct tns__DetachResponse **a, const char *type)
{
	struct tns__DetachResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__DetachResponse **)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__DetachResponse, sizeof(struct tns__DetachResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__DetachResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__DetachResponse(soap, tag, NULL, type)))
		{	a = (struct tns__DetachResponse **)soap_id_enter(soap, "", NULL, SOAP_PointerTotns__DetachResponse, sizeof(struct tns__DetachResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__DetachResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__DetachResponse, sizeof(struct tns__DetachResponse *), 1), SOAP_tns__DetachResponse, sizeof(struct tns__DetachResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__AppDetachResponse(struct soap *soap, struct tns__AppDetachResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTotns__AppDetachResponse))
		soap_mark_PointerTotns__AppDetachResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__AppDetachResponse(struct soap *soap, struct tns__AppDetachResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_tns__AppDetachResponse))
		soap_mark_tns__AppDetachResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__AppDetachResponse(struct soap *soap, struct tns__AppDetachResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTotns__AppDetachResponse(struct soap *soap, struct tns__AppDetachResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTotns__AppDetachResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__AppDetachResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__AppDetachResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__AppDetachResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTotns__AppDetachResponse(struct soap *soap, const char *tag, int id, struct tns__AppDetachResponse *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTotns__AppDetachResponse);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_tns__AppDetachResponse, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           soap_out_tns__AppDetachResponse(soap, tag, 0, *a, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       soap_out_tns__AppDetachResponse(soap, tag, i, *a, type);
	                   }
	                   else   soap_out_tns__AppDetachResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__AppDetachResponse, &pp), *a, type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if(soap_is_single(soap, pp))
	                             soap_out_tns__AppDetachResponse(soap, tag, 0, *a, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          soap_out_tns__AppDetachResponse(soap, tag, i, *a, type);
	                     }
	              else    soap_out_tns__AppDetachResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_tns__AppDetachResponse, &pp),*a, type);
	}
}

SOAP_FMAC1 struct tns__AppDetachResponse ** SOAP_FMAC2 soap_get_PointerTotns__AppDetachResponse(struct soap *soap, struct tns__AppDetachResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__AppDetachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__AppDetachResponse ** SOAP_FMAC2 soap_in_PointerTotns__AppDetachResponse(struct soap *soap, const char *tag, struct tns__AppDetachResponse **a, const char *type)
{
	struct tns__AppDetachResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__AppDetachResponse **)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__AppDetachResponse, sizeof(struct tns__AppDetachResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__AppDetachResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__AppDetachResponse(soap, tag, NULL, type)))
		{	a = (struct tns__AppDetachResponse **)soap_id_enter(soap, "", NULL, SOAP_PointerTotns__AppDetachResponse, sizeof(struct tns__AppDetachResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__AppDetachResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTotns__AppDetachResponse, sizeof(struct tns__AppDetachResponse *), 1), SOAP_tns__AppDetachResponse, sizeof(struct tns__AppDetachResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsd__string(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsd__string
	*a = SOAP_DEFAULT_xsd__string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsd__string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_xsd__string);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsd__string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_xsd__string);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_xsd__string(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_xsd__string, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsd__string(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsd__string(soap, tag, i, a, type);
		}
	else
		soap_out_xsd__string(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_xsd__string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	soap_outstring(soap, tag, id, a, type, SOAP_xsd__string);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsd__string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsd__string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_xsd__string);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_string(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_string);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_string);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_string(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_string, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_string(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_string(soap, tag, i, a, type);
		}
	else
		soap_out_string(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	soap_outstring(soap, tag, id, a, type, SOAP_string);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_string);
}
#ifdef __cplusplus
}
#endif

/* end of soapC.c */
