/* soapC.c
   Generated by gSOAP 2.2.3b from SGS.h
   Copyright (C) 2001-2003 Genivia inc.
   All Rights Reserved.
*/
#include "soapH.h"
#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.2.3b 2003-06-09 16:46:29 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC1 void SOAP_FMAC2 soap_serializeheader(struct soap *soap)
{
	soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->is_in_header = 1;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->is_in_header = 0;
	}
	return SOAP_OK;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_getheader(struct soap *soap)
{
	soap->is_in_header = 1;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->is_in_header = 0;
	return soap->header == NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serializefault(struct soap *soap)
{
	soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_putfault(struct soap *soap)
{
	return soap_out_SOAP_ENV__Fault(soap, "SOAP-ENV:Fault", 0, soap->fault, NULL);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_in_SOAP_ENV__Fault(soap, "SOAP-ENV:Fault", NULL, NULL)) == NULL;
}

SOAP_FMAC1 const char ** SOAP_FMAC2 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC1 const char ** SOAP_FMAC2 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC1 const char ** SOAP_FMAC2 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Detail;
	return (const char**)&soap->fault->detail;
}

#endif

SOAP_FMAC1 int SOAP_FMAC2 soap_getindependent(struct soap *soap)
{
	for (;;)
	{	if (soap_peek_element(soap))
			break;
		switch (soap_lookup_type(soap, soap->id))
		{
		case SOAP_TYPE_byte:
			soap_in_byte(soap, NULL, NULL, "");
			break;
		case SOAP_TYPE_int:
			soap_in_int(soap, NULL, NULL, "");
			break;
		case SOAP_TYPE_tns__GetControl:
			soap_in_tns__GetControl(soap, NULL, NULL, "tns:GetControl");
			break;
		case SOAP_TYPE_tns__Attach:
			soap_in_tns__Attach(soap, NULL, NULL, "tns:Attach");
			break;
		case SOAP_TYPE_tns__AppStart:
			soap_in_tns__AppStart(soap, NULL, NULL, "tns:AppStart");
			break;
		case SOAP_TYPE_tns__Destroy:
			soap_in_tns__Destroy(soap, NULL, NULL, "tns:Destroy");
			break;
		case SOAP_TYPE_tns__PutControl:
			soap_in_tns__PutControl(soap, NULL, NULL, "tns:PutControl");
			break;
		case SOAP_TYPE_tns__Resume:
			soap_in_tns__Resume(soap, NULL, NULL, "tns:Resume");
			break;
		case SOAP_TYPE_tns__GetStatus:
			soap_in_tns__GetStatus(soap, NULL, NULL, "tns:GetStatus");
			break;
		case SOAP_TYPE_tns__PutStatus:
			soap_in_tns__PutStatus(soap, NULL, NULL, "tns:PutStatus");
			break;
		case SOAP_TYPE_tns__GetNthDataSource:
			soap_in_tns__GetNthDataSource(soap, NULL, NULL, "tns:GetNthDataSource");
			break;
		case SOAP_TYPE_tns__Stop:
			soap_in_tns__Stop(soap, NULL, NULL, "tns:Stop");
			break;
		case SOAP_TYPE_tns__Pause:
			soap_in_tns__Pause(soap, NULL, NULL, "tns:Pause");
			break;
		case SOAP_TYPE_tns__setServiceData:
			soap_in_tns__setServiceData(soap, NULL, NULL, "tns:setServiceData");
			break;
		case SOAP_TYPE_tns__AppStop:
			soap_in_tns__AppStop(soap, NULL, NULL, "tns:AppStop");
			break;
		case SOAP_TYPE_tns__findServiceData:
			soap_in_tns__findServiceData(soap, NULL, NULL, "tns:findServiceData");
			break;
		case SOAP_TYPE_tns__Detach:
			soap_in_tns__Detach(soap, NULL, NULL, "tns:Detach");
			break;
		case SOAP_TYPE_tns__AppDetach:
			soap_in_tns__AppDetach(soap, NULL, NULL, "tns:AppDetach");
			break;
		case SOAP_TYPE_tns__GetNotifications:
			soap_in_tns__GetNotifications(soap, NULL, NULL, "tns:GetNotifications");
			break;
		case SOAP_TYPE_tns__GetControlResponse:
			soap_in_tns__GetControlResponse(soap, NULL, NULL, "tns:GetControlResponse");
			break;
		case SOAP_TYPE_tns__DestroyResponse:
			soap_in_tns__DestroyResponse(soap, NULL, NULL, "tns:DestroyResponse");
			break;
		case SOAP_TYPE_tns__GetNotificationsResponse:
			soap_in_tns__GetNotificationsResponse(soap, NULL, NULL, "tns:GetNotificationsResponse");
			break;
		case SOAP_TYPE_tns__PauseResponse:
			soap_in_tns__PauseResponse(soap, NULL, NULL, "tns:PauseResponse");
			break;
		case SOAP_TYPE_tns__findServiceDataResponse:
			soap_in_tns__findServiceDataResponse(soap, NULL, NULL, "tns:findServiceDataResponse");
			break;
		case SOAP_TYPE_tns__AttachResponse:
			soap_in_tns__AttachResponse(soap, NULL, NULL, "tns:AttachResponse");
			break;
		case SOAP_TYPE_tns__PutStatusResponse:
			soap_in_tns__PutStatusResponse(soap, NULL, NULL, "tns:PutStatusResponse");
			break;
		case SOAP_TYPE_tns__PutControlResponse:
			soap_in_tns__PutControlResponse(soap, NULL, NULL, "tns:PutControlResponse");
			break;
		case SOAP_TYPE_tns__AppDetachResponse:
			soap_in_tns__AppDetachResponse(soap, NULL, NULL, "tns:AppDetachResponse");
			break;
		case SOAP_TYPE_tns__ResumeResponse:
			soap_in_tns__ResumeResponse(soap, NULL, NULL, "tns:ResumeResponse");
			break;
		case SOAP_TYPE_tns__GetNthDataSourceResponse:
			soap_in_tns__GetNthDataSourceResponse(soap, NULL, NULL, "tns:GetNthDataSourceResponse");
			break;
		case SOAP_TYPE_tns__setServiceDataResponse:
			soap_in_tns__setServiceDataResponse(soap, NULL, NULL, "tns:setServiceDataResponse");
			break;
		case SOAP_TYPE_tns__DetachResponse:
			soap_in_tns__DetachResponse(soap, NULL, NULL, "tns:DetachResponse");
			break;
		case SOAP_TYPE_tns__AppStopResponse:
			soap_in_tns__AppStopResponse(soap, NULL, NULL, "tns:AppStopResponse");
			break;
		case SOAP_TYPE_tns__StopResponse:
			soap_in_tns__StopResponse(soap, NULL, NULL, "tns:StopResponse");
			break;
		case SOAP_TYPE_tns__AppStartResponse:
			soap_in_tns__AppStartResponse(soap, NULL, NULL, "tns:AppStartResponse");
			break;
		case SOAP_TYPE_tns__GetStatusResponse:
			soap_in_tns__GetStatusResponse(soap, NULL, NULL, "tns:GetStatusResponse");
			break;
		case SOAP_TYPE_PointerTotns__GetControlResponse:
			soap_in_PointerTotns__GetControlResponse(soap, NULL, NULL, "tns:GetControlResponse");
			break;
		case SOAP_TYPE_PointerTotns__AttachResponse:
			soap_in_PointerTotns__AttachResponse(soap, NULL, NULL, "tns:AttachResponse");
			break;
		case SOAP_TYPE_PointerTotns__AppStartResponse:
			soap_in_PointerTotns__AppStartResponse(soap, NULL, NULL, "tns:AppStartResponse");
			break;
		case SOAP_TYPE_PointerTotns__DestroyResponse:
			soap_in_PointerTotns__DestroyResponse(soap, NULL, NULL, "tns:DestroyResponse");
			break;
		case SOAP_TYPE_PointerTotns__PutControlResponse:
			soap_in_PointerTotns__PutControlResponse(soap, NULL, NULL, "tns:PutControlResponse");
			break;
		case SOAP_TYPE_PointerTotns__ResumeResponse:
			soap_in_PointerTotns__ResumeResponse(soap, NULL, NULL, "tns:ResumeResponse");
			break;
		case SOAP_TYPE_PointerTotns__GetStatusResponse:
			soap_in_PointerTotns__GetStatusResponse(soap, NULL, NULL, "tns:GetStatusResponse");
			break;
		case SOAP_TYPE_PointerTotns__PutStatusResponse:
			soap_in_PointerTotns__PutStatusResponse(soap, NULL, NULL, "tns:PutStatusResponse");
			break;
		case SOAP_TYPE_PointerTotns__GetNthDataSourceResponse:
			soap_in_PointerTotns__GetNthDataSourceResponse(soap, NULL, NULL, "tns:GetNthDataSourceResponse");
			break;
		case SOAP_TYPE_PointerTotns__StopResponse:
			soap_in_PointerTotns__StopResponse(soap, NULL, NULL, "tns:StopResponse");
			break;
		case SOAP_TYPE_PointerTotns__PauseResponse:
			soap_in_PointerTotns__PauseResponse(soap, NULL, NULL, "tns:PauseResponse");
			break;
		case SOAP_TYPE_PointerTotns__setServiceDataResponse:
			soap_in_PointerTotns__setServiceDataResponse(soap, NULL, NULL, "tns:setServiceDataResponse");
			break;
		case SOAP_TYPE_PointerTotns__AppStopResponse:
			soap_in_PointerTotns__AppStopResponse(soap, NULL, NULL, "tns:AppStopResponse");
			break;
		case SOAP_TYPE_PointerTotns__findServiceDataResponse:
			soap_in_PointerTotns__findServiceDataResponse(soap, NULL, NULL, "tns:findServiceDataResponse");
			break;
		case SOAP_TYPE_PointerTotns__DetachResponse:
			soap_in_PointerTotns__DetachResponse(soap, NULL, NULL, "tns:DetachResponse");
			break;
		case SOAP_TYPE_PointerTotns__AppDetachResponse:
			soap_in_PointerTotns__AppDetachResponse(soap, NULL, NULL, "tns:AppDetachResponse");
			break;
		case SOAP_TYPE_PointerTotns__GetNotificationsResponse:
			soap_in_PointerTotns__GetNotificationsResponse(soap, NULL, NULL, "tns:GetNotificationsResponse");
			break;
		case SOAP_TYPE_xsdl__PutStatusRequest:
			soap_in_xsdl__PutStatusRequest(soap, NULL, NULL, "xsdl:PutStatusRequest");
			break;
		case SOAP_TYPE_xsdl__StopRequest:
			soap_in_xsdl__StopRequest(soap, NULL, NULL, "xsdl:StopRequest");
			break;
		case SOAP_TYPE_xsdl__DetachRequest:
			soap_in_xsdl__DetachRequest(soap, NULL, NULL, "xsdl:DetachRequest");
			break;
		case SOAP_TYPE_xsdl__AppDetachRequest:
			soap_in_xsdl__AppDetachRequest(soap, NULL, NULL, "xsdl:AppDetachRequest");
			break;
		case SOAP_TYPE_xsdl__GetNthDataSourceRequest:
			soap_in_xsdl__GetNthDataSourceRequest(soap, NULL, NULL, "xsdl:GetNthDataSourceRequest");
			break;
		case SOAP_TYPE_xsdl__AttachRequest:
			soap_in_xsdl__AttachRequest(soap, NULL, NULL, "xsdl:AttachRequest");
			break;
		case SOAP_TYPE_xsdl__GetNthDataSourceResponse:
			soap_in_xsdl__GetNthDataSourceResponse(soap, NULL, NULL, "xsdl:GetNthDataSourceResponse");
			break;
		case SOAP_TYPE_xsdl__AppStartRequest:
			soap_in_xsdl__AppStartRequest(soap, NULL, NULL, "xsdl:AppStartRequest");
			break;
		case SOAP_TYPE_xsdl__AppDetachResponse:
			soap_in_xsdl__AppDetachResponse(soap, NULL, NULL, "xsdl:AppDetachResponse");
			break;
		case SOAP_TYPE_xsdl__PutStatusResponse:
			soap_in_xsdl__PutStatusResponse(soap, NULL, NULL, "xsdl:PutStatusResponse");
			break;
		case SOAP_TYPE_xsdl__AttachResponse:
			soap_in_xsdl__AttachResponse(soap, NULL, NULL, "xsdl:AttachResponse");
			break;
		case SOAP_TYPE_xsdl__GetControlRequest:
			soap_in_xsdl__GetControlRequest(soap, NULL, NULL, "xsdl:GetControlRequest");
			break;
		case SOAP_TYPE_xsdl__ResumeResponse:
			soap_in_xsdl__ResumeResponse(soap, NULL, NULL, "xsdl:ResumeResponse");
			break;
		case SOAP_TYPE_xsdl__PutControlResponse:
			soap_in_xsdl__PutControlResponse(soap, NULL, NULL, "xsdl:PutControlResponse");
			break;
		case SOAP_TYPE_xsdl__PauseResponse:
			soap_in_xsdl__PauseResponse(soap, NULL, NULL, "xsdl:PauseResponse");
			break;
		case SOAP_TYPE_xsdl__findServiceDataRequest:
			soap_in_xsdl__findServiceDataRequest(soap, NULL, NULL, "xsdl:findServiceDataRequest");
			break;
		case SOAP_TYPE_xsdl__GetStatusRequest:
			soap_in_xsdl__GetStatusRequest(soap, NULL, NULL, "xsdl:GetStatusRequest");
			break;
		case SOAP_TYPE_xsdl__setServiceDataResponse:
			soap_in_xsdl__setServiceDataResponse(soap, NULL, NULL, "xsdl:setServiceDataResponse");
			break;
		case SOAP_TYPE_xsdl__StopResponse:
			soap_in_xsdl__StopResponse(soap, NULL, NULL, "xsdl:StopResponse");
			break;
		case SOAP_TYPE_xsdl__DetachResponse:
			soap_in_xsdl__DetachResponse(soap, NULL, NULL, "xsdl:DetachResponse");
			break;
		case SOAP_TYPE_xsdl__findServiceDataResponse:
			soap_in_xsdl__findServiceDataResponse(soap, NULL, NULL, "xsdl:findServiceDataResponse");
			break;
		case SOAP_TYPE_xsdl__ResumeRequest:
			soap_in_xsdl__ResumeRequest(soap, NULL, NULL, "xsdl:ResumeRequest");
			break;
		case SOAP_TYPE_xsdl__AppStopResponse:
			soap_in_xsdl__AppStopResponse(soap, NULL, NULL, "xsdl:AppStopResponse");
			break;
		case SOAP_TYPE_xsdl__AppStartResponse:
			soap_in_xsdl__AppStartResponse(soap, NULL, NULL, "xsdl:AppStartResponse");
			break;
		case SOAP_TYPE_xsdl__AppStopRequest:
			soap_in_xsdl__AppStopRequest(soap, NULL, NULL, "xsdl:AppStopRequest");
			break;
		case SOAP_TYPE_xsdl__PauseRequest:
			soap_in_xsdl__PauseRequest(soap, NULL, NULL, "xsdl:PauseRequest");
			break;
		case SOAP_TYPE_xsdl__GetNotificationsRequest:
			soap_in_xsdl__GetNotificationsRequest(soap, NULL, NULL, "xsdl:GetNotificationsRequest");
			break;
		case SOAP_TYPE_xsdl__GetStatusResponse:
			soap_in_xsdl__GetStatusResponse(soap, NULL, NULL, "xsdl:GetStatusResponse");
			break;
		case SOAP_TYPE_xsdl__GetNotificationsResponse:
			soap_in_xsdl__GetNotificationsResponse(soap, NULL, NULL, "xsdl:GetNotificationsResponse");
			break;
		case SOAP_TYPE_xsdl__setServiceDataRequest:
			soap_in_xsdl__setServiceDataRequest(soap, NULL, NULL, "xsdl:setServiceDataRequest");
			break;
		case SOAP_TYPE_xsdl__DestroyRequest:
			soap_in_xsdl__DestroyRequest(soap, NULL, NULL, "xsdl:DestroyRequest");
			break;
		case SOAP_TYPE_xsdl__PutControlRequest:
			soap_in_xsdl__PutControlRequest(soap, NULL, NULL, "xsdl:PutControlRequest");
			break;
		case SOAP_TYPE_xsdl__GetControlResponse:
			soap_in_xsdl__GetControlResponse(soap, NULL, NULL, "xsdl:GetControlResponse");
			break;
		case SOAP_TYPE_xsdl__DestroyResponse:
			soap_in_xsdl__DestroyResponse(soap, NULL, NULL, "xsdl:DestroyResponse");
			break;
		case SOAP_TYPE_xsd__integer:
			soap_in_xsd__integer(soap, NULL, NULL, "xsd:integer");
			break;
		case SOAP_TYPE_xsd__string:
			soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
			break;
		case SOAP_TYPE_string:
			soap_in_string(soap, NULL, NULL, "");
			break;
		default:
			if (!*soap->id)
			{	if (soap_ignore_element(soap))
					break;
				else
					continue;
			}
			soap_in_byte(soap, NULL, NULL, "xsd:byte");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_int(soap, NULL, NULL, "xsd:int");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__GetControl(soap, NULL, NULL, "tns:GetControl");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__Attach(soap, NULL, NULL, "tns:Attach");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__AppStart(soap, NULL, NULL, "tns:AppStart");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__Destroy(soap, NULL, NULL, "tns:Destroy");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__PutControl(soap, NULL, NULL, "tns:PutControl");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__Resume(soap, NULL, NULL, "tns:Resume");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__GetStatus(soap, NULL, NULL, "tns:GetStatus");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__PutStatus(soap, NULL, NULL, "tns:PutStatus");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__GetNthDataSource(soap, NULL, NULL, "tns:GetNthDataSource");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__Stop(soap, NULL, NULL, "tns:Stop");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__Pause(soap, NULL, NULL, "tns:Pause");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__setServiceData(soap, NULL, NULL, "tns:setServiceData");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__AppStop(soap, NULL, NULL, "tns:AppStop");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__findServiceData(soap, NULL, NULL, "tns:findServiceData");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__Detach(soap, NULL, NULL, "tns:Detach");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__AppDetach(soap, NULL, NULL, "tns:AppDetach");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__GetNotifications(soap, NULL, NULL, "tns:GetNotifications");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__GetControlResponse(soap, NULL, NULL, "tns:GetControlResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__DestroyResponse(soap, NULL, NULL, "tns:DestroyResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__GetNotificationsResponse(soap, NULL, NULL, "tns:GetNotificationsResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__PauseResponse(soap, NULL, NULL, "tns:PauseResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__findServiceDataResponse(soap, NULL, NULL, "tns:findServiceDataResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__AttachResponse(soap, NULL, NULL, "tns:AttachResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__PutStatusResponse(soap, NULL, NULL, "tns:PutStatusResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__PutControlResponse(soap, NULL, NULL, "tns:PutControlResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__AppDetachResponse(soap, NULL, NULL, "tns:AppDetachResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__ResumeResponse(soap, NULL, NULL, "tns:ResumeResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__GetNthDataSourceResponse(soap, NULL, NULL, "tns:GetNthDataSourceResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__setServiceDataResponse(soap, NULL, NULL, "tns:setServiceDataResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__DetachResponse(soap, NULL, NULL, "tns:DetachResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__AppStopResponse(soap, NULL, NULL, "tns:AppStopResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__StopResponse(soap, NULL, NULL, "tns:StopResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__AppStartResponse(soap, NULL, NULL, "tns:AppStartResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__GetStatusResponse(soap, NULL, NULL, "tns:GetStatusResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__PutStatusRequest(soap, NULL, NULL, "xsdl:PutStatusRequest");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__StopRequest(soap, NULL, NULL, "xsdl:StopRequest");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__DetachRequest(soap, NULL, NULL, "xsdl:DetachRequest");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__AppDetachRequest(soap, NULL, NULL, "xsdl:AppDetachRequest");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__GetNthDataSourceRequest(soap, NULL, NULL, "xsdl:GetNthDataSourceRequest");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__AttachRequest(soap, NULL, NULL, "xsdl:AttachRequest");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__GetNthDataSourceResponse(soap, NULL, NULL, "xsdl:GetNthDataSourceResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__AppStartRequest(soap, NULL, NULL, "xsdl:AppStartRequest");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__AppDetachResponse(soap, NULL, NULL, "xsdl:AppDetachResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__PutStatusResponse(soap, NULL, NULL, "xsdl:PutStatusResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__AttachResponse(soap, NULL, NULL, "xsdl:AttachResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__GetControlRequest(soap, NULL, NULL, "xsdl:GetControlRequest");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__ResumeResponse(soap, NULL, NULL, "xsdl:ResumeResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__PutControlResponse(soap, NULL, NULL, "xsdl:PutControlResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__PauseResponse(soap, NULL, NULL, "xsdl:PauseResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__findServiceDataRequest(soap, NULL, NULL, "xsdl:findServiceDataRequest");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__GetStatusRequest(soap, NULL, NULL, "xsdl:GetStatusRequest");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__setServiceDataResponse(soap, NULL, NULL, "xsdl:setServiceDataResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__StopResponse(soap, NULL, NULL, "xsdl:StopResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__DetachResponse(soap, NULL, NULL, "xsdl:DetachResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__findServiceDataResponse(soap, NULL, NULL, "xsdl:findServiceDataResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__ResumeRequest(soap, NULL, NULL, "xsdl:ResumeRequest");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__AppStopResponse(soap, NULL, NULL, "xsdl:AppStopResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__AppStartResponse(soap, NULL, NULL, "xsdl:AppStartResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__AppStopRequest(soap, NULL, NULL, "xsdl:AppStopRequest");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__PauseRequest(soap, NULL, NULL, "xsdl:PauseRequest");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__GetNotificationsRequest(soap, NULL, NULL, "xsdl:GetNotificationsRequest");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__GetStatusResponse(soap, NULL, NULL, "xsdl:GetStatusResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__GetNotificationsResponse(soap, NULL, NULL, "xsdl:GetNotificationsResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__setServiceDataRequest(soap, NULL, NULL, "xsdl:setServiceDataRequest");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__DestroyRequest(soap, NULL, NULL, "xsdl:DestroyRequest");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__PutControlRequest(soap, NULL, NULL, "xsdl:PutControlRequest");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__GetControlResponse(soap, NULL, NULL, "xsdl:GetControlResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsdl__DestroyResponse(soap, NULL, NULL, "xsdl:DestroyResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsd__integer(soap, NULL, NULL, "xsd:integer");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_string(soap, NULL, NULL, "xsd:string");
			if (soap->error)
			{	soap->peeked = 1;
				soap_ignore_element(soap);
			}
		}
		if (soap->error)
			break;
	}
	if (soap->error == SOAP_NO_TAG)
		soap->error = SOAP_OK;
	return soap->error;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version != 1 || (soap->mode & SOAP_XML_GRAPH) || (soap->mode & SOAP_XML_TREE))
		return SOAP_OK;
	for (i = 0; i < SOAP_PTRHASH; i++)
		for (pp = soap->pht[i]; pp; pp = pp->next)
			if ((soap->mode & SOAP_IO_LENGTH) ? pp->mark1 == 2 : pp->mark2 == 2)
				switch (pp->type)
				{
				case SOAP_TYPE_byte:
					soap_out_byte(soap, "id", pp->id, (const char *)pp->ptr, "xsd:byte");
					break;
				case SOAP_TYPE_int:
					soap_out_int(soap, "id", pp->id, (const int *)pp->ptr, "xsd:int");
					break;
				case SOAP_TYPE_tns__GetControl:
					soap_out_tns__GetControl(soap, "id", pp->id, (const struct tns__GetControl *)pp->ptr, "tns:GetControl");
					break;
				case SOAP_TYPE_tns__Attach:
					soap_out_tns__Attach(soap, "id", pp->id, (const struct tns__Attach *)pp->ptr, "tns:Attach");
					break;
				case SOAP_TYPE_tns__AppStart:
					soap_out_tns__AppStart(soap, "id", pp->id, (const struct tns__AppStart *)pp->ptr, "tns:AppStart");
					break;
				case SOAP_TYPE_tns__Destroy:
					soap_out_tns__Destroy(soap, "id", pp->id, (const struct tns__Destroy *)pp->ptr, "tns:Destroy");
					break;
				case SOAP_TYPE_tns__PutControl:
					soap_out_tns__PutControl(soap, "id", pp->id, (const struct tns__PutControl *)pp->ptr, "tns:PutControl");
					break;
				case SOAP_TYPE_tns__Resume:
					soap_out_tns__Resume(soap, "id", pp->id, (const struct tns__Resume *)pp->ptr, "tns:Resume");
					break;
				case SOAP_TYPE_tns__GetStatus:
					soap_out_tns__GetStatus(soap, "id", pp->id, (const struct tns__GetStatus *)pp->ptr, "tns:GetStatus");
					break;
				case SOAP_TYPE_tns__PutStatus:
					soap_out_tns__PutStatus(soap, "id", pp->id, (const struct tns__PutStatus *)pp->ptr, "tns:PutStatus");
					break;
				case SOAP_TYPE_tns__GetNthDataSource:
					soap_out_tns__GetNthDataSource(soap, "id", pp->id, (const struct tns__GetNthDataSource *)pp->ptr, "tns:GetNthDataSource");
					break;
				case SOAP_TYPE_tns__Stop:
					soap_out_tns__Stop(soap, "id", pp->id, (const struct tns__Stop *)pp->ptr, "tns:Stop");
					break;
				case SOAP_TYPE_tns__Pause:
					soap_out_tns__Pause(soap, "id", pp->id, (const struct tns__Pause *)pp->ptr, "tns:Pause");
					break;
				case SOAP_TYPE_tns__setServiceData:
					soap_out_tns__setServiceData(soap, "id", pp->id, (const struct tns__setServiceData *)pp->ptr, "tns:setServiceData");
					break;
				case SOAP_TYPE_tns__AppStop:
					soap_out_tns__AppStop(soap, "id", pp->id, (const struct tns__AppStop *)pp->ptr, "tns:AppStop");
					break;
				case SOAP_TYPE_tns__findServiceData:
					soap_out_tns__findServiceData(soap, "id", pp->id, (const struct tns__findServiceData *)pp->ptr, "tns:findServiceData");
					break;
				case SOAP_TYPE_tns__Detach:
					soap_out_tns__Detach(soap, "id", pp->id, (const struct tns__Detach *)pp->ptr, "tns:Detach");
					break;
				case SOAP_TYPE_tns__AppDetach:
					soap_out_tns__AppDetach(soap, "id", pp->id, (const struct tns__AppDetach *)pp->ptr, "tns:AppDetach");
					break;
				case SOAP_TYPE_tns__GetNotifications:
					soap_out_tns__GetNotifications(soap, "id", pp->id, (const struct tns__GetNotifications *)pp->ptr, "tns:GetNotifications");
					break;
				case SOAP_TYPE_tns__GetControlResponse:
					soap_out_tns__GetControlResponse(soap, "id", pp->id, (const struct tns__GetControlResponse *)pp->ptr, "tns:GetControlResponse");
					break;
				case SOAP_TYPE_tns__DestroyResponse:
					soap_out_tns__DestroyResponse(soap, "id", pp->id, (const struct tns__DestroyResponse *)pp->ptr, "tns:DestroyResponse");
					break;
				case SOAP_TYPE_tns__GetNotificationsResponse:
					soap_out_tns__GetNotificationsResponse(soap, "id", pp->id, (const struct tns__GetNotificationsResponse *)pp->ptr, "tns:GetNotificationsResponse");
					break;
				case SOAP_TYPE_tns__PauseResponse:
					soap_out_tns__PauseResponse(soap, "id", pp->id, (const struct tns__PauseResponse *)pp->ptr, "tns:PauseResponse");
					break;
				case SOAP_TYPE_tns__findServiceDataResponse:
					soap_out_tns__findServiceDataResponse(soap, "id", pp->id, (const struct tns__findServiceDataResponse *)pp->ptr, "tns:findServiceDataResponse");
					break;
				case SOAP_TYPE_tns__AttachResponse:
					soap_out_tns__AttachResponse(soap, "id", pp->id, (const struct tns__AttachResponse *)pp->ptr, "tns:AttachResponse");
					break;
				case SOAP_TYPE_tns__PutStatusResponse:
					soap_out_tns__PutStatusResponse(soap, "id", pp->id, (const struct tns__PutStatusResponse *)pp->ptr, "tns:PutStatusResponse");
					break;
				case SOAP_TYPE_tns__PutControlResponse:
					soap_out_tns__PutControlResponse(soap, "id", pp->id, (const struct tns__PutControlResponse *)pp->ptr, "tns:PutControlResponse");
					break;
				case SOAP_TYPE_tns__AppDetachResponse:
					soap_out_tns__AppDetachResponse(soap, "id", pp->id, (const struct tns__AppDetachResponse *)pp->ptr, "tns:AppDetachResponse");
					break;
				case SOAP_TYPE_tns__ResumeResponse:
					soap_out_tns__ResumeResponse(soap, "id", pp->id, (const struct tns__ResumeResponse *)pp->ptr, "tns:ResumeResponse");
					break;
				case SOAP_TYPE_tns__GetNthDataSourceResponse:
					soap_out_tns__GetNthDataSourceResponse(soap, "id", pp->id, (const struct tns__GetNthDataSourceResponse *)pp->ptr, "tns:GetNthDataSourceResponse");
					break;
				case SOAP_TYPE_tns__setServiceDataResponse:
					soap_out_tns__setServiceDataResponse(soap, "id", pp->id, (const struct tns__setServiceDataResponse *)pp->ptr, "tns:setServiceDataResponse");
					break;
				case SOAP_TYPE_tns__DetachResponse:
					soap_out_tns__DetachResponse(soap, "id", pp->id, (const struct tns__DetachResponse *)pp->ptr, "tns:DetachResponse");
					break;
				case SOAP_TYPE_tns__AppStopResponse:
					soap_out_tns__AppStopResponse(soap, "id", pp->id, (const struct tns__AppStopResponse *)pp->ptr, "tns:AppStopResponse");
					break;
				case SOAP_TYPE_tns__StopResponse:
					soap_out_tns__StopResponse(soap, "id", pp->id, (const struct tns__StopResponse *)pp->ptr, "tns:StopResponse");
					break;
				case SOAP_TYPE_tns__AppStartResponse:
					soap_out_tns__AppStartResponse(soap, "id", pp->id, (const struct tns__AppStartResponse *)pp->ptr, "tns:AppStartResponse");
					break;
				case SOAP_TYPE_tns__GetStatusResponse:
					soap_out_tns__GetStatusResponse(soap, "id", pp->id, (const struct tns__GetStatusResponse *)pp->ptr, "tns:GetStatusResponse");
					break;
				case SOAP_TYPE_PointerTotns__GetControlResponse:
					soap_out_PointerTotns__GetControlResponse(soap, "id", pp->id, (struct tns__GetControlResponse *const*)pp->ptr, "tns:GetControlResponse");
					break;
				case SOAP_TYPE_PointerTotns__AttachResponse:
					soap_out_PointerTotns__AttachResponse(soap, "id", pp->id, (struct tns__AttachResponse *const*)pp->ptr, "tns:AttachResponse");
					break;
				case SOAP_TYPE_PointerTotns__AppStartResponse:
					soap_out_PointerTotns__AppStartResponse(soap, "id", pp->id, (struct tns__AppStartResponse *const*)pp->ptr, "tns:AppStartResponse");
					break;
				case SOAP_TYPE_PointerTotns__DestroyResponse:
					soap_out_PointerTotns__DestroyResponse(soap, "id", pp->id, (struct tns__DestroyResponse *const*)pp->ptr, "tns:DestroyResponse");
					break;
				case SOAP_TYPE_PointerTotns__PutControlResponse:
					soap_out_PointerTotns__PutControlResponse(soap, "id", pp->id, (struct tns__PutControlResponse *const*)pp->ptr, "tns:PutControlResponse");
					break;
				case SOAP_TYPE_PointerTotns__ResumeResponse:
					soap_out_PointerTotns__ResumeResponse(soap, "id", pp->id, (struct tns__ResumeResponse *const*)pp->ptr, "tns:ResumeResponse");
					break;
				case SOAP_TYPE_PointerTotns__GetStatusResponse:
					soap_out_PointerTotns__GetStatusResponse(soap, "id", pp->id, (struct tns__GetStatusResponse *const*)pp->ptr, "tns:GetStatusResponse");
					break;
				case SOAP_TYPE_PointerTotns__PutStatusResponse:
					soap_out_PointerTotns__PutStatusResponse(soap, "id", pp->id, (struct tns__PutStatusResponse *const*)pp->ptr, "tns:PutStatusResponse");
					break;
				case SOAP_TYPE_PointerTotns__GetNthDataSourceResponse:
					soap_out_PointerTotns__GetNthDataSourceResponse(soap, "id", pp->id, (struct tns__GetNthDataSourceResponse *const*)pp->ptr, "tns:GetNthDataSourceResponse");
					break;
				case SOAP_TYPE_PointerTotns__StopResponse:
					soap_out_PointerTotns__StopResponse(soap, "id", pp->id, (struct tns__StopResponse *const*)pp->ptr, "tns:StopResponse");
					break;
				case SOAP_TYPE_PointerTotns__PauseResponse:
					soap_out_PointerTotns__PauseResponse(soap, "id", pp->id, (struct tns__PauseResponse *const*)pp->ptr, "tns:PauseResponse");
					break;
				case SOAP_TYPE_PointerTotns__setServiceDataResponse:
					soap_out_PointerTotns__setServiceDataResponse(soap, "id", pp->id, (struct tns__setServiceDataResponse *const*)pp->ptr, "tns:setServiceDataResponse");
					break;
				case SOAP_TYPE_PointerTotns__AppStopResponse:
					soap_out_PointerTotns__AppStopResponse(soap, "id", pp->id, (struct tns__AppStopResponse *const*)pp->ptr, "tns:AppStopResponse");
					break;
				case SOAP_TYPE_PointerTotns__findServiceDataResponse:
					soap_out_PointerTotns__findServiceDataResponse(soap, "id", pp->id, (struct tns__findServiceDataResponse *const*)pp->ptr, "tns:findServiceDataResponse");
					break;
				case SOAP_TYPE_PointerTotns__DetachResponse:
					soap_out_PointerTotns__DetachResponse(soap, "id", pp->id, (struct tns__DetachResponse *const*)pp->ptr, "tns:DetachResponse");
					break;
				case SOAP_TYPE_PointerTotns__AppDetachResponse:
					soap_out_PointerTotns__AppDetachResponse(soap, "id", pp->id, (struct tns__AppDetachResponse *const*)pp->ptr, "tns:AppDetachResponse");
					break;
				case SOAP_TYPE_PointerTotns__GetNotificationsResponse:
					soap_out_PointerTotns__GetNotificationsResponse(soap, "id", pp->id, (struct tns__GetNotificationsResponse *const*)pp->ptr, "tns:GetNotificationsResponse");
					break;
				case SOAP_TYPE_xsdl__PutStatusRequest:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:PutStatusRequest");
					break;
				case SOAP_TYPE_xsdl__StopRequest:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:StopRequest");
					break;
				case SOAP_TYPE_xsdl__DetachRequest:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:DetachRequest");
					break;
				case SOAP_TYPE_xsdl__AppDetachRequest:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:AppDetachRequest");
					break;
				case SOAP_TYPE_xsdl__GetNthDataSourceRequest:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:GetNthDataSourceRequest");
					break;
				case SOAP_TYPE_xsdl__AttachRequest:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:AttachRequest");
					break;
				case SOAP_TYPE_xsdl__GetNthDataSourceResponse:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:GetNthDataSourceResponse");
					break;
				case SOAP_TYPE_xsdl__AppStartRequest:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:AppStartRequest");
					break;
				case SOAP_TYPE_xsdl__AppDetachResponse:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:AppDetachResponse");
					break;
				case SOAP_TYPE_xsdl__PutStatusResponse:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:PutStatusResponse");
					break;
				case SOAP_TYPE_xsdl__AttachResponse:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:AttachResponse");
					break;
				case SOAP_TYPE_xsdl__GetControlRequest:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:GetControlRequest");
					break;
				case SOAP_TYPE_xsdl__ResumeResponse:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:ResumeResponse");
					break;
				case SOAP_TYPE_xsdl__PutControlResponse:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:PutControlResponse");
					break;
				case SOAP_TYPE_xsdl__PauseResponse:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:PauseResponse");
					break;
				case SOAP_TYPE_xsdl__findServiceDataRequest:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:findServiceDataRequest");
					break;
				case SOAP_TYPE_xsdl__GetStatusRequest:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:GetStatusRequest");
					break;
				case SOAP_TYPE_xsdl__setServiceDataResponse:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:setServiceDataResponse");
					break;
				case SOAP_TYPE_xsdl__StopResponse:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:StopResponse");
					break;
				case SOAP_TYPE_xsdl__DetachResponse:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:DetachResponse");
					break;
				case SOAP_TYPE_xsdl__findServiceDataResponse:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:findServiceDataResponse");
					break;
				case SOAP_TYPE_xsdl__ResumeRequest:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:ResumeRequest");
					break;
				case SOAP_TYPE_xsdl__AppStopResponse:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:AppStopResponse");
					break;
				case SOAP_TYPE_xsdl__AppStartResponse:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:AppStartResponse");
					break;
				case SOAP_TYPE_xsdl__AppStopRequest:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:AppStopRequest");
					break;
				case SOAP_TYPE_xsdl__PauseRequest:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:PauseRequest");
					break;
				case SOAP_TYPE_xsdl__GetNotificationsRequest:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:GetNotificationsRequest");
					break;
				case SOAP_TYPE_xsdl__GetStatusResponse:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:GetStatusResponse");
					break;
				case SOAP_TYPE_xsdl__GetNotificationsResponse:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:GetNotificationsResponse");
					break;
				case SOAP_TYPE_xsdl__setServiceDataRequest:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:setServiceDataRequest");
					break;
				case SOAP_TYPE_xsdl__DestroyRequest:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:DestroyRequest");
					break;
				case SOAP_TYPE_xsdl__PutControlRequest:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:PutControlRequest");
					break;
				case SOAP_TYPE_xsdl__GetControlResponse:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:GetControlResponse");
					break;
				case SOAP_TYPE_xsdl__DestroyResponse:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsdl:DestroyResponse");
					break;
				case SOAP_TYPE_xsd__integer:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsd:integer");
					break;
				case SOAP_TYPE_xsd__string:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsd:string");
					break;
				case SOAP_TYPE_string:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsd:string");
					break;
				}
		
	return SOAP_OK;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_getattachments(struct soap *soap)
{
	if (!(soap->mode & SOAP_ENC_DIME))
		return SOAP_OK;
	while (soap->dime_flags & SOAP_DIME_CF)
	{	if (soap_getdimehdr(soap))
			return soap->error;
		if (soap_move(soap, soap->dime_size))
			return soap->error = SOAP_EOF;
	}
	if (soap_move(soap, ((soap->dime_size+3)&-4)-soap_tell(soap)))
		return soap->error = SOAP_EOF;
	for (;;)
	{	if (soap_getdime(soap) || !soap->dime_id)
			break;
		switch (soap_lookup_type(soap, soap->dime_id))
		{
		case SOAP_TYPE_xsdl__PutStatusRequest:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__PutStatusRequest, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__StopRequest:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__StopRequest, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__DetachRequest:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__DetachRequest, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__AppDetachRequest:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__AppDetachRequest, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__GetNthDataSourceRequest:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__GetNthDataSourceRequest, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__AttachRequest:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__AttachRequest, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__GetNthDataSourceResponse:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__GetNthDataSourceResponse, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__AppStartRequest:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__AppStartRequest, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__AppDetachResponse:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__AppDetachResponse, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__PutStatusResponse:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__PutStatusResponse, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__AttachResponse:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__AttachResponse, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__GetControlRequest:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__GetControlRequest, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__ResumeResponse:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__ResumeResponse, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__PutControlResponse:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__PutControlResponse, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__PauseResponse:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__PauseResponse, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__findServiceDataRequest:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__findServiceDataRequest, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__GetStatusRequest:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__GetStatusRequest, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__setServiceDataResponse:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__setServiceDataResponse, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__StopResponse:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__StopResponse, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__DetachResponse:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__DetachResponse, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__findServiceDataResponse:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__findServiceDataResponse, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__ResumeRequest:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__ResumeRequest, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__AppStopResponse:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__AppStopResponse, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__AppStartResponse:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__AppStartResponse, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__AppStopRequest:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__AppStopRequest, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__PauseRequest:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__PauseRequest, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__GetNotificationsRequest:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__GetNotificationsRequest, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__GetStatusResponse:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__GetStatusResponse, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__GetNotificationsResponse:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__GetNotificationsResponse, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__setServiceDataRequest:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__setServiceDataRequest, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__DestroyRequest:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__DestroyRequest, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__PutControlRequest:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__PutControlRequest, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__GetControlResponse:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__GetControlResponse, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsdl__DestroyResponse:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsdl__DestroyResponse, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsd__integer:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsd__integer, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsd__string:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsd__string, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_string:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_string, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		default:
			soap->error = SOAP_DIME_ERROR;
		}
		if (soap->error)
			break;
	}
	if (soap->error == SOAP_EOD)
		soap->error = SOAP_OK;
	return soap->error;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_putattachments(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (!(soap->mode & SOAP_ENC_DIME))
		return SOAP_OK;
	if (soap_send_raw(soap, "\0\0\0", -(int)soap->count&3))
		return soap->error;
	for (i = 0; i < SOAP_PTRHASH; i++)
		for (pp = soap->pht[i]; pp; pp = pp->next)
			if (pp->mark2 == 3)
				switch (pp->type)
				{
				}
		
	return SOAP_OK;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_byte(struct soap *soap, char *a)
{
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_byte(struct soap *soap, char const*a)
{
	soap_reference(soap, a, SOAP_TYPE_byte);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_byte(struct soap *soap, char *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_byte, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_byte(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_byte(soap, tag, i, a, type);
		}
	else
		soap_out_byte(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC1 char * SOAP_FMAC2 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * SOAP_FMAC2 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_int(struct soap *soap, int *a)
{
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_int(struct soap *soap, int const*a)
{
	soap_reference(soap, a, SOAP_TYPE_int);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_int(struct soap *soap, int *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_int, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_int(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_int(soap, tag, i, a, type);
		}
	else
		soap_out_int(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC1 int * SOAP_FMAC2 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 int * SOAP_FMAC2 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_SOAP_ENV__Fault))
		soap_mark_SOAP_ENV__Fault(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	soap_embedded(soap, &a->faultcode, SOAP_TYPE_string);
	soap_mark_string(soap, &a->faultcode);
	soap_embedded(soap, &a->faultstring, SOAP_TYPE_string);
	soap_mark_string(soap, &a->faultstring);
	soap_embedded(soap, &a->faultactor, SOAP_TYPE_string);
	soap_mark_string(soap, &a->faultactor);
	soap_embedded(soap, &a->detail, SOAP_TYPE_string);
	soap_mark_string(soap, &a->detail);
	soap_embedded(soap, &a->SOAP_ENV__Code, SOAP_TYPE_PointerToSOAP_ENV__Code);
	soap_mark_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_embedded(soap, &a->SOAP_ENV__Reason, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Reason);
	soap_embedded(soap, &a->SOAP_ENV__Detail, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	soap_default_string(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	soap_default_string(soap, &a->detail);
	soap_default_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_default_string(soap, &a->SOAP_ENV__Reason);
	soap_default_string(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_SOAP_ENV__Fault, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_SOAP_ENV__Fault(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_SOAP_ENV__Fault(soap, tag, i, a, type);
		}
	else
		soap_out_SOAP_ENV__Fault(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out_string(soap, "faultcode", -1, &a->faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_string(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_string(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_string(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Fault(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode = 0;
					continue;
				}
			if (soap_flag_faultstring && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultstring", &a->faultstring, ""))
				{	soap_flag_faultstring = 0;
					continue;
				}
			if (soap_flag_faultactor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultactor", &a->faultactor, ""))
				{	soap_flag_faultactor = 0;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "detail", &a->detail, ""))
				{	soap_flag_detail = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0), SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault));
		if (soap->alloced)
			soap_default_SOAP_ENV__Fault(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_SOAP_ENV__Code))
		soap_mark_SOAP_ENV__Code(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	soap_embedded(soap, &a->SOAP_ENV__Value, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Value);
	soap_embedded(soap, &a->SOAP_ENV__Node, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Node);
	soap_embedded(soap, &a->SOAP_ENV__Role, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Role);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	soap_default_string(soap, &a->SOAP_ENV__Value);
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_SOAP_ENV__Code, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_SOAP_ENV__Code(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_SOAP_ENV__Code(soap, tag, i, a, type);
		}
	else
		soap_out_SOAP_ENV__Code(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out_string(soap, "SOAP-ENV:Value", -1, &a->SOAP_ENV__Value, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Code(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, ""))
				{	soap_flag_SOAP_ENV__Node = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, ""))
				{	soap_flag_SOAP_ENV__Role = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0), SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code));
		if (soap->alloced)
			soap_default_SOAP_ENV__Code(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_SOAP_ENV__Header))
		soap_mark_SOAP_ENV__Header(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	/* transient dummy skipped */
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	/* transient dummy skipped */
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_SOAP_ENV__Header, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_SOAP_ENV__Header(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_SOAP_ENV__Header(soap, tag, i, a, type);
		}
	else
		soap_out_SOAP_ENV__Header(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	/* transient dummy skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Header(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
		/* transient dummy skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0), SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header));
		if (soap->alloced)
			soap_default_SOAP_ENV__Header(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__GetControl(struct soap *soap, struct tns__GetControl const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__GetControl))
		soap_mark_tns__GetControl(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__GetControl(struct soap *soap, const struct tns__GetControl *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__GetControl(struct soap *soap, struct tns__GetControl *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__GetControl(struct soap *soap, struct tns__GetControl *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__GetControl, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__GetControl(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__GetControl(soap, tag, i, a, type);
		}
	else
		soap_out_tns__GetControl(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__GetControl(struct soap *soap, const char *tag, int id, const struct tns__GetControl *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__GetControl), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__GetControl * SOAP_FMAC2 soap_get_tns__GetControl(struct soap *soap, struct tns__GetControl *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__GetControl(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__GetControl * SOAP_FMAC2 soap_in_tns__GetControl(struct soap *soap, const char *tag, struct tns__GetControl *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__GetControl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__GetControl, sizeof(struct tns__GetControl), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__GetControl(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__GetControl *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__GetControl, sizeof(struct tns__GetControl), 0), SOAP_TYPE_tns__GetControl, sizeof(struct tns__GetControl));
		if (soap->alloced)
			soap_default_tns__GetControl(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__Attach(struct soap *soap, struct tns__Attach const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__Attach))
		soap_mark_tns__Attach(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__Attach(struct soap *soap, const struct tns__Attach *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__Attach(struct soap *soap, struct tns__Attach *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__Attach(struct soap *soap, struct tns__Attach *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__Attach, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__Attach(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__Attach(soap, tag, i, a, type);
		}
	else
		soap_out_tns__Attach(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__Attach(struct soap *soap, const char *tag, int id, const struct tns__Attach *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__Attach), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__Attach * SOAP_FMAC2 soap_get_tns__Attach(struct soap *soap, struct tns__Attach *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__Attach(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__Attach * SOAP_FMAC2 soap_in_tns__Attach(struct soap *soap, const char *tag, struct tns__Attach *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__Attach *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__Attach, sizeof(struct tns__Attach), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__Attach(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__Attach *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__Attach, sizeof(struct tns__Attach), 0), SOAP_TYPE_tns__Attach, sizeof(struct tns__Attach));
		if (soap->alloced)
			soap_default_tns__Attach(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__AppStart(struct soap *soap, struct tns__AppStart const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__AppStart))
		soap_mark_tns__AppStart(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__AppStart(struct soap *soap, const struct tns__AppStart *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__AppStart(struct soap *soap, struct tns__AppStart *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__AppStart(struct soap *soap, struct tns__AppStart *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__AppStart, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__AppStart(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__AppStart(soap, tag, i, a, type);
		}
	else
		soap_out_tns__AppStart(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__AppStart(struct soap *soap, const char *tag, int id, const struct tns__AppStart *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__AppStart), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__AppStart * SOAP_FMAC2 soap_get_tns__AppStart(struct soap *soap, struct tns__AppStart *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__AppStart(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__AppStart * SOAP_FMAC2 soap_in_tns__AppStart(struct soap *soap, const char *tag, struct tns__AppStart *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__AppStart *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__AppStart, sizeof(struct tns__AppStart), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__AppStart(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__AppStart *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__AppStart, sizeof(struct tns__AppStart), 0), SOAP_TYPE_tns__AppStart, sizeof(struct tns__AppStart));
		if (soap->alloced)
			soap_default_tns__AppStart(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__Destroy(struct soap *soap, struct tns__Destroy const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__Destroy))
		soap_mark_tns__Destroy(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__Destroy(struct soap *soap, const struct tns__Destroy *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__Destroy(struct soap *soap, struct tns__Destroy *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__Destroy(struct soap *soap, struct tns__Destroy *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__Destroy, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__Destroy(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__Destroy(soap, tag, i, a, type);
		}
	else
		soap_out_tns__Destroy(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__Destroy(struct soap *soap, const char *tag, int id, const struct tns__Destroy *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__Destroy), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__Destroy * SOAP_FMAC2 soap_get_tns__Destroy(struct soap *soap, struct tns__Destroy *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__Destroy(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__Destroy * SOAP_FMAC2 soap_in_tns__Destroy(struct soap *soap, const char *tag, struct tns__Destroy *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__Destroy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__Destroy, sizeof(struct tns__Destroy), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__Destroy(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__Destroy *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__Destroy, sizeof(struct tns__Destroy), 0), SOAP_TYPE_tns__Destroy, sizeof(struct tns__Destroy));
		if (soap->alloced)
			soap_default_tns__Destroy(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__PutControl(struct soap *soap, struct tns__PutControl const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__PutControl))
		soap_mark_tns__PutControl(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__PutControl(struct soap *soap, const struct tns__PutControl *a)
{
	soap_embedded(soap, &a->input, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->input);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__PutControl(struct soap *soap, struct tns__PutControl *a)
{
	soap_default_xsd__string(soap, &a->input);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__PutControl(struct soap *soap, struct tns__PutControl *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__PutControl, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__PutControl(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__PutControl(soap, tag, i, a, type);
		}
	else
		soap_out_tns__PutControl(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__PutControl(struct soap *soap, const char *tag, int id, const struct tns__PutControl *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__PutControl), type);
	soap_out_xsd__string(soap, "input", -1, &a->input, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__PutControl * SOAP_FMAC2 soap_get_tns__PutControl(struct soap *soap, struct tns__PutControl *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__PutControl(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__PutControl * SOAP_FMAC2 soap_in_tns__PutControl(struct soap *soap, const char *tag, struct tns__PutControl *a, const char *type)
{
	short soap_flag_input = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__PutControl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__PutControl, sizeof(struct tns__PutControl), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__PutControl(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_input && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "input", &a->input, "xsd:string"))
				{	soap_flag_input = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__PutControl *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__PutControl, sizeof(struct tns__PutControl), 0), SOAP_TYPE_tns__PutControl, sizeof(struct tns__PutControl));
		if (soap->alloced)
			soap_default_tns__PutControl(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__Resume(struct soap *soap, struct tns__Resume const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__Resume))
		soap_mark_tns__Resume(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__Resume(struct soap *soap, const struct tns__Resume *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__Resume(struct soap *soap, struct tns__Resume *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__Resume(struct soap *soap, struct tns__Resume *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__Resume, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__Resume(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__Resume(soap, tag, i, a, type);
		}
	else
		soap_out_tns__Resume(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__Resume(struct soap *soap, const char *tag, int id, const struct tns__Resume *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__Resume), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__Resume * SOAP_FMAC2 soap_get_tns__Resume(struct soap *soap, struct tns__Resume *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__Resume(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__Resume * SOAP_FMAC2 soap_in_tns__Resume(struct soap *soap, const char *tag, struct tns__Resume *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__Resume *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__Resume, sizeof(struct tns__Resume), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__Resume(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__Resume *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__Resume, sizeof(struct tns__Resume), 0), SOAP_TYPE_tns__Resume, sizeof(struct tns__Resume));
		if (soap->alloced)
			soap_default_tns__Resume(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__GetStatus(struct soap *soap, struct tns__GetStatus const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__GetStatus))
		soap_mark_tns__GetStatus(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__GetStatus(struct soap *soap, const struct tns__GetStatus *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__GetStatus(struct soap *soap, struct tns__GetStatus *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__GetStatus(struct soap *soap, struct tns__GetStatus *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__GetStatus, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__GetStatus(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__GetStatus(soap, tag, i, a, type);
		}
	else
		soap_out_tns__GetStatus(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__GetStatus(struct soap *soap, const char *tag, int id, const struct tns__GetStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__GetStatus), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__GetStatus * SOAP_FMAC2 soap_get_tns__GetStatus(struct soap *soap, struct tns__GetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__GetStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__GetStatus * SOAP_FMAC2 soap_in_tns__GetStatus(struct soap *soap, const char *tag, struct tns__GetStatus *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__GetStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__GetStatus, sizeof(struct tns__GetStatus), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__GetStatus(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__GetStatus *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__GetStatus, sizeof(struct tns__GetStatus), 0), SOAP_TYPE_tns__GetStatus, sizeof(struct tns__GetStatus));
		if (soap->alloced)
			soap_default_tns__GetStatus(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__PutStatus(struct soap *soap, struct tns__PutStatus const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__PutStatus))
		soap_mark_tns__PutStatus(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__PutStatus(struct soap *soap, const struct tns__PutStatus *a)
{
	soap_embedded(soap, &a->input, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->input);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__PutStatus(struct soap *soap, struct tns__PutStatus *a)
{
	soap_default_xsd__string(soap, &a->input);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__PutStatus(struct soap *soap, struct tns__PutStatus *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__PutStatus, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__PutStatus(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__PutStatus(soap, tag, i, a, type);
		}
	else
		soap_out_tns__PutStatus(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__PutStatus(struct soap *soap, const char *tag, int id, const struct tns__PutStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__PutStatus), type);
	soap_out_xsd__string(soap, "input", -1, &a->input, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__PutStatus * SOAP_FMAC2 soap_get_tns__PutStatus(struct soap *soap, struct tns__PutStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__PutStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__PutStatus * SOAP_FMAC2 soap_in_tns__PutStatus(struct soap *soap, const char *tag, struct tns__PutStatus *a, const char *type)
{
	short soap_flag_input = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__PutStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__PutStatus, sizeof(struct tns__PutStatus), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__PutStatus(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_input && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "input", &a->input, "xsd:string"))
				{	soap_flag_input = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__PutStatus *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__PutStatus, sizeof(struct tns__PutStatus), 0), SOAP_TYPE_tns__PutStatus, sizeof(struct tns__PutStatus));
		if (soap->alloced)
			soap_default_tns__PutStatus(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__GetNthDataSource(struct soap *soap, struct tns__GetNthDataSource const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__GetNthDataSource))
		soap_mark_tns__GetNthDataSource(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__GetNthDataSource(struct soap *soap, const struct tns__GetNthDataSource *a)
{
	soap_embedded(soap, &a->input, SOAP_TYPE_xsd__integer);
	soap_mark_xsd__integer(soap, &a->input);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__GetNthDataSource(struct soap *soap, struct tns__GetNthDataSource *a)
{
	soap_default_xsd__integer(soap, &a->input);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__GetNthDataSource(struct soap *soap, struct tns__GetNthDataSource *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__GetNthDataSource, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__GetNthDataSource(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__GetNthDataSource(soap, tag, i, a, type);
		}
	else
		soap_out_tns__GetNthDataSource(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__GetNthDataSource(struct soap *soap, const char *tag, int id, const struct tns__GetNthDataSource *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__GetNthDataSource), type);
	soap_out_xsd__integer(soap, "input", -1, &a->input, "xsd:integer");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__GetNthDataSource * SOAP_FMAC2 soap_get_tns__GetNthDataSource(struct soap *soap, struct tns__GetNthDataSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__GetNthDataSource(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__GetNthDataSource * SOAP_FMAC2 soap_in_tns__GetNthDataSource(struct soap *soap, const char *tag, struct tns__GetNthDataSource *a, const char *type)
{
	short soap_flag_input = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__GetNthDataSource *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__GetNthDataSource, sizeof(struct tns__GetNthDataSource), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__GetNthDataSource(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_input && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__integer(soap, "input", &a->input, "xsd:integer"))
				{	soap_flag_input = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__GetNthDataSource *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__GetNthDataSource, sizeof(struct tns__GetNthDataSource), 0), SOAP_TYPE_tns__GetNthDataSource, sizeof(struct tns__GetNthDataSource));
		if (soap->alloced)
			soap_default_tns__GetNthDataSource(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__Stop(struct soap *soap, struct tns__Stop const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__Stop))
		soap_mark_tns__Stop(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__Stop(struct soap *soap, const struct tns__Stop *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__Stop(struct soap *soap, struct tns__Stop *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__Stop(struct soap *soap, struct tns__Stop *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__Stop, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__Stop(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__Stop(soap, tag, i, a, type);
		}
	else
		soap_out_tns__Stop(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__Stop(struct soap *soap, const char *tag, int id, const struct tns__Stop *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__Stop), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__Stop * SOAP_FMAC2 soap_get_tns__Stop(struct soap *soap, struct tns__Stop *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__Stop(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__Stop * SOAP_FMAC2 soap_in_tns__Stop(struct soap *soap, const char *tag, struct tns__Stop *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__Stop *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__Stop, sizeof(struct tns__Stop), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__Stop(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__Stop *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__Stop, sizeof(struct tns__Stop), 0), SOAP_TYPE_tns__Stop, sizeof(struct tns__Stop));
		if (soap->alloced)
			soap_default_tns__Stop(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__Pause(struct soap *soap, struct tns__Pause const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__Pause))
		soap_mark_tns__Pause(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__Pause(struct soap *soap, const struct tns__Pause *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__Pause(struct soap *soap, struct tns__Pause *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__Pause(struct soap *soap, struct tns__Pause *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__Pause, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__Pause(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__Pause(soap, tag, i, a, type);
		}
	else
		soap_out_tns__Pause(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__Pause(struct soap *soap, const char *tag, int id, const struct tns__Pause *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__Pause), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__Pause * SOAP_FMAC2 soap_get_tns__Pause(struct soap *soap, struct tns__Pause *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__Pause(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__Pause * SOAP_FMAC2 soap_in_tns__Pause(struct soap *soap, const char *tag, struct tns__Pause *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__Pause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__Pause, sizeof(struct tns__Pause), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__Pause(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__Pause *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__Pause, sizeof(struct tns__Pause), 0), SOAP_TYPE_tns__Pause, sizeof(struct tns__Pause));
		if (soap->alloced)
			soap_default_tns__Pause(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__setServiceData(struct soap *soap, struct tns__setServiceData const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__setServiceData))
		soap_mark_tns__setServiceData(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__setServiceData(struct soap *soap, const struct tns__setServiceData *a)
{
	soap_embedded(soap, &a->input, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->input);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__setServiceData(struct soap *soap, struct tns__setServiceData *a)
{
	soap_default_xsd__string(soap, &a->input);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__setServiceData(struct soap *soap, struct tns__setServiceData *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__setServiceData, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__setServiceData(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__setServiceData(soap, tag, i, a, type);
		}
	else
		soap_out_tns__setServiceData(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__setServiceData(struct soap *soap, const char *tag, int id, const struct tns__setServiceData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__setServiceData), type);
	soap_out_xsd__string(soap, "input", -1, &a->input, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__setServiceData * SOAP_FMAC2 soap_get_tns__setServiceData(struct soap *soap, struct tns__setServiceData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__setServiceData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__setServiceData * SOAP_FMAC2 soap_in_tns__setServiceData(struct soap *soap, const char *tag, struct tns__setServiceData *a, const char *type)
{
	short soap_flag_input = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__setServiceData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__setServiceData, sizeof(struct tns__setServiceData), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__setServiceData(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_input && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "input", &a->input, "xsd:string"))
				{	soap_flag_input = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__setServiceData *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__setServiceData, sizeof(struct tns__setServiceData), 0), SOAP_TYPE_tns__setServiceData, sizeof(struct tns__setServiceData));
		if (soap->alloced)
			soap_default_tns__setServiceData(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__AppStop(struct soap *soap, struct tns__AppStop const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__AppStop))
		soap_mark_tns__AppStop(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__AppStop(struct soap *soap, const struct tns__AppStop *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__AppStop(struct soap *soap, struct tns__AppStop *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__AppStop(struct soap *soap, struct tns__AppStop *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__AppStop, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__AppStop(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__AppStop(soap, tag, i, a, type);
		}
	else
		soap_out_tns__AppStop(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__AppStop(struct soap *soap, const char *tag, int id, const struct tns__AppStop *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__AppStop), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__AppStop * SOAP_FMAC2 soap_get_tns__AppStop(struct soap *soap, struct tns__AppStop *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__AppStop(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__AppStop * SOAP_FMAC2 soap_in_tns__AppStop(struct soap *soap, const char *tag, struct tns__AppStop *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__AppStop *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__AppStop, sizeof(struct tns__AppStop), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__AppStop(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__AppStop *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__AppStop, sizeof(struct tns__AppStop), 0), SOAP_TYPE_tns__AppStop, sizeof(struct tns__AppStop));
		if (soap->alloced)
			soap_default_tns__AppStop(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__findServiceData(struct soap *soap, struct tns__findServiceData const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__findServiceData))
		soap_mark_tns__findServiceData(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__findServiceData(struct soap *soap, const struct tns__findServiceData *a)
{
	soap_embedded(soap, &a->input, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->input);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__findServiceData(struct soap *soap, struct tns__findServiceData *a)
{
	soap_default_xsd__string(soap, &a->input);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__findServiceData(struct soap *soap, struct tns__findServiceData *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__findServiceData, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__findServiceData(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__findServiceData(soap, tag, i, a, type);
		}
	else
		soap_out_tns__findServiceData(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__findServiceData(struct soap *soap, const char *tag, int id, const struct tns__findServiceData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__findServiceData), type);
	soap_out_xsd__string(soap, "input", -1, &a->input, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__findServiceData * SOAP_FMAC2 soap_get_tns__findServiceData(struct soap *soap, struct tns__findServiceData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__findServiceData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__findServiceData * SOAP_FMAC2 soap_in_tns__findServiceData(struct soap *soap, const char *tag, struct tns__findServiceData *a, const char *type)
{
	short soap_flag_input = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__findServiceData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__findServiceData, sizeof(struct tns__findServiceData), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__findServiceData(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_input && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "input", &a->input, "xsd:string"))
				{	soap_flag_input = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__findServiceData *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__findServiceData, sizeof(struct tns__findServiceData), 0), SOAP_TYPE_tns__findServiceData, sizeof(struct tns__findServiceData));
		if (soap->alloced)
			soap_default_tns__findServiceData(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__Detach(struct soap *soap, struct tns__Detach const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__Detach))
		soap_mark_tns__Detach(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__Detach(struct soap *soap, const struct tns__Detach *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__Detach(struct soap *soap, struct tns__Detach *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__Detach(struct soap *soap, struct tns__Detach *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__Detach, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__Detach(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__Detach(soap, tag, i, a, type);
		}
	else
		soap_out_tns__Detach(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__Detach(struct soap *soap, const char *tag, int id, const struct tns__Detach *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__Detach), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__Detach * SOAP_FMAC2 soap_get_tns__Detach(struct soap *soap, struct tns__Detach *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__Detach(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__Detach * SOAP_FMAC2 soap_in_tns__Detach(struct soap *soap, const char *tag, struct tns__Detach *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__Detach *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__Detach, sizeof(struct tns__Detach), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__Detach(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__Detach *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__Detach, sizeof(struct tns__Detach), 0), SOAP_TYPE_tns__Detach, sizeof(struct tns__Detach));
		if (soap->alloced)
			soap_default_tns__Detach(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__AppDetach(struct soap *soap, struct tns__AppDetach const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__AppDetach))
		soap_mark_tns__AppDetach(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__AppDetach(struct soap *soap, const struct tns__AppDetach *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__AppDetach(struct soap *soap, struct tns__AppDetach *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__AppDetach(struct soap *soap, struct tns__AppDetach *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__AppDetach, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__AppDetach(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__AppDetach(soap, tag, i, a, type);
		}
	else
		soap_out_tns__AppDetach(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__AppDetach(struct soap *soap, const char *tag, int id, const struct tns__AppDetach *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__AppDetach), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__AppDetach * SOAP_FMAC2 soap_get_tns__AppDetach(struct soap *soap, struct tns__AppDetach *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__AppDetach(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__AppDetach * SOAP_FMAC2 soap_in_tns__AppDetach(struct soap *soap, const char *tag, struct tns__AppDetach *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__AppDetach *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__AppDetach, sizeof(struct tns__AppDetach), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__AppDetach(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__AppDetach *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__AppDetach, sizeof(struct tns__AppDetach), 0), SOAP_TYPE_tns__AppDetach, sizeof(struct tns__AppDetach));
		if (soap->alloced)
			soap_default_tns__AppDetach(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__GetNotifications(struct soap *soap, struct tns__GetNotifications const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__GetNotifications))
		soap_mark_tns__GetNotifications(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__GetNotifications(struct soap *soap, const struct tns__GetNotifications *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__GetNotifications(struct soap *soap, struct tns__GetNotifications *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__GetNotifications(struct soap *soap, struct tns__GetNotifications *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__GetNotifications, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__GetNotifications(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__GetNotifications(soap, tag, i, a, type);
		}
	else
		soap_out_tns__GetNotifications(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__GetNotifications(struct soap *soap, const char *tag, int id, const struct tns__GetNotifications *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__GetNotifications), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__GetNotifications * SOAP_FMAC2 soap_get_tns__GetNotifications(struct soap *soap, struct tns__GetNotifications *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__GetNotifications(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__GetNotifications * SOAP_FMAC2 soap_in_tns__GetNotifications(struct soap *soap, const char *tag, struct tns__GetNotifications *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__GetNotifications *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__GetNotifications, sizeof(struct tns__GetNotifications), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__GetNotifications(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__GetNotifications *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__GetNotifications, sizeof(struct tns__GetNotifications), 0), SOAP_TYPE_tns__GetNotifications, sizeof(struct tns__GetNotifications));
		if (soap->alloced)
			soap_default_tns__GetNotifications(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__GetControlResponse(struct soap *soap, struct tns__GetControlResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__GetControlResponse))
		soap_mark_tns__GetControlResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__GetControlResponse(struct soap *soap, const struct tns__GetControlResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__GetControlResponse(struct soap *soap, struct tns__GetControlResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__GetControlResponse(struct soap *soap, struct tns__GetControlResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__GetControlResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__GetControlResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__GetControlResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__GetControlResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__GetControlResponse(struct soap *soap, const char *tag, int id, const struct tns__GetControlResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__GetControlResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__GetControlResponse * SOAP_FMAC2 soap_get_tns__GetControlResponse(struct soap *soap, struct tns__GetControlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__GetControlResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__GetControlResponse * SOAP_FMAC2 soap_in_tns__GetControlResponse(struct soap *soap, const char *tag, struct tns__GetControlResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__GetControlResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__GetControlResponse, sizeof(struct tns__GetControlResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__GetControlResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__GetControlResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__GetControlResponse, sizeof(struct tns__GetControlResponse), 0), SOAP_TYPE_tns__GetControlResponse, sizeof(struct tns__GetControlResponse));
		if (soap->alloced)
			soap_default_tns__GetControlResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__DestroyResponse(struct soap *soap, struct tns__DestroyResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__DestroyResponse))
		soap_mark_tns__DestroyResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__DestroyResponse(struct soap *soap, const struct tns__DestroyResponse *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__DestroyResponse(struct soap *soap, struct tns__DestroyResponse *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__DestroyResponse(struct soap *soap, struct tns__DestroyResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__DestroyResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__DestroyResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__DestroyResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__DestroyResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__DestroyResponse(struct soap *soap, const char *tag, int id, const struct tns__DestroyResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__DestroyResponse), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__DestroyResponse * SOAP_FMAC2 soap_get_tns__DestroyResponse(struct soap *soap, struct tns__DestroyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__DestroyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__DestroyResponse * SOAP_FMAC2 soap_in_tns__DestroyResponse(struct soap *soap, const char *tag, struct tns__DestroyResponse *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__DestroyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__DestroyResponse, sizeof(struct tns__DestroyResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__DestroyResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__DestroyResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__DestroyResponse, sizeof(struct tns__DestroyResponse), 0), SOAP_TYPE_tns__DestroyResponse, sizeof(struct tns__DestroyResponse));
		if (soap->alloced)
			soap_default_tns__DestroyResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__GetNotificationsResponse(struct soap *soap, struct tns__GetNotificationsResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__GetNotificationsResponse))
		soap_mark_tns__GetNotificationsResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__GetNotificationsResponse(struct soap *soap, const struct tns__GetNotificationsResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__GetNotificationsResponse(struct soap *soap, struct tns__GetNotificationsResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__GetNotificationsResponse(struct soap *soap, struct tns__GetNotificationsResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__GetNotificationsResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__GetNotificationsResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__GetNotificationsResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__GetNotificationsResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__GetNotificationsResponse(struct soap *soap, const char *tag, int id, const struct tns__GetNotificationsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__GetNotificationsResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__GetNotificationsResponse * SOAP_FMAC2 soap_get_tns__GetNotificationsResponse(struct soap *soap, struct tns__GetNotificationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__GetNotificationsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__GetNotificationsResponse * SOAP_FMAC2 soap_in_tns__GetNotificationsResponse(struct soap *soap, const char *tag, struct tns__GetNotificationsResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__GetNotificationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__GetNotificationsResponse, sizeof(struct tns__GetNotificationsResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__GetNotificationsResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__GetNotificationsResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__GetNotificationsResponse, sizeof(struct tns__GetNotificationsResponse), 0), SOAP_TYPE_tns__GetNotificationsResponse, sizeof(struct tns__GetNotificationsResponse));
		if (soap->alloced)
			soap_default_tns__GetNotificationsResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__PauseResponse(struct soap *soap, struct tns__PauseResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__PauseResponse))
		soap_mark_tns__PauseResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__PauseResponse(struct soap *soap, const struct tns__PauseResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__PauseResponse(struct soap *soap, struct tns__PauseResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__PauseResponse(struct soap *soap, struct tns__PauseResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__PauseResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__PauseResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__PauseResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__PauseResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__PauseResponse(struct soap *soap, const char *tag, int id, const struct tns__PauseResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__PauseResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__PauseResponse * SOAP_FMAC2 soap_get_tns__PauseResponse(struct soap *soap, struct tns__PauseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__PauseResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__PauseResponse * SOAP_FMAC2 soap_in_tns__PauseResponse(struct soap *soap, const char *tag, struct tns__PauseResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__PauseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__PauseResponse, sizeof(struct tns__PauseResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__PauseResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__PauseResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__PauseResponse, sizeof(struct tns__PauseResponse), 0), SOAP_TYPE_tns__PauseResponse, sizeof(struct tns__PauseResponse));
		if (soap->alloced)
			soap_default_tns__PauseResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__findServiceDataResponse(struct soap *soap, struct tns__findServiceDataResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__findServiceDataResponse))
		soap_mark_tns__findServiceDataResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__findServiceDataResponse(struct soap *soap, const struct tns__findServiceDataResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__findServiceDataResponse(struct soap *soap, struct tns__findServiceDataResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__findServiceDataResponse(struct soap *soap, struct tns__findServiceDataResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__findServiceDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__findServiceDataResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__findServiceDataResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__findServiceDataResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__findServiceDataResponse(struct soap *soap, const char *tag, int id, const struct tns__findServiceDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__findServiceDataResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__findServiceDataResponse * SOAP_FMAC2 soap_get_tns__findServiceDataResponse(struct soap *soap, struct tns__findServiceDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__findServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__findServiceDataResponse * SOAP_FMAC2 soap_in_tns__findServiceDataResponse(struct soap *soap, const char *tag, struct tns__findServiceDataResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__findServiceDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__findServiceDataResponse, sizeof(struct tns__findServiceDataResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__findServiceDataResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__findServiceDataResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__findServiceDataResponse, sizeof(struct tns__findServiceDataResponse), 0), SOAP_TYPE_tns__findServiceDataResponse, sizeof(struct tns__findServiceDataResponse));
		if (soap->alloced)
			soap_default_tns__findServiceDataResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__AttachResponse(struct soap *soap, struct tns__AttachResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__AttachResponse))
		soap_mark_tns__AttachResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__AttachResponse(struct soap *soap, const struct tns__AttachResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__AttachResponse(struct soap *soap, struct tns__AttachResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__AttachResponse(struct soap *soap, struct tns__AttachResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__AttachResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__AttachResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__AttachResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__AttachResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__AttachResponse(struct soap *soap, const char *tag, int id, const struct tns__AttachResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__AttachResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__AttachResponse * SOAP_FMAC2 soap_get_tns__AttachResponse(struct soap *soap, struct tns__AttachResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__AttachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__AttachResponse * SOAP_FMAC2 soap_in_tns__AttachResponse(struct soap *soap, const char *tag, struct tns__AttachResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__AttachResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__AttachResponse, sizeof(struct tns__AttachResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__AttachResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__AttachResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__AttachResponse, sizeof(struct tns__AttachResponse), 0), SOAP_TYPE_tns__AttachResponse, sizeof(struct tns__AttachResponse));
		if (soap->alloced)
			soap_default_tns__AttachResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__PutStatusResponse(struct soap *soap, struct tns__PutStatusResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__PutStatusResponse))
		soap_mark_tns__PutStatusResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__PutStatusResponse(struct soap *soap, const struct tns__PutStatusResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__PutStatusResponse(struct soap *soap, struct tns__PutStatusResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__PutStatusResponse(struct soap *soap, struct tns__PutStatusResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__PutStatusResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__PutStatusResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__PutStatusResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__PutStatusResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__PutStatusResponse(struct soap *soap, const char *tag, int id, const struct tns__PutStatusResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__PutStatusResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__PutStatusResponse * SOAP_FMAC2 soap_get_tns__PutStatusResponse(struct soap *soap, struct tns__PutStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__PutStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__PutStatusResponse * SOAP_FMAC2 soap_in_tns__PutStatusResponse(struct soap *soap, const char *tag, struct tns__PutStatusResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__PutStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__PutStatusResponse, sizeof(struct tns__PutStatusResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__PutStatusResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__PutStatusResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__PutStatusResponse, sizeof(struct tns__PutStatusResponse), 0), SOAP_TYPE_tns__PutStatusResponse, sizeof(struct tns__PutStatusResponse));
		if (soap->alloced)
			soap_default_tns__PutStatusResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__PutControlResponse(struct soap *soap, struct tns__PutControlResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__PutControlResponse))
		soap_mark_tns__PutControlResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__PutControlResponse(struct soap *soap, const struct tns__PutControlResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__PutControlResponse(struct soap *soap, struct tns__PutControlResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__PutControlResponse(struct soap *soap, struct tns__PutControlResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__PutControlResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__PutControlResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__PutControlResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__PutControlResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__PutControlResponse(struct soap *soap, const char *tag, int id, const struct tns__PutControlResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__PutControlResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__PutControlResponse * SOAP_FMAC2 soap_get_tns__PutControlResponse(struct soap *soap, struct tns__PutControlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__PutControlResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__PutControlResponse * SOAP_FMAC2 soap_in_tns__PutControlResponse(struct soap *soap, const char *tag, struct tns__PutControlResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__PutControlResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__PutControlResponse, sizeof(struct tns__PutControlResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__PutControlResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__PutControlResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__PutControlResponse, sizeof(struct tns__PutControlResponse), 0), SOAP_TYPE_tns__PutControlResponse, sizeof(struct tns__PutControlResponse));
		if (soap->alloced)
			soap_default_tns__PutControlResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__AppDetachResponse(struct soap *soap, struct tns__AppDetachResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__AppDetachResponse))
		soap_mark_tns__AppDetachResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__AppDetachResponse(struct soap *soap, const struct tns__AppDetachResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__AppDetachResponse(struct soap *soap, struct tns__AppDetachResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__AppDetachResponse(struct soap *soap, struct tns__AppDetachResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__AppDetachResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__AppDetachResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__AppDetachResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__AppDetachResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__AppDetachResponse(struct soap *soap, const char *tag, int id, const struct tns__AppDetachResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__AppDetachResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__AppDetachResponse * SOAP_FMAC2 soap_get_tns__AppDetachResponse(struct soap *soap, struct tns__AppDetachResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__AppDetachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__AppDetachResponse * SOAP_FMAC2 soap_in_tns__AppDetachResponse(struct soap *soap, const char *tag, struct tns__AppDetachResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__AppDetachResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__AppDetachResponse, sizeof(struct tns__AppDetachResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__AppDetachResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__AppDetachResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__AppDetachResponse, sizeof(struct tns__AppDetachResponse), 0), SOAP_TYPE_tns__AppDetachResponse, sizeof(struct tns__AppDetachResponse));
		if (soap->alloced)
			soap_default_tns__AppDetachResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__ResumeResponse(struct soap *soap, struct tns__ResumeResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__ResumeResponse))
		soap_mark_tns__ResumeResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__ResumeResponse(struct soap *soap, const struct tns__ResumeResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__ResumeResponse(struct soap *soap, struct tns__ResumeResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__ResumeResponse(struct soap *soap, struct tns__ResumeResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__ResumeResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__ResumeResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__ResumeResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__ResumeResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__ResumeResponse(struct soap *soap, const char *tag, int id, const struct tns__ResumeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__ResumeResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__ResumeResponse * SOAP_FMAC2 soap_get_tns__ResumeResponse(struct soap *soap, struct tns__ResumeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__ResumeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__ResumeResponse * SOAP_FMAC2 soap_in_tns__ResumeResponse(struct soap *soap, const char *tag, struct tns__ResumeResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__ResumeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__ResumeResponse, sizeof(struct tns__ResumeResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__ResumeResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__ResumeResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__ResumeResponse, sizeof(struct tns__ResumeResponse), 0), SOAP_TYPE_tns__ResumeResponse, sizeof(struct tns__ResumeResponse));
		if (soap->alloced)
			soap_default_tns__ResumeResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__GetNthDataSourceResponse(struct soap *soap, struct tns__GetNthDataSourceResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__GetNthDataSourceResponse))
		soap_mark_tns__GetNthDataSourceResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__GetNthDataSourceResponse(struct soap *soap, const struct tns__GetNthDataSourceResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__GetNthDataSourceResponse(struct soap *soap, struct tns__GetNthDataSourceResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__GetNthDataSourceResponse(struct soap *soap, struct tns__GetNthDataSourceResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__GetNthDataSourceResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__GetNthDataSourceResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__GetNthDataSourceResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__GetNthDataSourceResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__GetNthDataSourceResponse(struct soap *soap, const char *tag, int id, const struct tns__GetNthDataSourceResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__GetNthDataSourceResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__GetNthDataSourceResponse * SOAP_FMAC2 soap_get_tns__GetNthDataSourceResponse(struct soap *soap, struct tns__GetNthDataSourceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__GetNthDataSourceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__GetNthDataSourceResponse * SOAP_FMAC2 soap_in_tns__GetNthDataSourceResponse(struct soap *soap, const char *tag, struct tns__GetNthDataSourceResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__GetNthDataSourceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__GetNthDataSourceResponse, sizeof(struct tns__GetNthDataSourceResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__GetNthDataSourceResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__GetNthDataSourceResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__GetNthDataSourceResponse, sizeof(struct tns__GetNthDataSourceResponse), 0), SOAP_TYPE_tns__GetNthDataSourceResponse, sizeof(struct tns__GetNthDataSourceResponse));
		if (soap->alloced)
			soap_default_tns__GetNthDataSourceResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__setServiceDataResponse(struct soap *soap, struct tns__setServiceDataResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__setServiceDataResponse))
		soap_mark_tns__setServiceDataResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__setServiceDataResponse(struct soap *soap, const struct tns__setServiceDataResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__setServiceDataResponse(struct soap *soap, struct tns__setServiceDataResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__setServiceDataResponse(struct soap *soap, struct tns__setServiceDataResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__setServiceDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__setServiceDataResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__setServiceDataResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__setServiceDataResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__setServiceDataResponse(struct soap *soap, const char *tag, int id, const struct tns__setServiceDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__setServiceDataResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__setServiceDataResponse * SOAP_FMAC2 soap_get_tns__setServiceDataResponse(struct soap *soap, struct tns__setServiceDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__setServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__setServiceDataResponse * SOAP_FMAC2 soap_in_tns__setServiceDataResponse(struct soap *soap, const char *tag, struct tns__setServiceDataResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__setServiceDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__setServiceDataResponse, sizeof(struct tns__setServiceDataResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__setServiceDataResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__setServiceDataResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__setServiceDataResponse, sizeof(struct tns__setServiceDataResponse), 0), SOAP_TYPE_tns__setServiceDataResponse, sizeof(struct tns__setServiceDataResponse));
		if (soap->alloced)
			soap_default_tns__setServiceDataResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__DetachResponse(struct soap *soap, struct tns__DetachResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__DetachResponse))
		soap_mark_tns__DetachResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__DetachResponse(struct soap *soap, const struct tns__DetachResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__DetachResponse(struct soap *soap, struct tns__DetachResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__DetachResponse(struct soap *soap, struct tns__DetachResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__DetachResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__DetachResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__DetachResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__DetachResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__DetachResponse(struct soap *soap, const char *tag, int id, const struct tns__DetachResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__DetachResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__DetachResponse * SOAP_FMAC2 soap_get_tns__DetachResponse(struct soap *soap, struct tns__DetachResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__DetachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__DetachResponse * SOAP_FMAC2 soap_in_tns__DetachResponse(struct soap *soap, const char *tag, struct tns__DetachResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__DetachResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__DetachResponse, sizeof(struct tns__DetachResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__DetachResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__DetachResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__DetachResponse, sizeof(struct tns__DetachResponse), 0), SOAP_TYPE_tns__DetachResponse, sizeof(struct tns__DetachResponse));
		if (soap->alloced)
			soap_default_tns__DetachResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__AppStopResponse(struct soap *soap, struct tns__AppStopResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__AppStopResponse))
		soap_mark_tns__AppStopResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__AppStopResponse(struct soap *soap, const struct tns__AppStopResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__AppStopResponse(struct soap *soap, struct tns__AppStopResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__AppStopResponse(struct soap *soap, struct tns__AppStopResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__AppStopResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__AppStopResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__AppStopResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__AppStopResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__AppStopResponse(struct soap *soap, const char *tag, int id, const struct tns__AppStopResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__AppStopResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__AppStopResponse * SOAP_FMAC2 soap_get_tns__AppStopResponse(struct soap *soap, struct tns__AppStopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__AppStopResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__AppStopResponse * SOAP_FMAC2 soap_in_tns__AppStopResponse(struct soap *soap, const char *tag, struct tns__AppStopResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__AppStopResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__AppStopResponse, sizeof(struct tns__AppStopResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__AppStopResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__AppStopResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__AppStopResponse, sizeof(struct tns__AppStopResponse), 0), SOAP_TYPE_tns__AppStopResponse, sizeof(struct tns__AppStopResponse));
		if (soap->alloced)
			soap_default_tns__AppStopResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__StopResponse(struct soap *soap, struct tns__StopResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__StopResponse))
		soap_mark_tns__StopResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__StopResponse(struct soap *soap, const struct tns__StopResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__StopResponse(struct soap *soap, struct tns__StopResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__StopResponse(struct soap *soap, struct tns__StopResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__StopResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__StopResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__StopResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__StopResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__StopResponse(struct soap *soap, const char *tag, int id, const struct tns__StopResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__StopResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__StopResponse * SOAP_FMAC2 soap_get_tns__StopResponse(struct soap *soap, struct tns__StopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__StopResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__StopResponse * SOAP_FMAC2 soap_in_tns__StopResponse(struct soap *soap, const char *tag, struct tns__StopResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__StopResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__StopResponse, sizeof(struct tns__StopResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__StopResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__StopResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__StopResponse, sizeof(struct tns__StopResponse), 0), SOAP_TYPE_tns__StopResponse, sizeof(struct tns__StopResponse));
		if (soap->alloced)
			soap_default_tns__StopResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__AppStartResponse(struct soap *soap, struct tns__AppStartResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__AppStartResponse))
		soap_mark_tns__AppStartResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__AppStartResponse(struct soap *soap, const struct tns__AppStartResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__AppStartResponse(struct soap *soap, struct tns__AppStartResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__AppStartResponse(struct soap *soap, struct tns__AppStartResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__AppStartResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__AppStartResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__AppStartResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__AppStartResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__AppStartResponse(struct soap *soap, const char *tag, int id, const struct tns__AppStartResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__AppStartResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__AppStartResponse * SOAP_FMAC2 soap_get_tns__AppStartResponse(struct soap *soap, struct tns__AppStartResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__AppStartResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__AppStartResponse * SOAP_FMAC2 soap_in_tns__AppStartResponse(struct soap *soap, const char *tag, struct tns__AppStartResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__AppStartResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__AppStartResponse, sizeof(struct tns__AppStartResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__AppStartResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__AppStartResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__AppStartResponse, sizeof(struct tns__AppStartResponse), 0), SOAP_TYPE_tns__AppStartResponse, sizeof(struct tns__AppStartResponse));
		if (soap->alloced)
			soap_default_tns__AppStartResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__GetStatusResponse(struct soap *soap, struct tns__GetStatusResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__GetStatusResponse))
		soap_mark_tns__GetStatusResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__GetStatusResponse(struct soap *soap, const struct tns__GetStatusResponse *a)
{
	soap_embedded(soap, &a->_result, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__GetStatusResponse(struct soap *soap, struct tns__GetStatusResponse *a)
{
	soap_default_xsd__string(soap, &a->_result);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__GetStatusResponse(struct soap *soap, struct tns__GetStatusResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__GetStatusResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__GetStatusResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__GetStatusResponse(soap, tag, i, a, type);
		}
	else
		soap_out_tns__GetStatusResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__GetStatusResponse(struct soap *soap, const char *tag, int id, const struct tns__GetStatusResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__GetStatusResponse), type);
	soap_out_xsd__string(soap, "result", -1, &a->_result, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__GetStatusResponse * SOAP_FMAC2 soap_get_tns__GetStatusResponse(struct soap *soap, struct tns__GetStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__GetStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__GetStatusResponse * SOAP_FMAC2 soap_in_tns__GetStatusResponse(struct soap *soap, const char *tag, struct tns__GetStatusResponse *a, const char *type)
{
	short soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__GetStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__GetStatusResponse, sizeof(struct tns__GetStatusResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__GetStatusResponse(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__GetStatusResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__GetStatusResponse, sizeof(struct tns__GetStatusResponse), 0), SOAP_TYPE_tns__GetStatusResponse, sizeof(struct tns__GetStatusResponse));
		if (soap->alloced)
			soap_default_tns__GetStatusResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerToSOAP_ENV__Code))
		soap_mark_PointerToSOAP_ENV__Code(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_mark_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerToSOAP_ENV__Code, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerToSOAP_ENV__Code(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerToSOAP_ENV__Code(soap, tag, i, a, type);
		}
	else
		soap_out_PointerToSOAP_ENV__Code(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_SOAP_ENV__Code, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_SOAP_ENV__Code(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_SOAP_ENV__Code(soap, tag, i, *a, type);
			}
		else
			soap_out_SOAP_ENV__Code(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_SOAP_ENV__Code, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct SOAP_ENV__Code ** SOAP_FMAC2 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code ** SOAP_FMAC2 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	struct SOAP_ENV__Code *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct SOAP_ENV__Code **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToSOAP_ENV__Code, sizeof(struct SOAP_ENV__Code *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_SOAP_ENV__Code(soap, tag, NULL, type)))
		{	a = (struct SOAP_ENV__Code **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerToSOAP_ENV__Code, sizeof(struct SOAP_ENV__Code *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToSOAP_ENV__Code, sizeof(struct SOAP_ENV__Code *), 1), SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__GetControlResponse(struct soap *soap, struct tns__GetControlResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__GetControlResponse))
		soap_mark_PointerTotns__GetControlResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__GetControlResponse(struct soap *soap, struct tns__GetControlResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__GetControlResponse))
		soap_mark_tns__GetControlResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__GetControlResponse(struct soap *soap, struct tns__GetControlResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__GetControlResponse(struct soap *soap, struct tns__GetControlResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__GetControlResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__GetControlResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__GetControlResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__GetControlResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__GetControlResponse(struct soap *soap, const char *tag, int id, struct tns__GetControlResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__GetControlResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__GetControlResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_tns__GetControlResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_tns__GetControlResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_tns__GetControlResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__GetControlResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__GetControlResponse ** SOAP_FMAC2 soap_get_PointerTotns__GetControlResponse(struct soap *soap, struct tns__GetControlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__GetControlResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__GetControlResponse ** SOAP_FMAC2 soap_in_PointerTotns__GetControlResponse(struct soap *soap, const char *tag, struct tns__GetControlResponse **a, const char *type)
{
	struct tns__GetControlResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__GetControlResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__GetControlResponse, sizeof(struct tns__GetControlResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__GetControlResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__GetControlResponse(soap, tag, NULL, type)))
		{	a = (struct tns__GetControlResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTotns__GetControlResponse, sizeof(struct tns__GetControlResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__GetControlResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__GetControlResponse, sizeof(struct tns__GetControlResponse *), 1), SOAP_TYPE_tns__GetControlResponse, sizeof(struct tns__GetControlResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__AttachResponse(struct soap *soap, struct tns__AttachResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__AttachResponse))
		soap_mark_PointerTotns__AttachResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__AttachResponse(struct soap *soap, struct tns__AttachResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__AttachResponse))
		soap_mark_tns__AttachResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__AttachResponse(struct soap *soap, struct tns__AttachResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__AttachResponse(struct soap *soap, struct tns__AttachResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__AttachResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__AttachResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__AttachResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__AttachResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__AttachResponse(struct soap *soap, const char *tag, int id, struct tns__AttachResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__AttachResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__AttachResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_tns__AttachResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_tns__AttachResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_tns__AttachResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__AttachResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__AttachResponse ** SOAP_FMAC2 soap_get_PointerTotns__AttachResponse(struct soap *soap, struct tns__AttachResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__AttachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__AttachResponse ** SOAP_FMAC2 soap_in_PointerTotns__AttachResponse(struct soap *soap, const char *tag, struct tns__AttachResponse **a, const char *type)
{
	struct tns__AttachResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__AttachResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__AttachResponse, sizeof(struct tns__AttachResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__AttachResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__AttachResponse(soap, tag, NULL, type)))
		{	a = (struct tns__AttachResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTotns__AttachResponse, sizeof(struct tns__AttachResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__AttachResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__AttachResponse, sizeof(struct tns__AttachResponse *), 1), SOAP_TYPE_tns__AttachResponse, sizeof(struct tns__AttachResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__AppStartResponse(struct soap *soap, struct tns__AppStartResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__AppStartResponse))
		soap_mark_PointerTotns__AppStartResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__AppStartResponse(struct soap *soap, struct tns__AppStartResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__AppStartResponse))
		soap_mark_tns__AppStartResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__AppStartResponse(struct soap *soap, struct tns__AppStartResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__AppStartResponse(struct soap *soap, struct tns__AppStartResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__AppStartResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__AppStartResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__AppStartResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__AppStartResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__AppStartResponse(struct soap *soap, const char *tag, int id, struct tns__AppStartResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__AppStartResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__AppStartResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_tns__AppStartResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_tns__AppStartResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_tns__AppStartResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__AppStartResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__AppStartResponse ** SOAP_FMAC2 soap_get_PointerTotns__AppStartResponse(struct soap *soap, struct tns__AppStartResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__AppStartResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__AppStartResponse ** SOAP_FMAC2 soap_in_PointerTotns__AppStartResponse(struct soap *soap, const char *tag, struct tns__AppStartResponse **a, const char *type)
{
	struct tns__AppStartResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__AppStartResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__AppStartResponse, sizeof(struct tns__AppStartResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__AppStartResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__AppStartResponse(soap, tag, NULL, type)))
		{	a = (struct tns__AppStartResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTotns__AppStartResponse, sizeof(struct tns__AppStartResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__AppStartResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__AppStartResponse, sizeof(struct tns__AppStartResponse *), 1), SOAP_TYPE_tns__AppStartResponse, sizeof(struct tns__AppStartResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__DestroyResponse(struct soap *soap, struct tns__DestroyResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__DestroyResponse))
		soap_mark_PointerTotns__DestroyResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__DestroyResponse(struct soap *soap, struct tns__DestroyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__DestroyResponse))
		soap_mark_tns__DestroyResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__DestroyResponse(struct soap *soap, struct tns__DestroyResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__DestroyResponse(struct soap *soap, struct tns__DestroyResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__DestroyResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__DestroyResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__DestroyResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__DestroyResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__DestroyResponse(struct soap *soap, const char *tag, int id, struct tns__DestroyResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__DestroyResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__DestroyResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_tns__DestroyResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_tns__DestroyResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_tns__DestroyResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__DestroyResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__DestroyResponse ** SOAP_FMAC2 soap_get_PointerTotns__DestroyResponse(struct soap *soap, struct tns__DestroyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__DestroyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__DestroyResponse ** SOAP_FMAC2 soap_in_PointerTotns__DestroyResponse(struct soap *soap, const char *tag, struct tns__DestroyResponse **a, const char *type)
{
	struct tns__DestroyResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__DestroyResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__DestroyResponse, sizeof(struct tns__DestroyResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__DestroyResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__DestroyResponse(soap, tag, NULL, type)))
		{	a = (struct tns__DestroyResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTotns__DestroyResponse, sizeof(struct tns__DestroyResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__DestroyResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__DestroyResponse, sizeof(struct tns__DestroyResponse *), 1), SOAP_TYPE_tns__DestroyResponse, sizeof(struct tns__DestroyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__PutControlResponse(struct soap *soap, struct tns__PutControlResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__PutControlResponse))
		soap_mark_PointerTotns__PutControlResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__PutControlResponse(struct soap *soap, struct tns__PutControlResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__PutControlResponse))
		soap_mark_tns__PutControlResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__PutControlResponse(struct soap *soap, struct tns__PutControlResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__PutControlResponse(struct soap *soap, struct tns__PutControlResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__PutControlResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__PutControlResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__PutControlResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__PutControlResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__PutControlResponse(struct soap *soap, const char *tag, int id, struct tns__PutControlResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__PutControlResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__PutControlResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_tns__PutControlResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_tns__PutControlResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_tns__PutControlResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__PutControlResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__PutControlResponse ** SOAP_FMAC2 soap_get_PointerTotns__PutControlResponse(struct soap *soap, struct tns__PutControlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__PutControlResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__PutControlResponse ** SOAP_FMAC2 soap_in_PointerTotns__PutControlResponse(struct soap *soap, const char *tag, struct tns__PutControlResponse **a, const char *type)
{
	struct tns__PutControlResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__PutControlResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__PutControlResponse, sizeof(struct tns__PutControlResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__PutControlResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__PutControlResponse(soap, tag, NULL, type)))
		{	a = (struct tns__PutControlResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTotns__PutControlResponse, sizeof(struct tns__PutControlResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__PutControlResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__PutControlResponse, sizeof(struct tns__PutControlResponse *), 1), SOAP_TYPE_tns__PutControlResponse, sizeof(struct tns__PutControlResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__ResumeResponse(struct soap *soap, struct tns__ResumeResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__ResumeResponse))
		soap_mark_PointerTotns__ResumeResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__ResumeResponse(struct soap *soap, struct tns__ResumeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__ResumeResponse))
		soap_mark_tns__ResumeResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__ResumeResponse(struct soap *soap, struct tns__ResumeResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__ResumeResponse(struct soap *soap, struct tns__ResumeResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__ResumeResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__ResumeResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__ResumeResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__ResumeResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__ResumeResponse(struct soap *soap, const char *tag, int id, struct tns__ResumeResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__ResumeResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__ResumeResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_tns__ResumeResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_tns__ResumeResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_tns__ResumeResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__ResumeResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__ResumeResponse ** SOAP_FMAC2 soap_get_PointerTotns__ResumeResponse(struct soap *soap, struct tns__ResumeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__ResumeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__ResumeResponse ** SOAP_FMAC2 soap_in_PointerTotns__ResumeResponse(struct soap *soap, const char *tag, struct tns__ResumeResponse **a, const char *type)
{
	struct tns__ResumeResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__ResumeResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__ResumeResponse, sizeof(struct tns__ResumeResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__ResumeResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__ResumeResponse(soap, tag, NULL, type)))
		{	a = (struct tns__ResumeResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTotns__ResumeResponse, sizeof(struct tns__ResumeResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__ResumeResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__ResumeResponse, sizeof(struct tns__ResumeResponse *), 1), SOAP_TYPE_tns__ResumeResponse, sizeof(struct tns__ResumeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__GetStatusResponse(struct soap *soap, struct tns__GetStatusResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__GetStatusResponse))
		soap_mark_PointerTotns__GetStatusResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__GetStatusResponse(struct soap *soap, struct tns__GetStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__GetStatusResponse))
		soap_mark_tns__GetStatusResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__GetStatusResponse(struct soap *soap, struct tns__GetStatusResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__GetStatusResponse(struct soap *soap, struct tns__GetStatusResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__GetStatusResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__GetStatusResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__GetStatusResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__GetStatusResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__GetStatusResponse(struct soap *soap, const char *tag, int id, struct tns__GetStatusResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__GetStatusResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__GetStatusResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_tns__GetStatusResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_tns__GetStatusResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_tns__GetStatusResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__GetStatusResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__GetStatusResponse ** SOAP_FMAC2 soap_get_PointerTotns__GetStatusResponse(struct soap *soap, struct tns__GetStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__GetStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__GetStatusResponse ** SOAP_FMAC2 soap_in_PointerTotns__GetStatusResponse(struct soap *soap, const char *tag, struct tns__GetStatusResponse **a, const char *type)
{
	struct tns__GetStatusResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__GetStatusResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__GetStatusResponse, sizeof(struct tns__GetStatusResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__GetStatusResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__GetStatusResponse(soap, tag, NULL, type)))
		{	a = (struct tns__GetStatusResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTotns__GetStatusResponse, sizeof(struct tns__GetStatusResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__GetStatusResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__GetStatusResponse, sizeof(struct tns__GetStatusResponse *), 1), SOAP_TYPE_tns__GetStatusResponse, sizeof(struct tns__GetStatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__PutStatusResponse(struct soap *soap, struct tns__PutStatusResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__PutStatusResponse))
		soap_mark_PointerTotns__PutStatusResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__PutStatusResponse(struct soap *soap, struct tns__PutStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__PutStatusResponse))
		soap_mark_tns__PutStatusResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__PutStatusResponse(struct soap *soap, struct tns__PutStatusResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__PutStatusResponse(struct soap *soap, struct tns__PutStatusResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__PutStatusResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__PutStatusResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__PutStatusResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__PutStatusResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__PutStatusResponse(struct soap *soap, const char *tag, int id, struct tns__PutStatusResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__PutStatusResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__PutStatusResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_tns__PutStatusResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_tns__PutStatusResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_tns__PutStatusResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__PutStatusResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__PutStatusResponse ** SOAP_FMAC2 soap_get_PointerTotns__PutStatusResponse(struct soap *soap, struct tns__PutStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__PutStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__PutStatusResponse ** SOAP_FMAC2 soap_in_PointerTotns__PutStatusResponse(struct soap *soap, const char *tag, struct tns__PutStatusResponse **a, const char *type)
{
	struct tns__PutStatusResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__PutStatusResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__PutStatusResponse, sizeof(struct tns__PutStatusResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__PutStatusResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__PutStatusResponse(soap, tag, NULL, type)))
		{	a = (struct tns__PutStatusResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTotns__PutStatusResponse, sizeof(struct tns__PutStatusResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__PutStatusResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__PutStatusResponse, sizeof(struct tns__PutStatusResponse *), 1), SOAP_TYPE_tns__PutStatusResponse, sizeof(struct tns__PutStatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__GetNthDataSourceResponse(struct soap *soap, struct tns__GetNthDataSourceResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__GetNthDataSourceResponse))
		soap_mark_PointerTotns__GetNthDataSourceResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__GetNthDataSourceResponse(struct soap *soap, struct tns__GetNthDataSourceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__GetNthDataSourceResponse))
		soap_mark_tns__GetNthDataSourceResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__GetNthDataSourceResponse(struct soap *soap, struct tns__GetNthDataSourceResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__GetNthDataSourceResponse(struct soap *soap, struct tns__GetNthDataSourceResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__GetNthDataSourceResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__GetNthDataSourceResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__GetNthDataSourceResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__GetNthDataSourceResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__GetNthDataSourceResponse(struct soap *soap, const char *tag, int id, struct tns__GetNthDataSourceResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__GetNthDataSourceResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__GetNthDataSourceResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_tns__GetNthDataSourceResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_tns__GetNthDataSourceResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_tns__GetNthDataSourceResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__GetNthDataSourceResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__GetNthDataSourceResponse ** SOAP_FMAC2 soap_get_PointerTotns__GetNthDataSourceResponse(struct soap *soap, struct tns__GetNthDataSourceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__GetNthDataSourceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__GetNthDataSourceResponse ** SOAP_FMAC2 soap_in_PointerTotns__GetNthDataSourceResponse(struct soap *soap, const char *tag, struct tns__GetNthDataSourceResponse **a, const char *type)
{
	struct tns__GetNthDataSourceResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__GetNthDataSourceResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__GetNthDataSourceResponse, sizeof(struct tns__GetNthDataSourceResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__GetNthDataSourceResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__GetNthDataSourceResponse(soap, tag, NULL, type)))
		{	a = (struct tns__GetNthDataSourceResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTotns__GetNthDataSourceResponse, sizeof(struct tns__GetNthDataSourceResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__GetNthDataSourceResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__GetNthDataSourceResponse, sizeof(struct tns__GetNthDataSourceResponse *), 1), SOAP_TYPE_tns__GetNthDataSourceResponse, sizeof(struct tns__GetNthDataSourceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__StopResponse(struct soap *soap, struct tns__StopResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__StopResponse))
		soap_mark_PointerTotns__StopResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__StopResponse(struct soap *soap, struct tns__StopResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__StopResponse))
		soap_mark_tns__StopResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__StopResponse(struct soap *soap, struct tns__StopResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__StopResponse(struct soap *soap, struct tns__StopResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__StopResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__StopResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__StopResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__StopResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__StopResponse(struct soap *soap, const char *tag, int id, struct tns__StopResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__StopResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__StopResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_tns__StopResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_tns__StopResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_tns__StopResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__StopResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__StopResponse ** SOAP_FMAC2 soap_get_PointerTotns__StopResponse(struct soap *soap, struct tns__StopResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__StopResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__StopResponse ** SOAP_FMAC2 soap_in_PointerTotns__StopResponse(struct soap *soap, const char *tag, struct tns__StopResponse **a, const char *type)
{
	struct tns__StopResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__StopResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__StopResponse, sizeof(struct tns__StopResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__StopResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__StopResponse(soap, tag, NULL, type)))
		{	a = (struct tns__StopResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTotns__StopResponse, sizeof(struct tns__StopResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__StopResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__StopResponse, sizeof(struct tns__StopResponse *), 1), SOAP_TYPE_tns__StopResponse, sizeof(struct tns__StopResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__PauseResponse(struct soap *soap, struct tns__PauseResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__PauseResponse))
		soap_mark_PointerTotns__PauseResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__PauseResponse(struct soap *soap, struct tns__PauseResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__PauseResponse))
		soap_mark_tns__PauseResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__PauseResponse(struct soap *soap, struct tns__PauseResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__PauseResponse(struct soap *soap, struct tns__PauseResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__PauseResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__PauseResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__PauseResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__PauseResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__PauseResponse(struct soap *soap, const char *tag, int id, struct tns__PauseResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__PauseResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__PauseResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_tns__PauseResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_tns__PauseResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_tns__PauseResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__PauseResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__PauseResponse ** SOAP_FMAC2 soap_get_PointerTotns__PauseResponse(struct soap *soap, struct tns__PauseResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__PauseResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__PauseResponse ** SOAP_FMAC2 soap_in_PointerTotns__PauseResponse(struct soap *soap, const char *tag, struct tns__PauseResponse **a, const char *type)
{
	struct tns__PauseResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__PauseResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__PauseResponse, sizeof(struct tns__PauseResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__PauseResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__PauseResponse(soap, tag, NULL, type)))
		{	a = (struct tns__PauseResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTotns__PauseResponse, sizeof(struct tns__PauseResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__PauseResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__PauseResponse, sizeof(struct tns__PauseResponse *), 1), SOAP_TYPE_tns__PauseResponse, sizeof(struct tns__PauseResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__setServiceDataResponse(struct soap *soap, struct tns__setServiceDataResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__setServiceDataResponse))
		soap_mark_PointerTotns__setServiceDataResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__setServiceDataResponse(struct soap *soap, struct tns__setServiceDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__setServiceDataResponse))
		soap_mark_tns__setServiceDataResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__setServiceDataResponse(struct soap *soap, struct tns__setServiceDataResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__setServiceDataResponse(struct soap *soap, struct tns__setServiceDataResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__setServiceDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__setServiceDataResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__setServiceDataResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__setServiceDataResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__setServiceDataResponse(struct soap *soap, const char *tag, int id, struct tns__setServiceDataResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__setServiceDataResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__setServiceDataResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_tns__setServiceDataResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_tns__setServiceDataResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_tns__setServiceDataResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__setServiceDataResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__setServiceDataResponse ** SOAP_FMAC2 soap_get_PointerTotns__setServiceDataResponse(struct soap *soap, struct tns__setServiceDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__setServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__setServiceDataResponse ** SOAP_FMAC2 soap_in_PointerTotns__setServiceDataResponse(struct soap *soap, const char *tag, struct tns__setServiceDataResponse **a, const char *type)
{
	struct tns__setServiceDataResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__setServiceDataResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__setServiceDataResponse, sizeof(struct tns__setServiceDataResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__setServiceDataResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__setServiceDataResponse(soap, tag, NULL, type)))
		{	a = (struct tns__setServiceDataResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTotns__setServiceDataResponse, sizeof(struct tns__setServiceDataResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__setServiceDataResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__setServiceDataResponse, sizeof(struct tns__setServiceDataResponse *), 1), SOAP_TYPE_tns__setServiceDataResponse, sizeof(struct tns__setServiceDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__AppStopResponse(struct soap *soap, struct tns__AppStopResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__AppStopResponse))
		soap_mark_PointerTotns__AppStopResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__AppStopResponse(struct soap *soap, struct tns__AppStopResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__AppStopResponse))
		soap_mark_tns__AppStopResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__AppStopResponse(struct soap *soap, struct tns__AppStopResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__AppStopResponse(struct soap *soap, struct tns__AppStopResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__AppStopResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__AppStopResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__AppStopResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__AppStopResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__AppStopResponse(struct soap *soap, const char *tag, int id, struct tns__AppStopResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__AppStopResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__AppStopResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_tns__AppStopResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_tns__AppStopResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_tns__AppStopResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__AppStopResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__AppStopResponse ** SOAP_FMAC2 soap_get_PointerTotns__AppStopResponse(struct soap *soap, struct tns__AppStopResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__AppStopResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__AppStopResponse ** SOAP_FMAC2 soap_in_PointerTotns__AppStopResponse(struct soap *soap, const char *tag, struct tns__AppStopResponse **a, const char *type)
{
	struct tns__AppStopResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__AppStopResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__AppStopResponse, sizeof(struct tns__AppStopResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__AppStopResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__AppStopResponse(soap, tag, NULL, type)))
		{	a = (struct tns__AppStopResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTotns__AppStopResponse, sizeof(struct tns__AppStopResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__AppStopResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__AppStopResponse, sizeof(struct tns__AppStopResponse *), 1), SOAP_TYPE_tns__AppStopResponse, sizeof(struct tns__AppStopResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__findServiceDataResponse(struct soap *soap, struct tns__findServiceDataResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__findServiceDataResponse))
		soap_mark_PointerTotns__findServiceDataResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__findServiceDataResponse(struct soap *soap, struct tns__findServiceDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__findServiceDataResponse))
		soap_mark_tns__findServiceDataResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__findServiceDataResponse(struct soap *soap, struct tns__findServiceDataResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__findServiceDataResponse(struct soap *soap, struct tns__findServiceDataResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__findServiceDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__findServiceDataResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__findServiceDataResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__findServiceDataResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__findServiceDataResponse(struct soap *soap, const char *tag, int id, struct tns__findServiceDataResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__findServiceDataResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__findServiceDataResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_tns__findServiceDataResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_tns__findServiceDataResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_tns__findServiceDataResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__findServiceDataResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__findServiceDataResponse ** SOAP_FMAC2 soap_get_PointerTotns__findServiceDataResponse(struct soap *soap, struct tns__findServiceDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__findServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__findServiceDataResponse ** SOAP_FMAC2 soap_in_PointerTotns__findServiceDataResponse(struct soap *soap, const char *tag, struct tns__findServiceDataResponse **a, const char *type)
{
	struct tns__findServiceDataResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__findServiceDataResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__findServiceDataResponse, sizeof(struct tns__findServiceDataResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__findServiceDataResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__findServiceDataResponse(soap, tag, NULL, type)))
		{	a = (struct tns__findServiceDataResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTotns__findServiceDataResponse, sizeof(struct tns__findServiceDataResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__findServiceDataResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__findServiceDataResponse, sizeof(struct tns__findServiceDataResponse *), 1), SOAP_TYPE_tns__findServiceDataResponse, sizeof(struct tns__findServiceDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__DetachResponse(struct soap *soap, struct tns__DetachResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__DetachResponse))
		soap_mark_PointerTotns__DetachResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__DetachResponse(struct soap *soap, struct tns__DetachResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__DetachResponse))
		soap_mark_tns__DetachResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__DetachResponse(struct soap *soap, struct tns__DetachResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__DetachResponse(struct soap *soap, struct tns__DetachResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__DetachResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__DetachResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__DetachResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__DetachResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__DetachResponse(struct soap *soap, const char *tag, int id, struct tns__DetachResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__DetachResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__DetachResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_tns__DetachResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_tns__DetachResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_tns__DetachResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__DetachResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__DetachResponse ** SOAP_FMAC2 soap_get_PointerTotns__DetachResponse(struct soap *soap, struct tns__DetachResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__DetachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__DetachResponse ** SOAP_FMAC2 soap_in_PointerTotns__DetachResponse(struct soap *soap, const char *tag, struct tns__DetachResponse **a, const char *type)
{
	struct tns__DetachResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__DetachResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__DetachResponse, sizeof(struct tns__DetachResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__DetachResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__DetachResponse(soap, tag, NULL, type)))
		{	a = (struct tns__DetachResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTotns__DetachResponse, sizeof(struct tns__DetachResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__DetachResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__DetachResponse, sizeof(struct tns__DetachResponse *), 1), SOAP_TYPE_tns__DetachResponse, sizeof(struct tns__DetachResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__AppDetachResponse(struct soap *soap, struct tns__AppDetachResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__AppDetachResponse))
		soap_mark_PointerTotns__AppDetachResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__AppDetachResponse(struct soap *soap, struct tns__AppDetachResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__AppDetachResponse))
		soap_mark_tns__AppDetachResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__AppDetachResponse(struct soap *soap, struct tns__AppDetachResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__AppDetachResponse(struct soap *soap, struct tns__AppDetachResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__AppDetachResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__AppDetachResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__AppDetachResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__AppDetachResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__AppDetachResponse(struct soap *soap, const char *tag, int id, struct tns__AppDetachResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__AppDetachResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__AppDetachResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_tns__AppDetachResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_tns__AppDetachResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_tns__AppDetachResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__AppDetachResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__AppDetachResponse ** SOAP_FMAC2 soap_get_PointerTotns__AppDetachResponse(struct soap *soap, struct tns__AppDetachResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__AppDetachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__AppDetachResponse ** SOAP_FMAC2 soap_in_PointerTotns__AppDetachResponse(struct soap *soap, const char *tag, struct tns__AppDetachResponse **a, const char *type)
{
	struct tns__AppDetachResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__AppDetachResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__AppDetachResponse, sizeof(struct tns__AppDetachResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__AppDetachResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__AppDetachResponse(soap, tag, NULL, type)))
		{	a = (struct tns__AppDetachResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTotns__AppDetachResponse, sizeof(struct tns__AppDetachResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__AppDetachResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__AppDetachResponse, sizeof(struct tns__AppDetachResponse *), 1), SOAP_TYPE_tns__AppDetachResponse, sizeof(struct tns__AppDetachResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__GetNotificationsResponse(struct soap *soap, struct tns__GetNotificationsResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__GetNotificationsResponse))
		soap_mark_PointerTotns__GetNotificationsResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__GetNotificationsResponse(struct soap *soap, struct tns__GetNotificationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__GetNotificationsResponse))
		soap_mark_tns__GetNotificationsResponse(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__GetNotificationsResponse(struct soap *soap, struct tns__GetNotificationsResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__GetNotificationsResponse(struct soap *soap, struct tns__GetNotificationsResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__GetNotificationsResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__GetNotificationsResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__GetNotificationsResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__GetNotificationsResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__GetNotificationsResponse(struct soap *soap, const char *tag, int id, struct tns__GetNotificationsResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__GetNotificationsResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__GetNotificationsResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_tns__GetNotificationsResponse(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_tns__GetNotificationsResponse(soap, tag, i, *a, type);
			}
		else
			soap_out_tns__GetNotificationsResponse(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__GetNotificationsResponse, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__GetNotificationsResponse ** SOAP_FMAC2 soap_get_PointerTotns__GetNotificationsResponse(struct soap *soap, struct tns__GetNotificationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__GetNotificationsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__GetNotificationsResponse ** SOAP_FMAC2 soap_in_PointerTotns__GetNotificationsResponse(struct soap *soap, const char *tag, struct tns__GetNotificationsResponse **a, const char *type)
{
	struct tns__GetNotificationsResponse *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct tns__GetNotificationsResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__GetNotificationsResponse, sizeof(struct tns__GetNotificationsResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_tns__GetNotificationsResponse(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_tns__GetNotificationsResponse(soap, tag, NULL, type)))
		{	a = (struct tns__GetNotificationsResponse **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTotns__GetNotificationsResponse, sizeof(struct tns__GetNotificationsResponse *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct tns__GetNotificationsResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__GetNotificationsResponse, sizeof(struct tns__GetNotificationsResponse *), 1), SOAP_TYPE_tns__GetNotificationsResponse, sizeof(struct tns__GetNotificationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__PutStatusRequest(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__PutStatusRequest
	*a = SOAP_DEFAULT_xsdl__PutStatusRequest;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__PutStatusRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__PutStatusRequest);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__PutStatusRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__PutStatusRequest);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__PutStatusRequest(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__PutStatusRequest, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__PutStatusRequest(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__PutStatusRequest(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__PutStatusRequest(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__PutStatusRequest(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__PutStatusRequest);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__PutStatusRequest(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__PutStatusRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__PutStatusRequest(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__PutStatusRequest, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__StopRequest(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__StopRequest
	*a = SOAP_DEFAULT_xsdl__StopRequest;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__StopRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__StopRequest);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__StopRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__StopRequest);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__StopRequest(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__StopRequest, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__StopRequest(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__StopRequest(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__StopRequest(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__StopRequest(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__StopRequest);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__StopRequest(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__StopRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__StopRequest(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__StopRequest, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__DetachRequest(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__DetachRequest
	*a = SOAP_DEFAULT_xsdl__DetachRequest;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__DetachRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__DetachRequest);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__DetachRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__DetachRequest);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__DetachRequest(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__DetachRequest, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__DetachRequest(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__DetachRequest(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__DetachRequest(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__DetachRequest(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__DetachRequest);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__DetachRequest(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__DetachRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__DetachRequest(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__DetachRequest, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__AppDetachRequest(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__AppDetachRequest
	*a = SOAP_DEFAULT_xsdl__AppDetachRequest;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__AppDetachRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__AppDetachRequest);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__AppDetachRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__AppDetachRequest);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__AppDetachRequest(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__AppDetachRequest, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__AppDetachRequest(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__AppDetachRequest(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__AppDetachRequest(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__AppDetachRequest(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__AppDetachRequest);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__AppDetachRequest(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__AppDetachRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__AppDetachRequest(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__AppDetachRequest, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__GetNthDataSourceRequest(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__GetNthDataSourceRequest
	*a = SOAP_DEFAULT_xsdl__GetNthDataSourceRequest;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__GetNthDataSourceRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__GetNthDataSourceRequest);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__GetNthDataSourceRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__GetNthDataSourceRequest);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__GetNthDataSourceRequest(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__GetNthDataSourceRequest, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__GetNthDataSourceRequest(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__GetNthDataSourceRequest(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__GetNthDataSourceRequest(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__GetNthDataSourceRequest(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__GetNthDataSourceRequest);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__GetNthDataSourceRequest(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__GetNthDataSourceRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__GetNthDataSourceRequest(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__GetNthDataSourceRequest, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__AttachRequest(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__AttachRequest
	*a = SOAP_DEFAULT_xsdl__AttachRequest;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__AttachRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__AttachRequest);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__AttachRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__AttachRequest);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__AttachRequest(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__AttachRequest, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__AttachRequest(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__AttachRequest(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__AttachRequest(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__AttachRequest(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__AttachRequest);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__AttachRequest(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__AttachRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__AttachRequest(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__AttachRequest, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__GetNthDataSourceResponse(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__GetNthDataSourceResponse
	*a = SOAP_DEFAULT_xsdl__GetNthDataSourceResponse;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__GetNthDataSourceResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__GetNthDataSourceResponse);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__GetNthDataSourceResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__GetNthDataSourceResponse);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__GetNthDataSourceResponse(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__GetNthDataSourceResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__GetNthDataSourceResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__GetNthDataSourceResponse(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__GetNthDataSourceResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__GetNthDataSourceResponse(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__GetNthDataSourceResponse);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__GetNthDataSourceResponse(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__GetNthDataSourceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__GetNthDataSourceResponse(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__GetNthDataSourceResponse, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__AppStartRequest(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__AppStartRequest
	*a = SOAP_DEFAULT_xsdl__AppStartRequest;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__AppStartRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__AppStartRequest);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__AppStartRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__AppStartRequest);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__AppStartRequest(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__AppStartRequest, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__AppStartRequest(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__AppStartRequest(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__AppStartRequest(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__AppStartRequest(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__AppStartRequest);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__AppStartRequest(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__AppStartRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__AppStartRequest(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__AppStartRequest, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__AppDetachResponse(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__AppDetachResponse
	*a = SOAP_DEFAULT_xsdl__AppDetachResponse;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__AppDetachResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__AppDetachResponse);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__AppDetachResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__AppDetachResponse);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__AppDetachResponse(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__AppDetachResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__AppDetachResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__AppDetachResponse(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__AppDetachResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__AppDetachResponse(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__AppDetachResponse);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__AppDetachResponse(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__AppDetachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__AppDetachResponse(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__AppDetachResponse, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__PutStatusResponse(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__PutStatusResponse
	*a = SOAP_DEFAULT_xsdl__PutStatusResponse;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__PutStatusResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__PutStatusResponse);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__PutStatusResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__PutStatusResponse);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__PutStatusResponse(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__PutStatusResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__PutStatusResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__PutStatusResponse(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__PutStatusResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__PutStatusResponse(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__PutStatusResponse);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__PutStatusResponse(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__PutStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__PutStatusResponse(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__PutStatusResponse, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__AttachResponse(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__AttachResponse
	*a = SOAP_DEFAULT_xsdl__AttachResponse;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__AttachResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__AttachResponse);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__AttachResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__AttachResponse);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__AttachResponse(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__AttachResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__AttachResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__AttachResponse(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__AttachResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__AttachResponse(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__AttachResponse);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__AttachResponse(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__AttachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__AttachResponse(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__AttachResponse, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__GetControlRequest(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__GetControlRequest
	*a = SOAP_DEFAULT_xsdl__GetControlRequest;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__GetControlRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__GetControlRequest);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__GetControlRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__GetControlRequest);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__GetControlRequest(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__GetControlRequest, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__GetControlRequest(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__GetControlRequest(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__GetControlRequest(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__GetControlRequest(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__GetControlRequest);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__GetControlRequest(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__GetControlRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__GetControlRequest(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__GetControlRequest, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__ResumeResponse(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__ResumeResponse
	*a = SOAP_DEFAULT_xsdl__ResumeResponse;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__ResumeResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__ResumeResponse);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__ResumeResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__ResumeResponse);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__ResumeResponse(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__ResumeResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__ResumeResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__ResumeResponse(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__ResumeResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__ResumeResponse(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__ResumeResponse);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__ResumeResponse(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__ResumeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__ResumeResponse(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__ResumeResponse, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__PutControlResponse(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__PutControlResponse
	*a = SOAP_DEFAULT_xsdl__PutControlResponse;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__PutControlResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__PutControlResponse);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__PutControlResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__PutControlResponse);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__PutControlResponse(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__PutControlResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__PutControlResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__PutControlResponse(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__PutControlResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__PutControlResponse(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__PutControlResponse);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__PutControlResponse(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__PutControlResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__PutControlResponse(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__PutControlResponse, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__PauseResponse(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__PauseResponse
	*a = SOAP_DEFAULT_xsdl__PauseResponse;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__PauseResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__PauseResponse);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__PauseResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__PauseResponse);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__PauseResponse(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__PauseResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__PauseResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__PauseResponse(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__PauseResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__PauseResponse(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__PauseResponse);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__PauseResponse(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__PauseResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__PauseResponse(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__PauseResponse, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__findServiceDataRequest(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__findServiceDataRequest
	*a = SOAP_DEFAULT_xsdl__findServiceDataRequest;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__findServiceDataRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__findServiceDataRequest);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__findServiceDataRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__findServiceDataRequest);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__findServiceDataRequest(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__findServiceDataRequest, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__findServiceDataRequest(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__findServiceDataRequest(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__findServiceDataRequest(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__findServiceDataRequest(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__findServiceDataRequest);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__findServiceDataRequest(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__findServiceDataRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__findServiceDataRequest(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__findServiceDataRequest, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__GetStatusRequest(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__GetStatusRequest
	*a = SOAP_DEFAULT_xsdl__GetStatusRequest;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__GetStatusRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__GetStatusRequest);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__GetStatusRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__GetStatusRequest);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__GetStatusRequest(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__GetStatusRequest, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__GetStatusRequest(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__GetStatusRequest(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__GetStatusRequest(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__GetStatusRequest(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__GetStatusRequest);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__GetStatusRequest(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__GetStatusRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__GetStatusRequest(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__GetStatusRequest, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__setServiceDataResponse(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__setServiceDataResponse
	*a = SOAP_DEFAULT_xsdl__setServiceDataResponse;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__setServiceDataResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__setServiceDataResponse);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__setServiceDataResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__setServiceDataResponse);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__setServiceDataResponse(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__setServiceDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__setServiceDataResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__setServiceDataResponse(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__setServiceDataResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__setServiceDataResponse(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__setServiceDataResponse);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__setServiceDataResponse(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__setServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__setServiceDataResponse(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__setServiceDataResponse, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__StopResponse(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__StopResponse
	*a = SOAP_DEFAULT_xsdl__StopResponse;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__StopResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__StopResponse);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__StopResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__StopResponse);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__StopResponse(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__StopResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__StopResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__StopResponse(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__StopResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__StopResponse(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__StopResponse);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__StopResponse(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__StopResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__StopResponse(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__StopResponse, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__DetachResponse(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__DetachResponse
	*a = SOAP_DEFAULT_xsdl__DetachResponse;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__DetachResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__DetachResponse);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__DetachResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__DetachResponse);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__DetachResponse(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__DetachResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__DetachResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__DetachResponse(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__DetachResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__DetachResponse(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__DetachResponse);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__DetachResponse(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__DetachResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__DetachResponse(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__DetachResponse, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__findServiceDataResponse(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__findServiceDataResponse
	*a = SOAP_DEFAULT_xsdl__findServiceDataResponse;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__findServiceDataResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__findServiceDataResponse);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__findServiceDataResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__findServiceDataResponse);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__findServiceDataResponse(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__findServiceDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__findServiceDataResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__findServiceDataResponse(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__findServiceDataResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__findServiceDataResponse(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__findServiceDataResponse);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__findServiceDataResponse(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__findServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__findServiceDataResponse(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__findServiceDataResponse, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__ResumeRequest(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__ResumeRequest
	*a = SOAP_DEFAULT_xsdl__ResumeRequest;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__ResumeRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__ResumeRequest);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__ResumeRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__ResumeRequest);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__ResumeRequest(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__ResumeRequest, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__ResumeRequest(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__ResumeRequest(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__ResumeRequest(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__ResumeRequest(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__ResumeRequest);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__ResumeRequest(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__ResumeRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__ResumeRequest(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__ResumeRequest, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__AppStopResponse(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__AppStopResponse
	*a = SOAP_DEFAULT_xsdl__AppStopResponse;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__AppStopResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__AppStopResponse);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__AppStopResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__AppStopResponse);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__AppStopResponse(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__AppStopResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__AppStopResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__AppStopResponse(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__AppStopResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__AppStopResponse(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__AppStopResponse);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__AppStopResponse(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__AppStopResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__AppStopResponse(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__AppStopResponse, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__AppStartResponse(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__AppStartResponse
	*a = SOAP_DEFAULT_xsdl__AppStartResponse;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__AppStartResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__AppStartResponse);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__AppStartResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__AppStartResponse);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__AppStartResponse(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__AppStartResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__AppStartResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__AppStartResponse(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__AppStartResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__AppStartResponse(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__AppStartResponse);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__AppStartResponse(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__AppStartResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__AppStartResponse(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__AppStartResponse, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__AppStopRequest(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__AppStopRequest
	*a = SOAP_DEFAULT_xsdl__AppStopRequest;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__AppStopRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__AppStopRequest);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__AppStopRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__AppStopRequest);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__AppStopRequest(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__AppStopRequest, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__AppStopRequest(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__AppStopRequest(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__AppStopRequest(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__AppStopRequest(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__AppStopRequest);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__AppStopRequest(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__AppStopRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__AppStopRequest(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__AppStopRequest, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__PauseRequest(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__PauseRequest
	*a = SOAP_DEFAULT_xsdl__PauseRequest;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__PauseRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__PauseRequest);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__PauseRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__PauseRequest);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__PauseRequest(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__PauseRequest, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__PauseRequest(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__PauseRequest(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__PauseRequest(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__PauseRequest(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__PauseRequest);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__PauseRequest(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__PauseRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__PauseRequest(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__PauseRequest, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__GetNotificationsRequest(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__GetNotificationsRequest
	*a = SOAP_DEFAULT_xsdl__GetNotificationsRequest;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__GetNotificationsRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__GetNotificationsRequest);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__GetNotificationsRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__GetNotificationsRequest);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__GetNotificationsRequest(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__GetNotificationsRequest, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__GetNotificationsRequest(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__GetNotificationsRequest(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__GetNotificationsRequest(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__GetNotificationsRequest(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__GetNotificationsRequest);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__GetNotificationsRequest(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__GetNotificationsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__GetNotificationsRequest(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__GetNotificationsRequest, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__GetStatusResponse(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__GetStatusResponse
	*a = SOAP_DEFAULT_xsdl__GetStatusResponse;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__GetStatusResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__GetStatusResponse);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__GetStatusResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__GetStatusResponse);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__GetStatusResponse(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__GetStatusResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__GetStatusResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__GetStatusResponse(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__GetStatusResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__GetStatusResponse(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__GetStatusResponse);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__GetStatusResponse(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__GetStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__GetStatusResponse(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__GetStatusResponse, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__GetNotificationsResponse(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__GetNotificationsResponse
	*a = SOAP_DEFAULT_xsdl__GetNotificationsResponse;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__GetNotificationsResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__GetNotificationsResponse);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__GetNotificationsResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__GetNotificationsResponse);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__GetNotificationsResponse(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__GetNotificationsResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__GetNotificationsResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__GetNotificationsResponse(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__GetNotificationsResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__GetNotificationsResponse(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__GetNotificationsResponse);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__GetNotificationsResponse(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__GetNotificationsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__GetNotificationsResponse(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__GetNotificationsResponse, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__setServiceDataRequest(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__setServiceDataRequest
	*a = SOAP_DEFAULT_xsdl__setServiceDataRequest;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__setServiceDataRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__setServiceDataRequest);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__setServiceDataRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__setServiceDataRequest);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__setServiceDataRequest(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__setServiceDataRequest, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__setServiceDataRequest(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__setServiceDataRequest(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__setServiceDataRequest(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__setServiceDataRequest(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__setServiceDataRequest);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__setServiceDataRequest(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__setServiceDataRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__setServiceDataRequest(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__setServiceDataRequest, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__DestroyRequest(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__DestroyRequest
	*a = SOAP_DEFAULT_xsdl__DestroyRequest;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__DestroyRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__DestroyRequest);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__DestroyRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__DestroyRequest);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__DestroyRequest(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__DestroyRequest, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__DestroyRequest(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__DestroyRequest(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__DestroyRequest(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__DestroyRequest(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__DestroyRequest);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__DestroyRequest(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__DestroyRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__DestroyRequest(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__DestroyRequest, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__PutControlRequest(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__PutControlRequest
	*a = SOAP_DEFAULT_xsdl__PutControlRequest;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__PutControlRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__PutControlRequest);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__PutControlRequest(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__PutControlRequest);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__PutControlRequest(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__PutControlRequest, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__PutControlRequest(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__PutControlRequest(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__PutControlRequest(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__PutControlRequest(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__PutControlRequest);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__PutControlRequest(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__PutControlRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__PutControlRequest(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__PutControlRequest, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__GetControlResponse(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__GetControlResponse
	*a = SOAP_DEFAULT_xsdl__GetControlResponse;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__GetControlResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__GetControlResponse);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__GetControlResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__GetControlResponse);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__GetControlResponse(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__GetControlResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__GetControlResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__GetControlResponse(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__GetControlResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__GetControlResponse(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__GetControlResponse);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__GetControlResponse(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__GetControlResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__GetControlResponse(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__GetControlResponse, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsdl__DestroyResponse(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsdl__DestroyResponse
	*a = SOAP_DEFAULT_xsdl__DestroyResponse;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsdl__DestroyResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__DestroyResponse);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsdl__DestroyResponse(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsdl__DestroyResponse);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsdl__DestroyResponse(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsdl__DestroyResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsdl__DestroyResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsdl__DestroyResponse(soap, tag, i, a, type);
		}
	else
		soap_out_xsdl__DestroyResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsdl__DestroyResponse(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsdl__DestroyResponse);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsdl__DestroyResponse(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsdl__DestroyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsdl__DestroyResponse(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsdl__DestroyResponse, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsd__integer(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsd__integer
	*a = SOAP_DEFAULT_xsd__integer;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsd__integer(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__integer);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsd__integer(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__integer);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsd__integer(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsd__integer, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsd__integer(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsd__integer(soap, tag, i, a, type);
		}
	else
		soap_out_xsd__integer(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__integer);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsd__integer(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsd__integer(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__integer, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsd__string(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsd__string
	*a = SOAP_DEFAULT_xsd__string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsd__string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__string);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsd__string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__string);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsd__string(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsd__string, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsd__string(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsd__string(soap, tag, i, a, type);
		}
	else
		soap_out_xsd__string(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsd__string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__string);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsd__string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsd__string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__string, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_string(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_string(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_string, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_string(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_string(soap, tag, i, a, type);
		}
	else
		soap_out_string(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1);
}
#ifdef __cplusplus
}
#endif

/* end of soapC.c */
